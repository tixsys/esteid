// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "OpenDocument_manifest.hxx"

namespace manifest
{
  // Manifest
  // 

  const Manifest::File_entrySequence& Manifest::
  file_entry () const
  {
    return this->file_entry_;
  }

  Manifest::File_entrySequence& Manifest::
  file_entry ()
  {
    return this->file_entry_;
  }

  void Manifest::
  file_entry (const File_entrySequence& s)
  {
    this->file_entry_ = s;
  }


  // File_entry
  // 

  const File_entry::Encryption_dataOptional& File_entry::
  encryption_data () const
  {
    return this->encryption_data_;
  }

  File_entry::Encryption_dataOptional& File_entry::
  encryption_data ()
  {
    return this->encryption_data_;
  }

  void File_entry::
  encryption_data (const Encryption_dataType& x)
  {
    this->encryption_data_.set (x);
  }

  void File_entry::
  encryption_data (const Encryption_dataOptional& x)
  {
    this->encryption_data_ = x;
  }

  void File_entry::
  encryption_data (::std::auto_ptr< Encryption_dataType > x)
  {
    this->encryption_data_.set (x);
  }

  const File_entry::Full_pathType& File_entry::
  full_path () const
  {
    return this->full_path_.get ();
  }

  File_entry::Full_pathType& File_entry::
  full_path ()
  {
    return this->full_path_.get ();
  }

  void File_entry::
  full_path (const Full_pathType& x)
  {
    this->full_path_.set (x);
  }

  void File_entry::
  full_path (::std::auto_ptr< Full_pathType > x)
  {
    this->full_path_.set (x);
  }

  const File_entry::SizeOptional& File_entry::
  size () const
  {
    return this->size_;
  }

  File_entry::SizeOptional& File_entry::
  size ()
  {
    return this->size_;
  }

  void File_entry::
  size (const SizeType& x)
  {
    this->size_.set (x);
  }

  void File_entry::
  size (const SizeOptional& x)
  {
    this->size_ = x;
  }

  const File_entry::Media_typeType& File_entry::
  media_type () const
  {
    return this->media_type_.get ();
  }

  File_entry::Media_typeType& File_entry::
  media_type ()
  {
    return this->media_type_.get ();
  }

  void File_entry::
  media_type (const Media_typeType& x)
  {
    this->media_type_.set (x);
  }

  void File_entry::
  media_type (::std::auto_ptr< Media_typeType > x)
  {
    this->media_type_.set (x);
  }


  // Encryption_data
  // 

  const Encryption_data::AlgorithmType& Encryption_data::
  algorithm () const
  {
    return this->algorithm_.get ();
  }

  Encryption_data::AlgorithmType& Encryption_data::
  algorithm ()
  {
    return this->algorithm_.get ();
  }

  void Encryption_data::
  algorithm (const AlgorithmType& x)
  {
    this->algorithm_.set (x);
  }

  void Encryption_data::
  algorithm (::std::auto_ptr< AlgorithmType > x)
  {
    this->algorithm_.set (x);
  }

  const Encryption_data::Key_derivationType& Encryption_data::
  key_derivation () const
  {
    return this->key_derivation_.get ();
  }

  Encryption_data::Key_derivationType& Encryption_data::
  key_derivation ()
  {
    return this->key_derivation_.get ();
  }

  void Encryption_data::
  key_derivation (const Key_derivationType& x)
  {
    this->key_derivation_.set (x);
  }

  void Encryption_data::
  key_derivation (::std::auto_ptr< Key_derivationType > x)
  {
    this->key_derivation_.set (x);
  }

  const Encryption_data::Checksum_typeType& Encryption_data::
  checksum_type () const
  {
    return this->checksum_type_.get ();
  }

  Encryption_data::Checksum_typeType& Encryption_data::
  checksum_type ()
  {
    return this->checksum_type_.get ();
  }

  void Encryption_data::
  checksum_type (const Checksum_typeType& x)
  {
    this->checksum_type_.set (x);
  }

  void Encryption_data::
  checksum_type (::std::auto_ptr< Checksum_typeType > x)
  {
    this->checksum_type_.set (x);
  }

  const Encryption_data::ChecksumType& Encryption_data::
  checksum () const
  {
    return this->checksum_.get ();
  }

  Encryption_data::ChecksumType& Encryption_data::
  checksum ()
  {
    return this->checksum_.get ();
  }

  void Encryption_data::
  checksum (const ChecksumType& x)
  {
    this->checksum_.set (x);
  }

  void Encryption_data::
  checksum (::std::auto_ptr< ChecksumType > x)
  {
    this->checksum_.set (x);
  }


  // Algorithm
  // 

  const Algorithm::Algorithm_nameType& Algorithm::
  algorithm_name () const
  {
    return this->algorithm_name_.get ();
  }

  Algorithm::Algorithm_nameType& Algorithm::
  algorithm_name ()
  {
    return this->algorithm_name_.get ();
  }

  void Algorithm::
  algorithm_name (const Algorithm_nameType& x)
  {
    this->algorithm_name_.set (x);
  }

  void Algorithm::
  algorithm_name (::std::auto_ptr< Algorithm_nameType > x)
  {
    this->algorithm_name_.set (x);
  }

  const Algorithm::Initialisation_vectorType& Algorithm::
  initialisation_vector () const
  {
    return this->initialisation_vector_.get ();
  }

  Algorithm::Initialisation_vectorType& Algorithm::
  initialisation_vector ()
  {
    return this->initialisation_vector_.get ();
  }

  void Algorithm::
  initialisation_vector (const Initialisation_vectorType& x)
  {
    this->initialisation_vector_.set (x);
  }

  void Algorithm::
  initialisation_vector (::std::auto_ptr< Initialisation_vectorType > x)
  {
    this->initialisation_vector_.set (x);
  }


  // Key_derivation
  // 

  const Key_derivation::Key_derivation_nameType& Key_derivation::
  key_derivation_name () const
  {
    return this->key_derivation_name_.get ();
  }

  Key_derivation::Key_derivation_nameType& Key_derivation::
  key_derivation_name ()
  {
    return this->key_derivation_name_.get ();
  }

  void Key_derivation::
  key_derivation_name (const Key_derivation_nameType& x)
  {
    this->key_derivation_name_.set (x);
  }

  void Key_derivation::
  key_derivation_name (::std::auto_ptr< Key_derivation_nameType > x)
  {
    this->key_derivation_name_.set (x);
  }

  const Key_derivation::SaltType& Key_derivation::
  salt () const
  {
    return this->salt_.get ();
  }

  Key_derivation::SaltType& Key_derivation::
  salt ()
  {
    return this->salt_.get ();
  }

  void Key_derivation::
  salt (const SaltType& x)
  {
    this->salt_.set (x);
  }

  void Key_derivation::
  salt (::std::auto_ptr< SaltType > x)
  {
    this->salt_.set (x);
  }

  const Key_derivation::Iteration_countType& Key_derivation::
  iteration_count () const
  {
    return this->iteration_count_.get ();
  }

  Key_derivation::Iteration_countType& Key_derivation::
  iteration_count ()
  {
    return this->iteration_count_.get ();
  }

  void Key_derivation::
  iteration_count (const Iteration_countType& x)
  {
    this->iteration_count_.set (x);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace manifest
{
  // Manifest
  //

  Manifest::
  Manifest ()
  : ::xml_schema::Type (),
    file_entry_ (::xml_schema::Flags (), this)
  {
  }

  Manifest::
  Manifest (const Manifest& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    file_entry_ (x.file_entry_, f, this)
  {
  }

  Manifest::
  Manifest (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    file_entry_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Manifest::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // file-entry
      //
      if (n.name () == "file-entry" && n.namespace_ () == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")
      {
        ::std::auto_ptr< File_entryType > r (
          File_entryTraits::create (i, f, this));

        this->file_entry_.push_back (r);
        continue;
      }

      break;
    }
  }

  Manifest* Manifest::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Manifest (*this, f, c);
  }

  Manifest::
  ~Manifest ()
  {
  }

  // File_entry
  //

  File_entry::
  File_entry (const Full_pathType& full_path,
              const Media_typeType& media_type)
  : ::xml_schema::Type (),
    encryption_data_ (::xml_schema::Flags (), this),
    full_path_ (full_path, ::xml_schema::Flags (), this),
    size_ (::xml_schema::Flags (), this),
    media_type_ (media_type, ::xml_schema::Flags (), this)
  {
  }

  File_entry::
  File_entry (const File_entry& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    encryption_data_ (x.encryption_data_, f, this),
    full_path_ (x.full_path_, f, this),
    size_ (x.size_, f, this),
    media_type_ (x.media_type_, f, this)
  {
  }

  File_entry::
  File_entry (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    encryption_data_ (f, this),
    full_path_ (f, this),
    size_ (f, this),
    media_type_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void File_entry::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // encryption-data
      //
      if (n.name () == "encryption-data" && n.namespace_ () == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")
      {
        ::std::auto_ptr< Encryption_dataType > r (
          Encryption_dataTraits::create (i, f, this));

        if (!this->encryption_data_)
        {
          this->encryption_data_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "full-path" && n.namespace_ () == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")
      {
        ::std::auto_ptr< Full_pathType > r (
          Full_pathTraits::create (i, f, this));

        this->full_path_.set (r);
        continue;
      }

      if (n.name () == "size" && n.namespace_ () == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")
      {
        this->size_.set (SizeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "media-type" && n.namespace_ () == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")
      {
        ::std::auto_ptr< Media_typeType > r (
          Media_typeTraits::create (i, f, this));

        this->media_type_.set (r);
        continue;
      }
    }

    if (!full_path_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "full-path",
        "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0");
    }

    if (!media_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "media-type",
        "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0");
    }
  }

  File_entry* File_entry::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class File_entry (*this, f, c);
  }

  File_entry::
  ~File_entry ()
  {
  }

  // Encryption_data
  //

  Encryption_data::
  Encryption_data (const AlgorithmType& algorithm,
                   const Key_derivationType& key_derivation,
                   const Checksum_typeType& checksum_type,
                   const ChecksumType& checksum)
  : ::xml_schema::Type (),
    algorithm_ (algorithm, ::xml_schema::Flags (), this),
    key_derivation_ (key_derivation, ::xml_schema::Flags (), this),
    checksum_type_ (checksum_type, ::xml_schema::Flags (), this),
    checksum_ (checksum, ::xml_schema::Flags (), this)
  {
  }

  Encryption_data::
  Encryption_data (::std::auto_ptr< AlgorithmType >& algorithm,
                   ::std::auto_ptr< Key_derivationType >& key_derivation,
                   const Checksum_typeType& checksum_type,
                   const ChecksumType& checksum)
  : ::xml_schema::Type (),
    algorithm_ (algorithm, ::xml_schema::Flags (), this),
    key_derivation_ (key_derivation, ::xml_schema::Flags (), this),
    checksum_type_ (checksum_type, ::xml_schema::Flags (), this),
    checksum_ (checksum, ::xml_schema::Flags (), this)
  {
  }

  Encryption_data::
  Encryption_data (const Encryption_data& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    algorithm_ (x.algorithm_, f, this),
    key_derivation_ (x.key_derivation_, f, this),
    checksum_type_ (x.checksum_type_, f, this),
    checksum_ (x.checksum_, f, this)
  {
  }

  Encryption_data::
  Encryption_data (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    algorithm_ (f, this),
    key_derivation_ (f, this),
    checksum_type_ (f, this),
    checksum_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Encryption_data::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // algorithm
      //
      if (n.name () == "algorithm" && n.namespace_ () == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")
      {
        ::std::auto_ptr< AlgorithmType > r (
          AlgorithmTraits::create (i, f, this));

        if (!algorithm_.present ())
        {
          this->algorithm_.set (r);
          continue;
        }
      }

      // key-derivation
      //
      if (n.name () == "key-derivation" && n.namespace_ () == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")
      {
        ::std::auto_ptr< Key_derivationType > r (
          Key_derivationTraits::create (i, f, this));

        if (!key_derivation_.present ())
        {
          this->key_derivation_.set (r);
          continue;
        }
      }

      break;
    }

    if (!algorithm_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "algorithm",
        "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0");
    }

    if (!key_derivation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "key-derivation",
        "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "checksum-type" && n.namespace_ () == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")
      {
        ::std::auto_ptr< Checksum_typeType > r (
          Checksum_typeTraits::create (i, f, this));

        this->checksum_type_.set (r);
        continue;
      }

      if (n.name () == "checksum" && n.namespace_ () == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")
      {
        ::std::auto_ptr< ChecksumType > r (
          ChecksumTraits::create (i, f, this));

        this->checksum_.set (r);
        continue;
      }
    }

    if (!checksum_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "checksum-type",
        "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0");
    }

    if (!checksum_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "checksum",
        "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0");
    }
  }

  Encryption_data* Encryption_data::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Encryption_data (*this, f, c);
  }

  Encryption_data::
  ~Encryption_data ()
  {
  }

  // Algorithm
  //

  Algorithm::
  Algorithm (const Algorithm_nameType& algorithm_name,
             const Initialisation_vectorType& initialisation_vector)
  : ::xml_schema::Type (),
    algorithm_name_ (algorithm_name, ::xml_schema::Flags (), this),
    initialisation_vector_ (initialisation_vector, ::xml_schema::Flags (), this)
  {
  }

  Algorithm::
  Algorithm (const Algorithm& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    algorithm_name_ (x.algorithm_name_, f, this),
    initialisation_vector_ (x.initialisation_vector_, f, this)
  {
  }

  Algorithm::
  Algorithm (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    algorithm_name_ (f, this),
    initialisation_vector_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Algorithm::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "algorithm-name" && n.namespace_ () == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")
      {
        ::std::auto_ptr< Algorithm_nameType > r (
          Algorithm_nameTraits::create (i, f, this));

        this->algorithm_name_.set (r);
        continue;
      }

      if (n.name () == "initialisation-vector" && n.namespace_ () == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")
      {
        ::std::auto_ptr< Initialisation_vectorType > r (
          Initialisation_vectorTraits::create (i, f, this));

        this->initialisation_vector_.set (r);
        continue;
      }
    }

    if (!algorithm_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "algorithm-name",
        "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0");
    }

    if (!initialisation_vector_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "initialisation-vector",
        "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0");
    }
  }

  Algorithm* Algorithm::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Algorithm (*this, f, c);
  }

  Algorithm::
  ~Algorithm ()
  {
  }

  // Key_derivation
  //

  Key_derivation::
  Key_derivation (const Key_derivation_nameType& key_derivation_name,
                  const SaltType& salt,
                  const Iteration_countType& iteration_count)
  : ::xml_schema::Type (),
    key_derivation_name_ (key_derivation_name, ::xml_schema::Flags (), this),
    salt_ (salt, ::xml_schema::Flags (), this),
    iteration_count_ (iteration_count, ::xml_schema::Flags (), this)
  {
  }

  Key_derivation::
  Key_derivation (const Key_derivation& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    key_derivation_name_ (x.key_derivation_name_, f, this),
    salt_ (x.salt_, f, this),
    iteration_count_ (x.iteration_count_, f, this)
  {
  }

  Key_derivation::
  Key_derivation (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    key_derivation_name_ (f, this),
    salt_ (f, this),
    iteration_count_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Key_derivation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "key-derivation-name" && n.namespace_ () == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")
      {
        ::std::auto_ptr< Key_derivation_nameType > r (
          Key_derivation_nameTraits::create (i, f, this));

        this->key_derivation_name_.set (r);
        continue;
      }

      if (n.name () == "salt" && n.namespace_ () == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")
      {
        ::std::auto_ptr< SaltType > r (
          SaltTraits::create (i, f, this));

        this->salt_.set (r);
        continue;
      }

      if (n.name () == "iteration-count" && n.namespace_ () == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")
      {
        this->iteration_count_.set (Iteration_countTraits::create (i, f, this));
        continue;
      }
    }

    if (!key_derivation_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "key-derivation-name",
        "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0");
    }

    if (!salt_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "salt",
        "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0");
    }

    if (!iteration_count_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "iteration-count",
        "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0");
    }
  }

  Key_derivation* Key_derivation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Key_derivation (*this, f, c);
  }

  Key_derivation::
  ~Key_derivation ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace manifest
{
  ::std::auto_ptr< ::manifest::Manifest >
  manifest (const ::std::string& u,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::manifest::Manifest > r (
      ::manifest::manifest (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::manifest::Manifest >
  manifest (const ::std::string& u,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::manifest::Manifest > r (
      ::manifest::manifest (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::manifest::Manifest >
  manifest (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::manifest::Manifest > r (
      ::manifest::manifest (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::manifest::Manifest >
  manifest (::std::istream& is,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::manifest::manifest (isrc, f, p);
  }

  ::std::auto_ptr< ::manifest::Manifest >
  manifest (::std::istream& is,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::manifest::manifest (isrc, h, f, p);
  }

  ::std::auto_ptr< ::manifest::Manifest >
  manifest (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::manifest::manifest (isrc, h, f, p);
  }

  ::std::auto_ptr< ::manifest::Manifest >
  manifest (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::manifest::manifest (isrc, f, p);
  }

  ::std::auto_ptr< ::manifest::Manifest >
  manifest (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::manifest::manifest (isrc, h, f, p);
  }

  ::std::auto_ptr< ::manifest::Manifest >
  manifest (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::manifest::manifest (isrc, h, f, p);
  }

  ::std::auto_ptr< ::manifest::Manifest >
  manifest (::xercesc::InputSource& i,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::manifest::Manifest > r (
      ::manifest::manifest (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::manifest::Manifest >
  manifest (::xercesc::InputSource& i,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::manifest::Manifest > r (
      ::manifest::manifest (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::manifest::Manifest >
  manifest (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::manifest::Manifest > r (
      ::manifest::manifest (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::manifest::Manifest >
  manifest (const ::xercesc::DOMDocument& d,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::manifest::Manifest > r (
        ::manifest::manifest (
          c, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "manifest" &&
        n.namespace_ () == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")
    {
      ::std::auto_ptr< ::manifest::Manifest > r (
        ::xsd::cxx::tree::traits< ::manifest::Manifest, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "manifest",
      "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0");
  }

  ::std::auto_ptr< ::manifest::Manifest >
  manifest (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "manifest" &&
        n.namespace_ () == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")
    {
      ::std::auto_ptr< ::manifest::Manifest > r (
        ::xsd::cxx::tree::traits< ::manifest::Manifest, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "manifest",
      "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0");
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace manifest
{
  void
  manifest (::std::ostream& o,
            const ::manifest::Manifest& s,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::manifest::manifest (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  manifest (::std::ostream& o,
            const ::manifest::Manifest& s,
            ::xml_schema::ErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::manifest::manifest (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  manifest (::std::ostream& o,
            const ::manifest::Manifest& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::manifest::manifest (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  manifest (::xercesc::XMLFormatTarget& t,
            const ::manifest::Manifest& s,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::manifest::manifest (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  manifest (::xercesc::XMLFormatTarget& t,
            const ::manifest::Manifest& s,
            ::xml_schema::ErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::manifest::manifest (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  manifest (::xercesc::XMLFormatTarget& t,
            const ::manifest::Manifest& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::manifest::manifest (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  manifest (::xercesc::DOMDocument& d,
            const ::manifest::Manifest& s,
            ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "manifest" &&
        n.namespace_ () == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "manifest",
        "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  manifest (const ::manifest::Manifest& s,
            const ::xml_schema::NamespaceInfomap& m,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "manifest",
        "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0",
        m, f));

    ::manifest::manifest (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const Manifest& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // file-entry
    //
    for (Manifest::File_entryConstIterator
         b (i.file_entry ().begin ()), n (i.file_entry ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "file-entry",
          "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const File_entry& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // encryption-data
    //
    if (i.encryption_data ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "encryption-data",
          "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0",
          e));

      s << *i.encryption_data ();
    }

    // full-path
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "full-path",
          "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0",
          e));

      a << i.full_path ();
    }

    // size
    //
    if (i.size ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "size",
          "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0",
          e));

      a << *i.size ();
    }

    // media-type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "media-type",
          "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0",
          e));

      a << i.media_type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Encryption_data& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // algorithm
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "algorithm",
          "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0",
          e));

      s << i.algorithm ();
    }

    // key-derivation
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "key-derivation",
          "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0",
          e));

      s << i.key_derivation ();
    }

    // checksum-type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "checksum-type",
          "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0",
          e));

      a << i.checksum_type ();
    }

    // checksum
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "checksum",
          "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0",
          e));

      a << i.checksum ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Algorithm& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // algorithm-name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "algorithm-name",
          "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0",
          e));

      a << i.algorithm_name ();
    }

    // initialisation-vector
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "initialisation-vector",
          "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0",
          e));

      a << i.initialisation_vector ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Key_derivation& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // key-derivation-name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "key-derivation-name",
          "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0",
          e));

      a << i.key_derivation_name ();
    }

    // salt
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "salt",
          "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0",
          e));

      a << i.salt ();
    }

    // iteration-count
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "iteration-count",
          "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0",
          e));

      a << i.iteration_count ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

