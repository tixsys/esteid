// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "xmldsig-core-schema.h"

namespace ds
{
char const* XMLNS = "http://www.w3.org/2000/09/xmldsig#";

	
// CryptoBinary
//


// Signature
//

const Signature::SignedInfoType& Signature::signedInfo() const
{
	return this->SignedInfo_.get();
}

Signature::SignedInfoType& Signature::signedInfo()
{
	return this->SignedInfo_.get();
}

void Signature::signedInfo( const SignedInfoType& x )
{
	this->SignedInfo_.set( x );
}

void Signature::signedInfo( ::std::auto_ptr< SignedInfoType > x )
{
	this->SignedInfo_.set( x );
}

const Signature::SignatureValueType& Signature::signatureValue() const
{
	return this->SignatureValue_.get();
}

Signature::SignatureValueType& Signature::signatureValue()
{
	return this->SignatureValue_.get();
}

void Signature::signatureValue( const SignatureValueType& x )
{
	this->SignatureValue_.set( x );
}

void Signature::signatureValue( ::std::auto_ptr< SignatureValueType > x )
{
	this->SignatureValue_.set( x );
}

const Signature::KeyInfoOptional& Signature::keyInfo() const
{
	return this->KeyInfo_;
}

Signature::KeyInfoOptional& Signature::keyInfo()
{
	return this->KeyInfo_;
}

void Signature::keyInfo( const KeyInfoType& x )
{
	this->KeyInfo_.set( x );
}

void Signature::keyInfo( const KeyInfoOptional& x )
{
	this->KeyInfo_ = x;
}

void Signature::keyInfo( ::std::auto_ptr< KeyInfoType > x )
{
	this->KeyInfo_.set( x );
}

const Signature::ObjectSequence& Signature::object() const
{
	return this->Object_;
}

Signature::ObjectSequence& Signature::object()
{
	return this->Object_;
}

void Signature::object( const ObjectSequence& s )
{
	this->Object_ = s;
}

const Signature::IdOptional& Signature::id() const
{
	return this->Id_;
}

Signature::IdOptional& Signature::id()
{
	return this->Id_;
}

void Signature::id( const IdType& x )
{
	this->Id_.set( x );
}

void Signature::id( const IdOptional& x )
{
	this->Id_ = x;
}

void Signature::id( ::std::auto_ptr< IdType > x )
{
	this->Id_.set( x );
}


// SignatureValue
//

const SignatureValue::IdOptional& SignatureValue::id() const
{
	return this->Id_;
}

SignatureValue::IdOptional& SignatureValue::id()
{
	return this->Id_;
}

void SignatureValue::id( const IdType& x )
{
	this->Id_.set( x );
}

void SignatureValue::id( const IdOptional& x )
{
	this->Id_ = x;
}

void SignatureValue::id( ::std::auto_ptr< IdType > x )
{
	this->Id_.set( x );
}


// SignedInfo
//

const SignedInfo::CanonicalizationMethodType& SignedInfo::canonicalizationMethod() const
{
	return this->CanonicalizationMethod_.get();
}

SignedInfo::CanonicalizationMethodType& SignedInfo::canonicalizationMethod()
{
	return this->CanonicalizationMethod_.get();
}

void SignedInfo::canonicalizationMethod( const CanonicalizationMethodType& x )
{
	this->CanonicalizationMethod_.set( x );
}

void SignedInfo::canonicalizationMethod( ::std::auto_ptr< CanonicalizationMethodType > x )
{
	this->CanonicalizationMethod_.set( x );
}

const SignedInfo::SignatureMethodType& SignedInfo::signatureMethod() const
{
	return this->SignatureMethod_.get();
}

SignedInfo::SignatureMethodType& SignedInfo::signatureMethod()
{
	return this->SignatureMethod_.get();
}

void SignedInfo::signatureMethod( const SignatureMethodType& x )
{
	this->SignatureMethod_.set( x );
}

void SignedInfo::signatureMethod( ::std::auto_ptr< SignatureMethodType > x )
{
	this->SignatureMethod_.set( x );
}

const SignedInfo::ReferenceSequence& SignedInfo::reference() const
{
	return this->Reference_;
}

SignedInfo::ReferenceSequence& SignedInfo::reference()
{
	return this->Reference_;
}

void SignedInfo::reference( const ReferenceSequence& s )
{
	this->Reference_ = s;
}

const SignedInfo::IdOptional& SignedInfo::id() const
{
	return this->Id_;
}

SignedInfo::IdOptional& SignedInfo::id()
{
	return this->Id_;
}

void SignedInfo::id( const IdType& x )
{
	this->Id_.set( x );
}

void SignedInfo::id( const IdOptional& x )
{
	this->Id_ = x;
}

void SignedInfo::id( ::std::auto_ptr< IdType > x )
{
	this->Id_.set( x );
}


// CanonicalizationMethod
//

const CanonicalizationMethod::AlgorithmType& CanonicalizationMethod::algorithm() const
{
	return this->Algorithm_.get();
}

CanonicalizationMethod::AlgorithmType& CanonicalizationMethod::algorithm()
{
	return this->Algorithm_.get();
}

void CanonicalizationMethod::algorithm( const AlgorithmType& x )
{
	this->Algorithm_.set( x );
}

void CanonicalizationMethod::algorithm( ::std::auto_ptr< AlgorithmType > x )
{
	this->Algorithm_.set( x );
}


// SignatureMethod
//

const SignatureMethod::HMACOutputLengthOptional& SignatureMethod::hMACOutputLength() const
{
	return this->HMACOutputLength_;
}

SignatureMethod::HMACOutputLengthOptional& SignatureMethod::hMACOutputLength()
{
	return this->HMACOutputLength_;
}

void SignatureMethod::hMACOutputLength( const HMACOutputLengthType& x )
{
	this->HMACOutputLength_.set( x );
}

void SignatureMethod::hMACOutputLength( const HMACOutputLengthOptional& x )
{
	this->HMACOutputLength_ = x;
}

void SignatureMethod::hMACOutputLength( ::std::auto_ptr< HMACOutputLengthType > x )
{
	this->HMACOutputLength_.set( x );
}

const SignatureMethod::AlgorithmType& SignatureMethod::algorithm() const
{
	return this->Algorithm_.get();
}

SignatureMethod::AlgorithmType& SignatureMethod::algorithm()
{
	return this->Algorithm_.get();
}

void SignatureMethod::algorithm( const AlgorithmType& x )
{
	this->Algorithm_.set( x );
}

void SignatureMethod::algorithm( ::std::auto_ptr< AlgorithmType > x )
{
	this->Algorithm_.set( x );
}


// Reference
//

const Reference::TransformsOptional& Reference::transforms() const
{
	return this->Transforms_;
}

Reference::TransformsOptional& Reference::transforms()
{
	return this->Transforms_;
}

void Reference::transforms( const TransformsType& x )
{
	this->Transforms_.set( x );
}

void Reference::transforms( const TransformsOptional& x )
{
	this->Transforms_ = x;
}

void Reference::transforms( ::std::auto_ptr< TransformsType > x )
{
	this->Transforms_.set( x );
}

const Reference::DigestMethodType& Reference::digestMethod() const
{
	return this->DigestMethod_.get();
}

Reference::DigestMethodType& Reference::digestMethod()
{
	return this->DigestMethod_.get();
}

void Reference::digestMethod( const DigestMethodType& x )
{
	this->DigestMethod_.set( x );
}

void Reference::digestMethod( ::std::auto_ptr< DigestMethodType > x )
{
	this->DigestMethod_.set( x );
}

const Reference::DigestValueType& Reference::digestValue() const
{
	return this->DigestValue_.get();
}

Reference::DigestValueType& Reference::digestValue()
{
	return this->DigestValue_.get();
}

void Reference::digestValue( const DigestValueType& x )
{
	this->DigestValue_.set( x );
}

void Reference::digestValue( ::std::auto_ptr< DigestValueType > x )
{
	this->DigestValue_.set( x );
}

const Reference::IdOptional& Reference::id() const
{
	return this->Id_;
}

Reference::IdOptional& Reference::id()
{
	return this->Id_;
}

void Reference::id( const IdType& x )
{
	this->Id_.set( x );
}

void Reference::id( const IdOptional& x )
{
	this->Id_ = x;
}

void Reference::id( ::std::auto_ptr< IdType > x )
{
	this->Id_.set( x );
}

const Reference::URIOptional& Reference::uRI() const
{
	return this->URI_;
}

Reference::URIOptional& Reference::uRI()
{
	return this->URI_;
}

void Reference::uRI( const URIType& x )
{
	this->URI_.set( x );
}

void Reference::uRI( const URIOptional& x )
{
	this->URI_ = x;
}

void Reference::uRI( ::std::auto_ptr< URIType > x )
{
	this->URI_.set( x );
}

const Reference::TypeOptional& Reference::type() const
{
	return this->Type_;
}

Reference::TypeOptional& Reference::type()
{
	return this->Type_;
}

void Reference::type( const TypeType& x )
{
	this->Type_.set( x );
}

void Reference::type( const TypeOptional& x )
{
	this->Type_ = x;
}

void Reference::type( ::std::auto_ptr< TypeType > x )
{
	this->Type_.set( x );
}


// Transforms
//

const Transforms::TransformSequence& Transforms::transform() const
{
	return this->Transform_;
}

Transforms::TransformSequence& Transforms::transform()
{
	return this->Transform_;
}

void Transforms::transform( const TransformSequence& s )
{
	this->Transform_ = s;
}


// Transform
//

const Transform::XPathSequence& Transform::xPath() const
{
	return this->XPath_;
}

Transform::XPathSequence& Transform::xPath()
{
	return this->XPath_;
}

void Transform::xPath( const XPathSequence& s )
{
	this->XPath_ = s;
}

const Transform::AlgorithmType& Transform::algorithm() const
{
	return this->Algorithm_.get();
}

Transform::AlgorithmType& Transform::algorithm()
{
	return this->Algorithm_.get();
}

void Transform::algorithm( const AlgorithmType& x )
{
	this->Algorithm_.set( x );
}

void Transform::algorithm( ::std::auto_ptr< AlgorithmType > x )
{
	this->Algorithm_.set( x );
}


// DigestMethod
//

const DigestMethod::AlgorithmType& DigestMethod::algorithm() const
{
	return this->Algorithm_.get();
}

DigestMethod::AlgorithmType& DigestMethod::algorithm()
{
	return this->Algorithm_.get();
}

void DigestMethod::algorithm( const AlgorithmType& x )
{
	this->Algorithm_.set( x );
}

void DigestMethod::algorithm( ::std::auto_ptr< AlgorithmType > x )
{
	this->Algorithm_.set( x );
}


// DigestValue
//


// KeyInfo
//

const KeyInfo::KeyNameSequence& KeyInfo::keyName() const
{
	return this->KeyName_;
}

KeyInfo::KeyNameSequence& KeyInfo::keyName()
{
	return this->KeyName_;
}

void KeyInfo::keyName( const KeyNameSequence& s )
{
	this->KeyName_ = s;
}

const KeyInfo::KeyValueSequence& KeyInfo::keyValue() const
{
	return this->KeyValue_;
}

KeyInfo::KeyValueSequence& KeyInfo::keyValue()
{
	return this->KeyValue_;
}

void KeyInfo::keyValue( const KeyValueSequence& s )
{
	this->KeyValue_ = s;
}

const KeyInfo::RetrievalMethodSequence& KeyInfo::retrievalMethod() const
{
	return this->RetrievalMethod_;
}

KeyInfo::RetrievalMethodSequence& KeyInfo::retrievalMethod()
{
	return this->RetrievalMethod_;
}

void KeyInfo::retrievalMethod( const RetrievalMethodSequence& s )
{
	this->RetrievalMethod_ = s;
}

const KeyInfo::X509DataSequence& KeyInfo::x509Data() const
{
	return this->X509Data_;
}

KeyInfo::X509DataSequence& KeyInfo::x509Data()
{
	return this->X509Data_;
}

void KeyInfo::x509Data( const X509DataSequence& s )
{
	this->X509Data_ = s;
}

const KeyInfo::PGPDataSequence& KeyInfo::pGPData() const
{
	return this->PGPData_;
}

KeyInfo::PGPDataSequence& KeyInfo::pGPData()
{
	return this->PGPData_;
}

void KeyInfo::pGPData( const PGPDataSequence& s )
{
	this->PGPData_ = s;
}

const KeyInfo::SPKIDataSequence& KeyInfo::sPKIData() const
{
	return this->SPKIData_;
}

KeyInfo::SPKIDataSequence& KeyInfo::sPKIData()
{
	return this->SPKIData_;
}

void KeyInfo::sPKIData( const SPKIDataSequence& s )
{
	this->SPKIData_ = s;
}

const KeyInfo::MgmtDataSequence& KeyInfo::mgmtData() const
{
	return this->MgmtData_;
}

KeyInfo::MgmtDataSequence& KeyInfo::mgmtData()
{
	return this->MgmtData_;
}

void KeyInfo::mgmtData( const MgmtDataSequence& s )
{
	this->MgmtData_ = s;
}

const KeyInfo::IdOptional& KeyInfo::id() const
{
	return this->Id_;
}

KeyInfo::IdOptional& KeyInfo::id()
{
	return this->Id_;
}

void KeyInfo::id( const IdType& x )
{
	this->Id_.set( x );
}

void KeyInfo::id( const IdOptional& x )
{
	this->Id_ = x;
}

void KeyInfo::id( ::std::auto_ptr< IdType > x )
{
	this->Id_.set( x );
}


// KeyValue
//

const KeyValue::DSAKeyValueOptional& KeyValue::dSAKeyValue() const
{
	return this->DSAKeyValue_;
}

KeyValue::DSAKeyValueOptional& KeyValue::dSAKeyValue()
{
	return this->DSAKeyValue_;
}

void KeyValue::dSAKeyValue( const DSAKeyValueType& x )
{
	this->DSAKeyValue_.set( x );
}

void KeyValue::dSAKeyValue( const DSAKeyValueOptional& x )
{
	this->DSAKeyValue_ = x;
}

void KeyValue::dSAKeyValue( ::std::auto_ptr< DSAKeyValueType > x )
{
	this->DSAKeyValue_.set( x );
}

const KeyValue::RSAKeyValueOptional& KeyValue::rSAKeyValue() const
{
	return this->RSAKeyValue_;
}

KeyValue::RSAKeyValueOptional& KeyValue::rSAKeyValue()
{
	return this->RSAKeyValue_;
}

void KeyValue::rSAKeyValue( const RSAKeyValueType& x )
{
	this->RSAKeyValue_.set( x );
}

void KeyValue::rSAKeyValue( const RSAKeyValueOptional& x )
{
	this->RSAKeyValue_ = x;
}

void KeyValue::rSAKeyValue( ::std::auto_ptr< RSAKeyValueType > x )
{
	this->RSAKeyValue_.set( x );
}


// RetrievalMethod
//

const RetrievalMethod::TransformsOptional& RetrievalMethod::transforms() const
{
	return this->Transforms_;
}

RetrievalMethod::TransformsOptional& RetrievalMethod::transforms()
{
	return this->Transforms_;
}

void RetrievalMethod::transforms( const TransformsType& x )
{
	this->Transforms_.set( x );
}

void RetrievalMethod::transforms( const TransformsOptional& x )
{
	this->Transforms_ = x;
}

void RetrievalMethod::transforms( ::std::auto_ptr< TransformsType > x )
{
	this->Transforms_.set( x );
}

const RetrievalMethod::URIOptional& RetrievalMethod::uRI() const
{
	return this->URI_;
}

RetrievalMethod::URIOptional& RetrievalMethod::uRI()
{
	return this->URI_;
}

void RetrievalMethod::uRI( const URIType& x )
{
	this->URI_.set( x );
}

void RetrievalMethod::uRI( const URIOptional& x )
{
	this->URI_ = x;
}

void RetrievalMethod::uRI( ::std::auto_ptr< URIType > x )
{
	this->URI_.set( x );
}

const RetrievalMethod::TypeOptional& RetrievalMethod::type() const
{
	return this->Type_;
}

RetrievalMethod::TypeOptional& RetrievalMethod::type()
{
	return this->Type_;
}

void RetrievalMethod::type( const TypeType& x )
{
	this->Type_.set( x );
}

void RetrievalMethod::type( const TypeOptional& x )
{
	this->Type_ = x;
}

void RetrievalMethod::type( ::std::auto_ptr< TypeType > x )
{
	this->Type_.set( x );
}


// X509Data
//

const X509Data::X509IssuerSerialSequence& X509Data::x509IssuerSerial() const
{
	return this->X509IssuerSerial_;
}

X509Data::X509IssuerSerialSequence& X509Data::x509IssuerSerial()
{
	return this->X509IssuerSerial_;
}

void X509Data::x509IssuerSerial( const X509IssuerSerialSequence& s )
{
	this->X509IssuerSerial_ = s;
}

const X509Data::X509SKISequence& X509Data::x509SKI() const
{
	return this->X509SKI_;
}

X509Data::X509SKISequence& X509Data::x509SKI()
{
	return this->X509SKI_;
}

void X509Data::x509SKI( const X509SKISequence& s )
{
	this->X509SKI_ = s;
}

const X509Data::X509SubjectNameSequence& X509Data::x509SubjectName() const
{
	return this->X509SubjectName_;
}

X509Data::X509SubjectNameSequence& X509Data::x509SubjectName()
{
	return this->X509SubjectName_;
}

void X509Data::x509SubjectName( const X509SubjectNameSequence& s )
{
	this->X509SubjectName_ = s;
}

const X509Data::X509CertificateSequence& X509Data::x509Certificate() const
{
	return this->X509Certificate_;
}

X509Data::X509CertificateSequence& X509Data::x509Certificate()
{
	return this->X509Certificate_;
}

void X509Data::x509Certificate( const X509CertificateSequence& s )
{
	this->X509Certificate_ = s;
}

const X509Data::X509CRLSequence& X509Data::x509CRL() const
{
	return this->X509CRL_;
}

X509Data::X509CRLSequence& X509Data::x509CRL()
{
	return this->X509CRL_;
}

void X509Data::x509CRL( const X509CRLSequence& s )
{
	this->X509CRL_ = s;
}


// X509IssuerSerial
//

const X509IssuerSerial::X509IssuerNameType& X509IssuerSerial::x509IssuerName() const
{
	return this->X509IssuerName_.get();
}

X509IssuerSerial::X509IssuerNameType& X509IssuerSerial::x509IssuerName()
{
	return this->X509IssuerName_.get();
}

void X509IssuerSerial::x509IssuerName( const X509IssuerNameType& x )
{
	this->X509IssuerName_.set( x );
}

void X509IssuerSerial::x509IssuerName( ::std::auto_ptr< X509IssuerNameType > x )
{
	this->X509IssuerName_.set( x );
}

const X509IssuerSerial::X509SerialNumberType& X509IssuerSerial::x509SerialNumber() const
{
	return this->X509SerialNumber_.get();
}

X509IssuerSerial::X509SerialNumberType& X509IssuerSerial::x509SerialNumber()
{
	return this->X509SerialNumber_.get();
}

void X509IssuerSerial::x509SerialNumber( const X509SerialNumberType& x )
{
	this->X509SerialNumber_.set( x );
}


// PGPData
//

const PGPData::PGPKeyIDOptional& PGPData::pGPKeyID() const
{
	return this->PGPKeyID_;
}

PGPData::PGPKeyIDOptional& PGPData::pGPKeyID()
{
	return this->PGPKeyID_;
}

void PGPData::pGPKeyID( const PGPKeyIDType& x )
{
	this->PGPKeyID_.set( x );
}

void PGPData::pGPKeyID( const PGPKeyIDOptional& x )
{
	this->PGPKeyID_ = x;
}

void PGPData::pGPKeyID( ::std::auto_ptr< PGPKeyIDType > x )
{
	this->PGPKeyID_.set( x );
}

const PGPData::PGPKeyPacketOptional& PGPData::pGPKeyPacket() const
{
	return this->PGPKeyPacket_;
}

PGPData::PGPKeyPacketOptional& PGPData::pGPKeyPacket()
{
	return this->PGPKeyPacket_;
}

void PGPData::pGPKeyPacket( const PGPKeyPacketType& x )
{
	this->PGPKeyPacket_.set( x );
}

void PGPData::pGPKeyPacket( const PGPKeyPacketOptional& x )
{
	this->PGPKeyPacket_ = x;
}

void PGPData::pGPKeyPacket( ::std::auto_ptr< PGPKeyPacketType > x )
{
	this->PGPKeyPacket_.set( x );
}


// SPKIData
//

const SPKIData::SPKISexpSequence& SPKIData::sPKISexp() const
{
	return this->SPKISexp_;
}

SPKIData::SPKISexpSequence& SPKIData::sPKISexp()
{
	return this->SPKISexp_;
}

void SPKIData::sPKISexp( const SPKISexpSequence& s )
{
	this->SPKISexp_ = s;
}


// Object
//

const Object::IdOptional& Object::id() const
{
	return this->Id_;
}

Object::IdOptional& Object::id()
{
	return this->Id_;
}

void Object::id( const IdType& x )
{
	this->Id_.set( x );
}

void Object::id( const IdOptional& x )
{
	this->Id_ = x;
}

void Object::id( ::std::auto_ptr< IdType > x )
{
	this->Id_.set( x );
}

const Object::MimeTypeOptional& Object::mimeType() const
{
	return this->MimeType_;
}

Object::MimeTypeOptional& Object::mimeType()
{
	return this->MimeType_;
}

void Object::mimeType( const MimeTypeType& x )
{
	this->MimeType_.set( x );
}

void Object::mimeType( const MimeTypeOptional& x )
{
	this->MimeType_ = x;
}

void Object::mimeType( ::std::auto_ptr< MimeTypeType > x )
{
	this->MimeType_.set( x );
}

const Object::EncodingOptional& Object::encoding() const
{
	return this->Encoding_;
}

Object::EncodingOptional& Object::encoding()
{
	return this->Encoding_;
}

void Object::encoding( const EncodingType& x )
{
	this->Encoding_.set( x );
}

void Object::encoding( const EncodingOptional& x )
{
	this->Encoding_ = x;
}

void Object::encoding( ::std::auto_ptr< EncodingType > x )
{
	this->Encoding_.set( x );
}


// Manifest
//

const Manifest::ReferenceSequence& Manifest::reference() const
{
	return this->Reference_;
}

Manifest::ReferenceSequence& Manifest::reference()
{
	return this->Reference_;
}

void Manifest::reference( const ReferenceSequence& s )
{
	this->Reference_ = s;
}

const Manifest::IdOptional& Manifest::id() const
{
	return this->Id_;
}

Manifest::IdOptional& Manifest::id()
{
	return this->Id_;
}

void Manifest::id( const IdType& x )
{
	this->Id_.set( x );
}

void Manifest::id( const IdOptional& x )
{
	this->Id_ = x;
}

void Manifest::id( ::std::auto_ptr< IdType > x )
{
	this->Id_.set( x );
}


// SignatureProperties
//

const SignatureProperties::SignaturePropertySequence& SignatureProperties::signatureProperty() const
{
	return this->SignatureProperty_;
}

SignatureProperties::SignaturePropertySequence& SignatureProperties::signatureProperty()
{
	return this->SignatureProperty_;
}

void SignatureProperties::signatureProperty( const SignaturePropertySequence& s )
{
	this->SignatureProperty_ = s;
}

const SignatureProperties::IdOptional& SignatureProperties::id() const
{
	return this->Id_;
}

SignatureProperties::IdOptional& SignatureProperties::id()
{
	return this->Id_;
}

void SignatureProperties::id( const IdType& x )
{
	this->Id_.set( x );
}

void SignatureProperties::id( const IdOptional& x )
{
	this->Id_ = x;
}

void SignatureProperties::id( ::std::auto_ptr< IdType > x )
{
	this->Id_.set( x );
}


// SignatureProperty
//

const SignatureProperty::TargetType& SignatureProperty::target() const
{
	return this->Target_.get();
}

SignatureProperty::TargetType& SignatureProperty::target()
{
	return this->Target_.get();
}

void SignatureProperty::target( const TargetType& x )
{
	this->Target_.set( x );
}

void SignatureProperty::target( ::std::auto_ptr< TargetType > x )
{
	this->Target_.set( x );
}

const SignatureProperty::IdOptional& SignatureProperty::id() const
{
	return this->Id_;
}

SignatureProperty::IdOptional& SignatureProperty::id()
{
	return this->Id_;
}

void SignatureProperty::id( const IdType& x )
{
	this->Id_.set( x );
}

void SignatureProperty::id( const IdOptional& x )
{
	this->Id_ = x;
}

void SignatureProperty::id( ::std::auto_ptr< IdType > x )
{
	this->Id_.set( x );
}


// HMACOutputLength
//


// DSAKeyValue
//

const DSAKeyValue::POptional& DSAKeyValue::p() const
{
	return this->P_;
}

DSAKeyValue::POptional& DSAKeyValue::p()
{
	return this->P_;
}

void DSAKeyValue::p( const PType& x )
{
	this->P_.set( x );
}

void DSAKeyValue::p( const POptional& x )
{
	this->P_ = x;
}

void DSAKeyValue::p( ::std::auto_ptr< PType > x )
{
	this->P_.set( x );
}

const DSAKeyValue::QOptional& DSAKeyValue::q() const
{
	return this->Q_;
}

DSAKeyValue::QOptional& DSAKeyValue::q()
{
	return this->Q_;
}

void DSAKeyValue::q( const QType& x )
{
	this->Q_.set( x );
}

void DSAKeyValue::q( const QOptional& x )
{
	this->Q_ = x;
}

void DSAKeyValue::q( ::std::auto_ptr< QType > x )
{
	this->Q_.set( x );
}

const DSAKeyValue::GOptional& DSAKeyValue::g() const
{
	return this->G_;
}

DSAKeyValue::GOptional& DSAKeyValue::g()
{
	return this->G_;
}

void DSAKeyValue::g( const GType& x )
{
	this->G_.set( x );
}

void DSAKeyValue::g( const GOptional& x )
{
	this->G_ = x;
}

void DSAKeyValue::g( ::std::auto_ptr< GType > x )
{
	this->G_.set( x );
}

const DSAKeyValue::YType& DSAKeyValue::y() const
{
	return this->Y_.get();
}

DSAKeyValue::YType& DSAKeyValue::y()
{
	return this->Y_.get();
}

void DSAKeyValue::y( const YType& x )
{
	this->Y_.set( x );
}

void DSAKeyValue::y( ::std::auto_ptr< YType > x )
{
	this->Y_.set( x );
}

const DSAKeyValue::JOptional& DSAKeyValue::j() const
{
	return this->J_;
}

DSAKeyValue::JOptional& DSAKeyValue::j()
{
	return this->J_;
}

void DSAKeyValue::j( const JType& x )
{
	this->J_.set( x );
}

void DSAKeyValue::j( const JOptional& x )
{
	this->J_ = x;
}

void DSAKeyValue::j( ::std::auto_ptr< JType > x )
{
	this->J_.set( x );
}

const DSAKeyValue::SeedOptional& DSAKeyValue::seed() const
{
	return this->Seed_;
}

DSAKeyValue::SeedOptional& DSAKeyValue::seed()
{
	return this->Seed_;
}

void DSAKeyValue::seed( const SeedType& x )
{
	this->Seed_.set( x );
}

void DSAKeyValue::seed( const SeedOptional& x )
{
	this->Seed_ = x;
}

void DSAKeyValue::seed( ::std::auto_ptr< SeedType > x )
{
	this->Seed_.set( x );
}

const DSAKeyValue::PgenCounterOptional& DSAKeyValue::pgenCounter() const
{
	return this->PgenCounter_;
}

DSAKeyValue::PgenCounterOptional& DSAKeyValue::pgenCounter()
{
	return this->PgenCounter_;
}

void DSAKeyValue::pgenCounter( const PgenCounterType& x )
{
	this->PgenCounter_.set( x );
}

void DSAKeyValue::pgenCounter( const PgenCounterOptional& x )
{
	this->PgenCounter_ = x;
}

void DSAKeyValue::pgenCounter( ::std::auto_ptr< PgenCounterType > x )
{
	this->PgenCounter_.set( x );
}


// RSAKeyValue
//

const RSAKeyValue::ModulusType& RSAKeyValue::modulus() const
{
	return this->Modulus_.get();
}

RSAKeyValue::ModulusType& RSAKeyValue::modulus()
{
	return this->Modulus_.get();
}

void RSAKeyValue::modulus( const ModulusType& x )
{
	this->Modulus_.set( x );
}

void RSAKeyValue::modulus( ::std::auto_ptr< ModulusType > x )
{
	this->Modulus_.set( x );
}

const RSAKeyValue::ExponentType& RSAKeyValue::exponent() const
{
	return this->Exponent_.get();
}

RSAKeyValue::ExponentType& RSAKeyValue::exponent()
{
	return this->Exponent_.get();
}

void RSAKeyValue::exponent( const ExponentType& x )
{
	this->Exponent_.set( x );
}

void RSAKeyValue::exponent( ::std::auto_ptr< ExponentType > x )
{
	this->Exponent_.set( x );
}
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace ds
{
// CryptoBinary
//

CryptoBinary::CryptoBinary()
		: ::xml_schema::Base64Binary()
{
}

CryptoBinary::CryptoBinary( const ::xml_schema::Base64Binary& _xsd_Base64Binary_base )
		: ::xml_schema::Base64Binary( _xsd_Base64Binary_base )
{
}

CryptoBinary::CryptoBinary( const CryptoBinary& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Base64Binary( x, f, c )
{
}

CryptoBinary::CryptoBinary( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Base64Binary( e, f, c )
{
}

CryptoBinary::CryptoBinary( const ::xercesc::DOMAttr& a, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Base64Binary( a, f, c )
{
}

CryptoBinary::CryptoBinary( const ::std::string& s, const ::xercesc::DOMElement* e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Base64Binary( s, e, f, c )
{
}

CryptoBinary* CryptoBinary::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class CryptoBinary( *this, f, c );
}

CryptoBinary::~CryptoBinary()
{
}

// Signature
//

Signature::Signature( const SignedInfoType& SignedInfo, const SignatureValueType& SignatureValue )
		: ::xml_schema::Type(), SignedInfo_( SignedInfo, ::xml_schema::Flags(), this )
		, SignatureValue_( SignatureValue, ::xml_schema::Flags(), this )
		, KeyInfo_( ::xml_schema::Flags(), this )
		, Object_( ::xml_schema::Flags(), this )
		, Id_( ::xml_schema::Flags(), this )
{
}

Signature::Signature( ::std::auto_ptr< SignedInfoType >& SignedInfo, ::std::auto_ptr< SignatureValueType >& SignatureValue )
		: ::xml_schema::Type(), SignedInfo_( SignedInfo, ::xml_schema::Flags(), this )
		, SignatureValue_( SignatureValue, ::xml_schema::Flags(), this )
		, KeyInfo_( ::xml_schema::Flags(), this )
		, Object_( ::xml_schema::Flags(), this )
		, Id_( ::xml_schema::Flags(), this )
{
}

Signature::Signature( const Signature& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), SignedInfo_( x.SignedInfo_, f, this )
		, SignatureValue_( x.SignatureValue_, f, this )
		, KeyInfo_( x.KeyInfo_, f, this )
		, Object_( x.Object_, f, this )
		, Id_( x.Id_, f, this )
{
}

Signature::Signature( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), SignedInfo_( f, this )
		, SignatureValue_( f, this )
		, KeyInfo_( f, this )
		, Object_( f, this )
		, Id_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, true );
		this->parse( p, f );
	}
}

void Signature::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// SignedInfo
		//
		if ( n.name() == "SignedInfo" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< SignedInfoType > r( SignedInfoTraits::create( i, f, this ) );

			if ( !SignedInfo_.present() )
			{
				this->SignedInfo_.set( r );
				continue;
			}
		}

		// SignatureValue
		//
		if ( n.name() == "SignatureValue" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< SignatureValueType > r( SignatureValueTraits::create( i, f, this ) );

			if ( !SignatureValue_.present() )
			{
				this->SignatureValue_.set( r );
				continue;
			}
		}

		// KeyInfo
		//
		if ( n.name() == "KeyInfo" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< KeyInfoType > r( KeyInfoTraits::create( i, f, this ) );

			if ( !this->KeyInfo_ )
			{
				this->KeyInfo_.set( r );
				continue;
			}
		}

		// Object
		//
		if ( n.name() == "Object" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< ObjectType > r( ObjectTraits::create( i, f, this ) );

			this->Object_.push_back( r );
			continue;
		}

		break;
	}

	if ( !SignedInfo_.present() )
	{
		throw ::xsd::cxx::tree::expected_element< char > ( "SignedInfo", XMLNS );
	}

	if ( !SignatureValue_.present() )
	{
		throw ::xsd::cxx::tree::expected_element< char > ( "SignatureValue", XMLNS );
	}

	while ( p.more_attributes() )
	{
		const ::xercesc::DOMAttr& i( p.next_attribute() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		if ( n.name() == "Id" && n.namespace_().empty() )
		{
			::std::auto_ptr< IdType > r( IdTraits::create( i, f, this ) );

			this->Id_.set( r );
			continue;
		}
	}
}

Signature* Signature::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class Signature( *this, f, c );
}

Signature::~Signature()
{
}

// SignatureValue
//

SignatureValue::SignatureValue()
		: ::xml_schema::Base64Binary(), Id_( ::xml_schema::Flags(), this )
{
}

SignatureValue::SignatureValue( const ::xml_schema::Base64Binary& _xsd_Base64Binary_base )
		: ::xml_schema::Base64Binary( _xsd_Base64Binary_base ), Id_( ::xml_schema::Flags(), this )
{
}

SignatureValue::SignatureValue( const SignatureValue& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Base64Binary( x, f, c ), Id_( x.Id_, f, this )
{
}

SignatureValue::SignatureValue( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Base64Binary( e, f | ::xml_schema::Flags::base, c ), Id_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, false, true );
		this->parse( p, f );
	}
}

void SignatureValue::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	while ( p.more_attributes() )
	{
		const ::xercesc::DOMAttr& i( p.next_attribute() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		if ( n.name() == "Id" && n.namespace_().empty() )
		{
			::std::auto_ptr< IdType > r( IdTraits::create( i, f, this ) );

			this->Id_.set( r );
			continue;
		}
	}
}

SignatureValue* SignatureValue::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class SignatureValue( *this, f, c );
}

SignatureValue::~SignatureValue()
{
}

// SignedInfo
//

SignedInfo::SignedInfo( const CanonicalizationMethodType& CanonicalizationMethod, const SignatureMethodType& SignatureMethod )
		: ::xml_schema::Type(), CanonicalizationMethod_( CanonicalizationMethod, ::xml_schema::Flags(), this )
		, SignatureMethod_( SignatureMethod, ::xml_schema::Flags(), this )
		, Reference_( ::xml_schema::Flags(), this )
		, Id_( ::xml_schema::Flags(), this )
{
}

SignedInfo::SignedInfo( ::std::auto_ptr< CanonicalizationMethodType >& CanonicalizationMethod, ::std::auto_ptr< SignatureMethodType >& SignatureMethod )
		: ::xml_schema::Type(), CanonicalizationMethod_( CanonicalizationMethod, ::xml_schema::Flags(), this )
		, SignatureMethod_( SignatureMethod, ::xml_schema::Flags(), this )
		, Reference_( ::xml_schema::Flags(), this )
		, Id_( ::xml_schema::Flags(), this )
{
}

SignedInfo::SignedInfo( const SignedInfo& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), CanonicalizationMethod_( x.CanonicalizationMethod_, f, this )
		, SignatureMethod_( x.SignatureMethod_, f, this )
		, Reference_( x.Reference_, f, this )
		, Id_( x.Id_, f, this )
{
}

SignedInfo::SignedInfo( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), CanonicalizationMethod_( f, this )
		, SignatureMethod_( f, this )
		, Reference_( f, this )
		, Id_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, true );
		this->parse( p, f );
	}
}

void SignedInfo::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// CanonicalizationMethod
		//
		if ( n.name() == "CanonicalizationMethod" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< CanonicalizationMethodType > r( CanonicalizationMethodTraits::create( i, f, this ) );

			if ( !CanonicalizationMethod_.present() )
			{
				this->CanonicalizationMethod_.set( r );
				continue;
			}
		}

		// SignatureMethod
		//
		if ( n.name() == "SignatureMethod" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< SignatureMethodType > r( SignatureMethodTraits::create( i, f, this ) );

			if ( !SignatureMethod_.present() )
			{
				this->SignatureMethod_.set( r );
				continue;
			}
		}

		// Reference
		//
		if ( n.name() == "Reference" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< ReferenceType > r( ReferenceTraits::create( i, f, this ) );

			this->Reference_.push_back( r );
			continue;
		}

		break;
	}

	if ( !CanonicalizationMethod_.present() )
	{
		throw ::xsd::cxx::tree::expected_element< char > ( "CanonicalizationMethod", XMLNS );
	}

	if ( !SignatureMethod_.present() )
	{
		throw ::xsd::cxx::tree::expected_element< char > ( "SignatureMethod", XMLNS );
	}

	while ( p.more_attributes() )
	{
		const ::xercesc::DOMAttr& i( p.next_attribute() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		if ( n.name() == "Id" && n.namespace_().empty() )
		{
			::std::auto_ptr< IdType > r( IdTraits::create( i, f, this ) );

			this->Id_.set( r );
			continue;
		}
	}
}

SignedInfo* SignedInfo::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class SignedInfo( *this, f, c );
}

SignedInfo::~SignedInfo()
{
}

// CanonicalizationMethod
//

CanonicalizationMethod::CanonicalizationMethod( const AlgorithmType& Algorithm )
		: ::xml_schema::Type(), Algorithm_( Algorithm, ::xml_schema::Flags(), this )
{
}

CanonicalizationMethod::CanonicalizationMethod( const CanonicalizationMethod& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), Algorithm_( x.Algorithm_, f, this )
{
}

CanonicalizationMethod::CanonicalizationMethod( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), Algorithm_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, true );
		this->parse( p, f );
	}
}

void CanonicalizationMethod::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		break;
	}

	while ( p.more_attributes() )
	{
		const ::xercesc::DOMAttr& i( p.next_attribute() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		if ( n.name() == "Algorithm" && n.namespace_().empty() )
		{
			::std::auto_ptr< AlgorithmType > r( AlgorithmTraits::create( i, f, this ) );

			this->Algorithm_.set( r );
			continue;
		}
	}

	if ( !Algorithm_.present() )
	{
		throw ::xsd::cxx::tree::expected_attribute< char > ( "Algorithm", "" );
	}
}

CanonicalizationMethod* CanonicalizationMethod::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class CanonicalizationMethod( *this, f, c );
}

CanonicalizationMethod::~CanonicalizationMethod()
{
}

// SignatureMethod
//

SignatureMethod::SignatureMethod( const AlgorithmType& Algorithm )
		: ::xml_schema::Type(), HMACOutputLength_( ::xml_schema::Flags(), this )
		, Algorithm_( Algorithm, ::xml_schema::Flags(), this )
{
}

SignatureMethod::SignatureMethod( const SignatureMethod& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), HMACOutputLength_( x.HMACOutputLength_, f, this )
		, Algorithm_( x.Algorithm_, f, this )
{
}

SignatureMethod::SignatureMethod( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), HMACOutputLength_( f, this )
		, Algorithm_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, true );
		this->parse( p, f );
	}
}

void SignatureMethod::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// HMACOutputLength
		//
		if ( n.name() == "HMACOutputLength" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< HMACOutputLengthType > r( HMACOutputLengthTraits::create( i, f, this ) );

			if ( !this->HMACOutputLength_ )
			{
				this->HMACOutputLength_.set( r );
				continue;
			}
		}

		break;
	}

	while ( p.more_attributes() )
	{
		const ::xercesc::DOMAttr& i( p.next_attribute() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		if ( n.name() == "Algorithm" && n.namespace_().empty() )
		{
			::std::auto_ptr< AlgorithmType > r( AlgorithmTraits::create( i, f, this ) );

			this->Algorithm_.set( r );
			continue;
		}
	}

	if ( !Algorithm_.present() )
	{
		throw ::xsd::cxx::tree::expected_attribute< char > ( "Algorithm", "" );
	}
}

SignatureMethod* SignatureMethod::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class SignatureMethod( *this, f, c );
}

SignatureMethod::~SignatureMethod()
{
}

// Reference
//

Reference::Reference( const DigestMethodType& DigestMethod, const DigestValueType& DigestValue )
		: ::xml_schema::Type(), Transforms_( ::xml_schema::Flags(), this )
		, DigestMethod_( DigestMethod, ::xml_schema::Flags(), this )
		, DigestValue_( DigestValue, ::xml_schema::Flags(), this )
		, Id_( ::xml_schema::Flags(), this )
		, URI_( ::xml_schema::Flags(), this )
		, Type_( ::xml_schema::Flags(), this )
{
}

Reference::Reference( ::std::auto_ptr< DigestMethodType >& DigestMethod, const DigestValueType& DigestValue )
		: ::xml_schema::Type(), Transforms_( ::xml_schema::Flags(), this )
		, DigestMethod_( DigestMethod, ::xml_schema::Flags(), this )
		, DigestValue_( DigestValue, ::xml_schema::Flags(), this )
		, Id_( ::xml_schema::Flags(), this )
		, URI_( ::xml_schema::Flags(), this )
		, Type_( ::xml_schema::Flags(), this )
{
}

Reference::Reference( const Reference& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), Transforms_( x.Transforms_, f, this )
		, DigestMethod_( x.DigestMethod_, f, this )
		, DigestValue_( x.DigestValue_, f, this )
		, Id_( x.Id_, f, this )
		, URI_( x.URI_, f, this )
		, Type_( x.Type_, f, this )
{
}

Reference::Reference( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), Transforms_( f, this )
		, DigestMethod_( f, this )
		, DigestValue_( f, this )
		, Id_( f, this )
		, URI_( f, this )
		, Type_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, true );
		this->parse( p, f );
	}
}

void Reference::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// Transforms
		//
		if ( n.name() == "Transforms" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< TransformsType > r( TransformsTraits::create( i, f, this ) );

			if ( !this->Transforms_ )
			{
				this->Transforms_.set( r );
				continue;
			}
		}

		// DigestMethod
		//
		if ( n.name() == "DigestMethod" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< DigestMethodType > r( DigestMethodTraits::create( i, f, this ) );

			if ( !DigestMethod_.present() )
			{
				this->DigestMethod_.set( r );
				continue;
			}
		}

		// DigestValue
		//
		if ( n.name() == "DigestValue" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< DigestValueType > r( DigestValueTraits::create( i, f, this ) );

			if ( !DigestValue_.present() )
			{
				this->DigestValue_.set( r );
				continue;
			}
		}

		break;
	}

	if ( !DigestMethod_.present() )
	{
		throw ::xsd::cxx::tree::expected_element< char > ( "DigestMethod", XMLNS );
	}

	if ( !DigestValue_.present() )
	{
		throw ::xsd::cxx::tree::expected_element< char > ( "DigestValue", XMLNS );
	}

	while ( p.more_attributes() )
	{
		const ::xercesc::DOMAttr& i( p.next_attribute() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		if ( n.name() == "Id" && n.namespace_().empty() )
		{
			::std::auto_ptr< IdType > r( IdTraits::create( i, f, this ) );

			this->Id_.set( r );
			continue;
		}

		if ( n.name() == "URI" && n.namespace_().empty() )
		{
			::std::auto_ptr< URIType > r( URITraits::create( i, f, this ) );

			this->URI_.set( r );
			continue;
		}

		if ( n.name() == "Type" && n.namespace_().empty() )
		{
			::std::auto_ptr< TypeType > r( TypeTraits::create( i, f, this ) );

			this->Type_.set( r );
			continue;
		}
	}
}

Reference* Reference::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class Reference( *this, f, c );
}

Reference::~Reference()
{
}

// Transforms
//

Transforms::Transforms()
		: ::xml_schema::Type(), Transform_( ::xml_schema::Flags(), this )
{
}

Transforms::Transforms( const Transforms& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), Transform_( x.Transform_, f, this )
{
}

Transforms::Transforms( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), Transform_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, false );
		this->parse( p, f );
	}
}

void Transforms::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// Transform
		//
		if ( n.name() == "Transform" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< TransformType > r( TransformTraits::create( i, f, this ) );

			this->Transform_.push_back( r );
			continue;
		}

		break;
	}
}

Transforms* Transforms::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class Transforms( *this, f, c );
}

Transforms::~Transforms()
{
}

// Transform
//

Transform::Transform( const AlgorithmType& Algorithm )
		: ::xml_schema::Type(), XPath_( ::xml_schema::Flags(), this )
		, Algorithm_( Algorithm, ::xml_schema::Flags(), this )
{
}

Transform::Transform( const Transform& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), XPath_( x.XPath_, f, this )
		, Algorithm_( x.Algorithm_, f, this )
{
}

Transform::Transform( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), XPath_( f, this )
		, Algorithm_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, true );
		this->parse( p, f );
	}
}

void Transform::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// XPath
		//
		if ( n.name() == "XPath" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< XPathType > r( XPathTraits::create( i, f, this ) );

			this->XPath_.push_back( r );
			continue;
		}

		break;
	}

	while ( p.more_attributes() )
	{
		const ::xercesc::DOMAttr& i( p.next_attribute() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		if ( n.name() == "Algorithm" && n.namespace_().empty() )
		{
			::std::auto_ptr< AlgorithmType > r( AlgorithmTraits::create( i, f, this ) );

			this->Algorithm_.set( r );
			continue;
		}
	}

	if ( !Algorithm_.present() )
	{
		throw ::xsd::cxx::tree::expected_attribute< char > ( "Algorithm", "" );
	}
}

Transform* Transform::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class Transform( *this, f, c );
}

Transform::~Transform()
{
}

// DigestMethod
//

DigestMethod::DigestMethod( const AlgorithmType& Algorithm )
		: ::xml_schema::Type(), Algorithm_( Algorithm, ::xml_schema::Flags(), this )
{
}

DigestMethod::DigestMethod( const DigestMethod& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), Algorithm_( x.Algorithm_, f, this )
{
}

DigestMethod::DigestMethod( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), Algorithm_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, true );
		this->parse( p, f );
	}
}

void DigestMethod::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		break;
	}

	while ( p.more_attributes() )
	{
		const ::xercesc::DOMAttr& i( p.next_attribute() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		if ( n.name() == "Algorithm" && n.namespace_().empty() )
		{
			::std::auto_ptr< AlgorithmType > r( AlgorithmTraits::create( i, f, this ) );

			this->Algorithm_.set( r );
			continue;
		}
	}

	if ( !Algorithm_.present() )
	{
		throw ::xsd::cxx::tree::expected_attribute< char > ( "Algorithm", "" );
	}
}

DigestMethod* DigestMethod::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class DigestMethod( *this, f, c );
}

DigestMethod::~DigestMethod()
{
}

// DigestValue
//

DigestValue::DigestValue()
		: ::xml_schema::Base64Binary()
{
}

DigestValue::DigestValue( const ::xml_schema::Base64Binary& _xsd_Base64Binary_base )
		: ::xml_schema::Base64Binary( _xsd_Base64Binary_base )
{
}

DigestValue::DigestValue( const DigestValue& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Base64Binary( x, f, c )
{
}

DigestValue::DigestValue( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Base64Binary( e, f, c )
{
}

DigestValue::DigestValue( const ::xercesc::DOMAttr& a, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Base64Binary( a, f, c )
{
}

DigestValue::DigestValue( const ::std::string& s, const ::xercesc::DOMElement* e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Base64Binary( s, e, f, c )
{
}

DigestValue* DigestValue::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class DigestValue( *this, f, c );
}

DigestValue::~DigestValue()
{
}

// KeyInfo
//

KeyInfo::KeyInfo()
		: ::xml_schema::Type(), KeyName_( ::xml_schema::Flags(), this )
		, KeyValue_( ::xml_schema::Flags(), this )
		, RetrievalMethod_( ::xml_schema::Flags(), this )
		, X509Data_( ::xml_schema::Flags(), this )
		, PGPData_( ::xml_schema::Flags(), this )
		, SPKIData_( ::xml_schema::Flags(), this )
		, MgmtData_( ::xml_schema::Flags(), this )
		, Id_( ::xml_schema::Flags(), this )
{
}

KeyInfo::KeyInfo( const KeyInfo& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), KeyName_( x.KeyName_, f, this )
		, KeyValue_( x.KeyValue_, f, this )
		, RetrievalMethod_( x.RetrievalMethod_, f, this )
		, X509Data_( x.X509Data_, f, this )
		, PGPData_( x.PGPData_, f, this )
		, SPKIData_( x.SPKIData_, f, this )
		, MgmtData_( x.MgmtData_, f, this )
		, Id_( x.Id_, f, this )
{
}

KeyInfo::KeyInfo( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), KeyName_( f, this )
		, KeyValue_( f, this )
		, RetrievalMethod_( f, this )
		, X509Data_( f, this )
		, PGPData_( f, this )
		, SPKIData_( f, this )
		, MgmtData_( f, this )
		, Id_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, true );
		this->parse( p, f );
	}
}

void KeyInfo::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// KeyName
		//
		if ( n.name() == "KeyName" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< KeyNameType > r( KeyNameTraits::create( i, f, this ) );

			this->KeyName_.push_back( r );
			continue;
		}

		// KeyValue
		//
		if ( n.name() == "KeyValue" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< KeyValueType > r( KeyValueTraits::create( i, f, this ) );

			this->KeyValue_.push_back( r );
			continue;
		}

		// RetrievalMethod
		//
		if ( n.name() == "RetrievalMethod" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< RetrievalMethodType > r( RetrievalMethodTraits::create( i, f, this ) );

			this->RetrievalMethod_.push_back( r );
			continue;
		}

		// X509Data
		//
		if ( n.name() == "X509Data" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< X509DataType > r( X509DataTraits::create( i, f, this ) );

			this->X509Data_.push_back( r );
			continue;
		}

		// PGPData
		//
		if ( n.name() == "PGPData" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< PGPDataType > r( PGPDataTraits::create( i, f, this ) );

			this->PGPData_.push_back( r );
			continue;
		}

		// SPKIData
		//
		if ( n.name() == "SPKIData" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< SPKIDataType > r( SPKIDataTraits::create( i, f, this ) );

			this->SPKIData_.push_back( r );
			continue;
		}

		// MgmtData
		//
		if ( n.name() == "MgmtData" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< MgmtDataType > r( MgmtDataTraits::create( i, f, this ) );

			this->MgmtData_.push_back( r );
			continue;
		}

		break;
	}

	while ( p.more_attributes() )
	{
		const ::xercesc::DOMAttr& i( p.next_attribute() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		if ( n.name() == "Id" && n.namespace_().empty() )
		{
			::std::auto_ptr< IdType > r( IdTraits::create( i, f, this ) );

			this->Id_.set( r );
			continue;
		}
	}
}

KeyInfo* KeyInfo::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class KeyInfo( *this, f, c );
}

KeyInfo::~KeyInfo()
{
}

// KeyValue
//

KeyValue::KeyValue()
		: ::xml_schema::Type(), DSAKeyValue_( ::xml_schema::Flags(), this )
		, RSAKeyValue_( ::xml_schema::Flags(), this )
{
}

KeyValue::KeyValue( const KeyValue& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), DSAKeyValue_( x.DSAKeyValue_, f, this )
		, RSAKeyValue_( x.RSAKeyValue_, f, this )
{
}

KeyValue::KeyValue( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), DSAKeyValue_( f, this )
		, RSAKeyValue_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, false );
		this->parse( p, f );
	}
}

void KeyValue::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// DSAKeyValue
		//
		if ( n.name() == "DSAKeyValue" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< DSAKeyValueType > r( DSAKeyValueTraits::create( i, f, this ) );

			if ( !this->DSAKeyValue_ )
			{
				this->DSAKeyValue_.set( r );
				continue;
			}
		}

		// RSAKeyValue
		//
		if ( n.name() == "RSAKeyValue" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< RSAKeyValueType > r( RSAKeyValueTraits::create( i, f, this ) );

			if ( !this->RSAKeyValue_ )
			{
				this->RSAKeyValue_.set( r );
				continue;
			}
		}

		break;
	}
}

KeyValue* KeyValue::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class KeyValue( *this, f, c );
}

KeyValue::~KeyValue()
{
}

// RetrievalMethod
//

RetrievalMethod::RetrievalMethod()
		: ::xml_schema::Type(), Transforms_( ::xml_schema::Flags(), this )
		, URI_( ::xml_schema::Flags(), this )
		, Type_( ::xml_schema::Flags(), this )
{
}

RetrievalMethod::RetrievalMethod( const RetrievalMethod& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), Transforms_( x.Transforms_, f, this )
		, URI_( x.URI_, f, this )
		, Type_( x.Type_, f, this )
{
}

RetrievalMethod::RetrievalMethod( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), Transforms_( f, this )
		, URI_( f, this )
		, Type_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, true );
		this->parse( p, f );
	}
}

void RetrievalMethod::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// Transforms
		//
		if ( n.name() == "Transforms" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< TransformsType > r( TransformsTraits::create( i, f, this ) );

			if ( !this->Transforms_ )
			{
				this->Transforms_.set( r );
				continue;
			}
		}

		break;
	}

	while ( p.more_attributes() )
	{
		const ::xercesc::DOMAttr& i( p.next_attribute() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		if ( n.name() == "URI" && n.namespace_().empty() )
		{
			::std::auto_ptr< URIType > r( URITraits::create( i, f, this ) );

			this->URI_.set( r );
			continue;
		}

		if ( n.name() == "Type" && n.namespace_().empty() )
		{
			::std::auto_ptr< TypeType > r( TypeTraits::create( i, f, this ) );

			this->Type_.set( r );
			continue;
		}
	}
}

RetrievalMethod* RetrievalMethod::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class RetrievalMethod( *this, f, c );
}

RetrievalMethod::~RetrievalMethod()
{
}

// X509Data
//

X509Data::X509Data()
		: ::xml_schema::Type(), X509IssuerSerial_( ::xml_schema::Flags(), this )
		, X509SKI_( ::xml_schema::Flags(), this )
		, X509SubjectName_( ::xml_schema::Flags(), this )
		, X509Certificate_( ::xml_schema::Flags(), this )
		, X509CRL_( ::xml_schema::Flags(), this )
{
}

X509Data::X509Data( const X509Data& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), X509IssuerSerial_( x.X509IssuerSerial_, f, this )
		, X509SKI_( x.X509SKI_, f, this )
		, X509SubjectName_( x.X509SubjectName_, f, this )
		, X509Certificate_( x.X509Certificate_, f, this )
		, X509CRL_( x.X509CRL_, f, this )
{
}

X509Data::X509Data( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), X509IssuerSerial_( f, this )
		, X509SKI_( f, this )
		, X509SubjectName_( f, this )
		, X509Certificate_( f, this )
		, X509CRL_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, false );
		this->parse( p, f );
	}
}

void X509Data::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// X509IssuerSerial
		//
		if ( n.name() == "X509IssuerSerial" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< X509IssuerSerialType > r( X509IssuerSerialTraits::create( i, f, this ) );

			this->X509IssuerSerial_.push_back( r );
			continue;
		}

		// X509SKI
		//
		if ( n.name() == "X509SKI" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< X509SKIType > r( X509SKITraits::create( i, f, this ) );

			this->X509SKI_.push_back( r );
			continue;
		}

		// X509SubjectName
		//
		if ( n.name() == "X509SubjectName" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< X509SubjectNameType > r( X509SubjectNameTraits::create( i, f, this ) );

			this->X509SubjectName_.push_back( r );
			continue;
		}

		// X509Certificate
		//
		if ( n.name() == "X509Certificate" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< X509CertificateType > r( X509CertificateTraits::create( i, f, this ) );

			this->X509Certificate_.push_back( r );
			continue;
		}

		// X509CRL
		//
		if ( n.name() == "X509CRL" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< X509CRLType > r( X509CRLTraits::create( i, f, this ) );

			this->X509CRL_.push_back( r );
			continue;
		}

		break;
	}
}

X509Data* X509Data::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class X509Data( *this, f, c );
}

X509Data::~X509Data()
{
}

// X509IssuerSerial
//

X509IssuerSerial::X509IssuerSerial( const X509IssuerNameType& X509IssuerName, const X509SerialNumberType& X509SerialNumber )
		: ::xml_schema::Type(), X509IssuerName_( X509IssuerName, ::xml_schema::Flags(), this )
		, X509SerialNumber_( X509SerialNumber, ::xml_schema::Flags(), this )
{
}

X509IssuerSerial::X509IssuerSerial( const X509IssuerSerial& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), X509IssuerName_( x.X509IssuerName_, f, this )
		, X509SerialNumber_( x.X509SerialNumber_, f, this )
{
}

X509IssuerSerial::X509IssuerSerial( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), X509IssuerName_( f, this )
		, X509SerialNumber_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, false );
		this->parse( p, f );
	}
}

void X509IssuerSerial::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// X509IssuerName
		//
		if ( n.name() == "X509IssuerName" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< X509IssuerNameType > r( X509IssuerNameTraits::create( i, f, this ) );

			if ( !X509IssuerName_.present() )
			{
				this->X509IssuerName_.set( r );
				continue;
			}
		}

		// X509SerialNumber
		//
		if ( n.name() == "X509SerialNumber" && n.namespace_() == XMLNS )
		{
			if ( !X509SerialNumber_.present() )
			{
				this->X509SerialNumber_.set( X509SerialNumberTraits::create( i, f, this ) );
				continue;
			}
		}

		break;
	}

	if ( !X509IssuerName_.present() )
	{
		throw ::xsd::cxx::tree::expected_element< char > ( "X509IssuerName", XMLNS );
	}

	if ( !X509SerialNumber_.present() )
	{
		throw ::xsd::cxx::tree::expected_element< char > ( "X509SerialNumber", XMLNS );
	}
}

X509IssuerSerial* X509IssuerSerial::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class X509IssuerSerial( *this, f, c );
}

X509IssuerSerial::~X509IssuerSerial()
{
}

// PGPData
//

PGPData::PGPData()
		: ::xml_schema::Type(), PGPKeyID_( ::xml_schema::Flags(), this )
		, PGPKeyPacket_( ::xml_schema::Flags(), this )
{
}

PGPData::PGPData( const PGPData& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), PGPKeyID_( x.PGPKeyID_, f, this )
		, PGPKeyPacket_( x.PGPKeyPacket_, f, this )
{
}

PGPData::PGPData( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), PGPKeyID_( f, this )
		, PGPKeyPacket_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, false );
		this->parse( p, f );
	}
}

void PGPData::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// PGPKeyID
		//
		if ( n.name() == "PGPKeyID" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< PGPKeyIDType > r( PGPKeyIDTraits::create( i, f, this ) );

			if ( !this->PGPKeyID_ )
			{
				this->PGPKeyID_.set( r );
				continue;
			}
		}

		// PGPKeyPacket
		//
		if ( n.name() == "PGPKeyPacket" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< PGPKeyPacketType > r( PGPKeyPacketTraits::create( i, f, this ) );

			if ( !this->PGPKeyPacket_ )
			{
				this->PGPKeyPacket_.set( r );
				continue;
			}
		}

		break;
	}
}

PGPData* PGPData::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class PGPData( *this, f, c );
}

PGPData::~PGPData()
{
}

// SPKIData
//

SPKIData::SPKIData()
		: ::xml_schema::Type(), SPKISexp_( ::xml_schema::Flags(), this )
{
}

SPKIData::SPKIData( const SPKIData& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), SPKISexp_( x.SPKISexp_, f, this )
{
}

SPKIData::SPKIData( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), SPKISexp_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, false );
		this->parse( p, f );
	}
}

void SPKIData::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// SPKISexp
		//
		if ( n.name() == "SPKISexp" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< SPKISexpType > r( SPKISexpTraits::create( i, f, this ) );

			this->SPKISexp_.push_back( r );
			continue;
		}

		break;
	}
}

SPKIData* SPKIData::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class SPKIData( *this, f, c );
}

SPKIData::~SPKIData()
{
}

// Object
//

Object::Object()
		: ::xml_schema::Type(), Id_( ::xml_schema::Flags(), this )
		, MimeType_( ::xml_schema::Flags(), this )
		, Encoding_( ::xml_schema::Flags(), this )
{
}

Object::Object( const Object& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), Id_( x.Id_, f, this )
		, MimeType_( x.MimeType_, f, this )
		, Encoding_( x.Encoding_, f, this )
{
}

Object::Object( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), Id_( f, this )
		, MimeType_( f, this )
		, Encoding_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, true );
		this->parse( p, f );
	}
}

void Object::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		break;
	}

	while ( p.more_attributes() )
	{
		const ::xercesc::DOMAttr& i( p.next_attribute() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		if ( n.name() == "Id" && n.namespace_().empty() )
		{
			::std::auto_ptr< IdType > r( IdTraits::create( i, f, this ) );

			this->Id_.set( r );
			continue;
		}

		if ( n.name() == "MimeType" && n.namespace_().empty() )
		{
			::std::auto_ptr< MimeTypeType > r( MimeTypeTraits::create( i, f, this ) );

			this->MimeType_.set( r );
			continue;
		}

		if ( n.name() == "Encoding" && n.namespace_().empty() )
		{
			::std::auto_ptr< EncodingType > r( EncodingTraits::create( i, f, this ) );

			this->Encoding_.set( r );
			continue;
		}
	}
}

Object* Object::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class Object( *this, f, c );
}

Object::~Object()
{
}

// Manifest
//

Manifest::Manifest()
		: ::xml_schema::Type(), Reference_( ::xml_schema::Flags(), this )
		, Id_( ::xml_schema::Flags(), this )
{
}

Manifest::Manifest( const Manifest& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), Reference_( x.Reference_, f, this )
		, Id_( x.Id_, f, this )
{
}

Manifest::Manifest( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), Reference_( f, this )
		, Id_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, true );
		this->parse( p, f );
	}
}

void Manifest::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// Reference
		//
		if ( n.name() == "Reference" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< ReferenceType > r( ReferenceTraits::create( i, f, this ) );

			this->Reference_.push_back( r );
			continue;
		}

		break;
	}

	while ( p.more_attributes() )
	{
		const ::xercesc::DOMAttr& i( p.next_attribute() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		if ( n.name() == "Id" && n.namespace_().empty() )
		{
			::std::auto_ptr< IdType > r( IdTraits::create( i, f, this ) );

			this->Id_.set( r );
			continue;
		}
	}
}

Manifest* Manifest::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class Manifest( *this, f, c );
}

Manifest::~Manifest()
{
}

// SignatureProperties
//

SignatureProperties::SignatureProperties()
		: ::xml_schema::Type(), SignatureProperty_( ::xml_schema::Flags(), this )
		, Id_( ::xml_schema::Flags(), this )
{
}

SignatureProperties::SignatureProperties( const SignatureProperties& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), SignatureProperty_( x.SignatureProperty_, f, this )
		, Id_( x.Id_, f, this )
{
}

SignatureProperties::SignatureProperties( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), SignatureProperty_( f, this )
		, Id_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, true );
		this->parse( p, f );
	}
}

void SignatureProperties::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// SignatureProperty
		//
		if ( n.name() == "SignatureProperty" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< SignaturePropertyType > r( SignaturePropertyTraits::create( i, f, this ) );

			this->SignatureProperty_.push_back( r );
			continue;
		}

		break;
	}

	while ( p.more_attributes() )
	{
		const ::xercesc::DOMAttr& i( p.next_attribute() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		if ( n.name() == "Id" && n.namespace_().empty() )
		{
			::std::auto_ptr< IdType > r( IdTraits::create( i, f, this ) );

			this->Id_.set( r );
			continue;
		}
	}
}

SignatureProperties* SignatureProperties::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class SignatureProperties( *this, f, c );
}

SignatureProperties::~SignatureProperties()
{
}

// SignatureProperty
//

SignatureProperty::SignatureProperty( const TargetType& Target )
		: ::xml_schema::Type(), Target_( Target, ::xml_schema::Flags(), this )
		, Id_( ::xml_schema::Flags(), this )
{
}

SignatureProperty::SignatureProperty( const SignatureProperty& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), Target_( x.Target_, f, this )
		, Id_( x.Id_, f, this )
{
}

SignatureProperty::SignatureProperty( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), Target_( f, this )
		, Id_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, true );
		this->parse( p, f );
	}
}

void SignatureProperty::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		break;
	}

	while ( p.more_attributes() )
	{
		const ::xercesc::DOMAttr& i( p.next_attribute() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		if ( n.name() == "Target" && n.namespace_().empty() )
		{
			::std::auto_ptr< TargetType > r( TargetTraits::create( i, f, this ) );

			this->Target_.set( r );
			continue;
		}

		if ( n.name() == "Id" && n.namespace_().empty() )
		{
			::std::auto_ptr< IdType > r( IdTraits::create( i, f, this ) );

			this->Id_.set( r );
			continue;
		}
	}

	if ( !Target_.present() )
	{
		throw ::xsd::cxx::tree::expected_attribute< char > ( "Target", "" );
	}
}

SignatureProperty* SignatureProperty::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class SignatureProperty( *this, f, c );
}

SignatureProperty::~SignatureProperty()
{
}

// HMACOutputLength
//

HMACOutputLength::HMACOutputLength( const ::xml_schema::Integer& _xsd_Integer_base )
		: ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > ( _xsd_Integer_base )
{
}

HMACOutputLength::HMACOutputLength( const HMACOutputLength& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > ( x, f, c )
{
}

HMACOutputLength::HMACOutputLength( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > ( e, f, c )
{
}

HMACOutputLength::HMACOutputLength( const ::xercesc::DOMAttr& a, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > ( a, f, c )
{
}

HMACOutputLength::HMACOutputLength( const ::std::string& s, const ::xercesc::DOMElement* e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > ( s, e, f, c )
{
}

HMACOutputLength* HMACOutputLength::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class HMACOutputLength( *this, f, c );
}

HMACOutputLength::~HMACOutputLength()
{
}

// DSAKeyValue
//

DSAKeyValue::DSAKeyValue( const YType& Y )
		: ::xml_schema::Type(), P_( ::xml_schema::Flags(), this )
		, Q_( ::xml_schema::Flags(), this )
		, G_( ::xml_schema::Flags(), this )
		, Y_( Y, ::xml_schema::Flags(), this )
		, J_( ::xml_schema::Flags(), this )
		, Seed_( ::xml_schema::Flags(), this )
		, PgenCounter_( ::xml_schema::Flags(), this )
{
}

DSAKeyValue::DSAKeyValue( const DSAKeyValue& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), P_( x.P_, f, this )
		, Q_( x.Q_, f, this )
		, G_( x.G_, f, this )
		, Y_( x.Y_, f, this )
		, J_( x.J_, f, this )
		, Seed_( x.Seed_, f, this )
		, PgenCounter_( x.PgenCounter_, f, this )
{
}

DSAKeyValue::DSAKeyValue( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), P_( f, this )
		, Q_( f, this )
		, G_( f, this )
		, Y_( f, this )
		, J_( f, this )
		, Seed_( f, this )
		, PgenCounter_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, false );
		this->parse( p, f );
	}
}

void DSAKeyValue::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// P
		//
		if ( n.name() == "P" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< PType > r( PTraits::create( i, f, this ) );

			if ( !this->P_ )
			{
				this->P_.set( r );
				continue;
			}
		}

		// Q
		//
		if ( n.name() == "Q" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< QType > r( QTraits::create( i, f, this ) );

			if ( !this->Q_ )
			{
				this->Q_.set( r );
				continue;
			}
		}

		// G
		//
		if ( n.name() == "G" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< GType > r( GTraits::create( i, f, this ) );

			if ( !this->G_ )
			{
				this->G_.set( r );
				continue;
			}
		}

		// Y
		//
		if ( n.name() == "Y" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< YType > r( YTraits::create( i, f, this ) );

			if ( !Y_.present() )
			{
				this->Y_.set( r );
				continue;
			}
		}

		// J
		//
		if ( n.name() == "J" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< JType > r( JTraits::create( i, f, this ) );

			if ( !this->J_ )
			{
				this->J_.set( r );
				continue;
			}
		}

		// Seed
		//
		if ( n.name() == "Seed" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< SeedType > r( SeedTraits::create( i, f, this ) );

			if ( !this->Seed_ )
			{
				this->Seed_.set( r );
				continue;
			}
		}

		// PgenCounter
		//
		if ( n.name() == "PgenCounter" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< PgenCounterType > r( PgenCounterTraits::create( i, f, this ) );

			if ( !this->PgenCounter_ )
			{
				this->PgenCounter_.set( r );
				continue;
			}
		}

		break;
	}

	if ( !Y_.present() )
	{
		throw ::xsd::cxx::tree::expected_element< char > ( "Y", XMLNS );
	}
}

DSAKeyValue* DSAKeyValue::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class DSAKeyValue( *this, f, c );
}

DSAKeyValue::~DSAKeyValue()
{
}

// RSAKeyValue
//

RSAKeyValue::RSAKeyValue( const ModulusType& Modulus, const ExponentType& Exponent )
		: ::xml_schema::Type(), Modulus_( Modulus, ::xml_schema::Flags(), this )
		, Exponent_( Exponent, ::xml_schema::Flags(), this )
{
}

RSAKeyValue::RSAKeyValue( const RSAKeyValue& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), Modulus_( x.Modulus_, f, this )
		, Exponent_( x.Exponent_, f, this )
{
}

RSAKeyValue::RSAKeyValue( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), Modulus_( f, this )
		, Exponent_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, false );
		this->parse( p, f );
	}
}

void RSAKeyValue::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// Modulus
		//
		if ( n.name() == "Modulus" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< ModulusType > r( ModulusTraits::create( i, f, this ) );

			if ( !Modulus_.present() )
			{
				this->Modulus_.set( r );
				continue;
			}
		}

		// Exponent
		//
		if ( n.name() == "Exponent" && n.namespace_() == XMLNS )
		{
			::std::auto_ptr< ExponentType > r( ExponentTraits::create( i, f, this ) );

			if ( !Exponent_.present() )
			{
				this->Exponent_.set( r );
				continue;
			}
		}

		break;
	}

	if ( !Modulus_.present() )
	{
		throw ::xsd::cxx::tree::expected_element< char > ( "Modulus", XMLNS );
	}

	if ( !Exponent_.present() )
	{
		throw ::xsd::cxx::tree::expected_element< char > ( "Exponent", XMLNS );
	}
}

RSAKeyValue* RSAKeyValue::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class RSAKeyValue( *this, f, c );
}

RSAKeyValue::~RSAKeyValue()
{
}
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace ds
{
::std::auto_ptr< ::ds::Signature > signature( const ::std::string& u, ::xml_schema::Flags f, const ::xml_schema::Properties& p )
{
	::xsd::cxx::xml::auto_initializer i(( f & ::xml_schema::Flags::dont_initialize ) == 0, ( f & ::xml_schema::Flags::keep_dom ) == 0 );

	::xsd::cxx::tree::error_handler< char > h;

	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d( ::xsd::cxx::xml::dom::parse< char > ( u, h, p, f ) );

	h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

	::std::auto_ptr< ::ds::Signature > r( ::ds::signature( d, f | ::xml_schema::Flags::own_dom, p ) );

	return r;
}

::std::auto_ptr< ::ds::Signature > signature( const ::std::string& u, ::xml_schema::ErrorHandler& h, ::xml_schema::Flags f, const ::xml_schema::Properties& p )
{
	::xsd::cxx::xml::auto_initializer i(( f & ::xml_schema::Flags::dont_initialize ) == 0, ( f & ::xml_schema::Flags::keep_dom ) == 0 );

	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d( ::xsd::cxx::xml::dom::parse< char > ( u, h, p, f ) );

	if ( !d.get() )
		throw ::xsd::cxx::tree::parsing< char > ();

	::std::auto_ptr< ::ds::Signature > r( ::ds::signature( d, f | ::xml_schema::Flags::own_dom, p ) );

	return r;
}

::std::auto_ptr< ::ds::Signature > signature( const ::std::string& u, ::xercesc::DOMErrorHandler& h, ::xml_schema::Flags f, const ::xml_schema::Properties& p )
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d( ::xsd::cxx::xml::dom::parse< char > ( u, h, p, f ) );

	if ( !d.get() )
		throw ::xsd::cxx::tree::parsing< char > ();

	::std::auto_ptr< ::ds::Signature > r( ::ds::signature( d, f | ::xml_schema::Flags::own_dom, p ) );

	return r;
}

::std::auto_ptr< ::ds::Signature > signature( ::std::istream& is, ::xml_schema::Flags f, const ::xml_schema::Properties& p )
{
	::xsd::cxx::xml::auto_initializer i(( f & ::xml_schema::Flags::dont_initialize ) == 0, ( f & ::xml_schema::Flags::keep_dom ) == 0 );

	::xsd::cxx::xml::sax::std_input_source isrc( is );
	return ::ds::signature( isrc, f, p );
}

::std::auto_ptr< ::ds::Signature > signature( ::std::istream& is, ::xml_schema::ErrorHandler& h, ::xml_schema::Flags f, const ::xml_schema::Properties& p )
{
	::xsd::cxx::xml::auto_initializer i(( f & ::xml_schema::Flags::dont_initialize ) == 0, ( f & ::xml_schema::Flags::keep_dom ) == 0 );

	::xsd::cxx::xml::sax::std_input_source isrc( is );
	return ::ds::signature( isrc, h, f, p );
}

::std::auto_ptr< ::ds::Signature > signature( ::std::istream& is, ::xercesc::DOMErrorHandler& h, ::xml_schema::Flags f, const ::xml_schema::Properties& p )
{
	::xsd::cxx::xml::sax::std_input_source isrc( is );
	return ::ds::signature( isrc, h, f, p );
}

::std::auto_ptr< ::ds::Signature > signature( ::std::istream& is, const ::std::string& sid, ::xml_schema::Flags f, const ::xml_schema::Properties& p )
{
	::xsd::cxx::xml::auto_initializer i(( f & ::xml_schema::Flags::dont_initialize ) == 0, ( f & ::xml_schema::Flags::keep_dom ) == 0 );

	::xsd::cxx::xml::sax::std_input_source isrc( is, sid );
	return ::ds::signature( isrc, f, p );
}

::std::auto_ptr< ::ds::Signature > signature( ::std::istream& is, const ::std::string& sid, ::xml_schema::ErrorHandler& h, ::xml_schema::Flags f, const ::xml_schema::Properties& p )
{
	::xsd::cxx::xml::auto_initializer i(( f & ::xml_schema::Flags::dont_initialize ) == 0, ( f & ::xml_schema::Flags::keep_dom ) == 0 );

	::xsd::cxx::xml::sax::std_input_source isrc( is, sid );
	return ::ds::signature( isrc, h, f, p );
}

::std::auto_ptr< ::ds::Signature > signature( ::std::istream& is, const ::std::string& sid, ::xercesc::DOMErrorHandler& h, ::xml_schema::Flags f, const ::xml_schema::Properties& p )
{
	::xsd::cxx::xml::sax::std_input_source isrc( is, sid );
	return ::ds::signature( isrc, h, f, p );
}

::std::auto_ptr< ::ds::Signature > signature( ::xercesc::InputSource& i, ::xml_schema::Flags f, const ::xml_schema::Properties& p )
{
	::xsd::cxx::tree::error_handler< char > h;

	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d( ::xsd::cxx::xml::dom::parse< char > ( i, h, p, f ) );

	h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

	::std::auto_ptr< ::ds::Signature > r( ::ds::signature( d, f | ::xml_schema::Flags::own_dom, p ) );

	return r;
}

::std::auto_ptr< ::ds::Signature > signature( ::xercesc::InputSource& i, ::xml_schema::ErrorHandler& h, ::xml_schema::Flags f, const ::xml_schema::Properties& p )
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d( ::xsd::cxx::xml::dom::parse< char > ( i, h, p, f ) );

	if ( !d.get() )
		throw ::xsd::cxx::tree::parsing< char > ();

	::std::auto_ptr< ::ds::Signature > r( ::ds::signature( d, f | ::xml_schema::Flags::own_dom, p ) );

	return r;
}

::std::auto_ptr< ::ds::Signature > signature( ::xercesc::InputSource& i, ::xercesc::DOMErrorHandler& h, ::xml_schema::Flags f, const ::xml_schema::Properties& p )
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d( ::xsd::cxx::xml::dom::parse< char > ( i, h, p, f ) );

	if ( !d.get() )
		throw ::xsd::cxx::tree::parsing< char > ();

	::std::auto_ptr< ::ds::Signature > r( ::ds::signature( d, f | ::xml_schema::Flags::own_dom, p ) );

	return r;
}

::std::auto_ptr< ::ds::Signature > signature( const ::xercesc::DOMDocument& d, ::xml_schema::Flags f, const ::xml_schema::Properties& p )
{
	if ( f & ::xml_schema::Flags::keep_dom )
	{
		::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c( static_cast< ::xercesc::DOMDocument* >( d.cloneNode( true ) ) );

		::std::auto_ptr< ::ds::Signature > r( ::ds::signature( c, f | ::xml_schema::Flags::own_dom, p ) );

		return r;
	}

	const ::xercesc::DOMElement& e( *d.getDocumentElement() );
	const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( e ) );

	if ( n.name() == "Signature" && n.namespace_() == XMLNS )
	{
		::std::auto_ptr< ::ds::Signature > r( ::xsd::cxx::tree::traits< ::ds::Signature, char >::create( e, f, 0 ) );
		return r;
	}

	throw ::xsd::cxx::tree::unexpected_element < char > ( n.name(), n.namespace_(), "Signature", XMLNS );
}

::std::auto_ptr< ::ds::Signature > signature( ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d, ::xml_schema::Flags f, const ::xml_schema::Properties& )
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c((( f & ::xml_schema::Flags::keep_dom ) && !( f & ::xml_schema::Flags::own_dom ) )
	                                                        ? static_cast< ::xercesc::DOMDocument* >( d->cloneNode( true ) )
	                                                        : 0 );

	::xercesc::DOMDocument& doc( c.get() ? *c : *d );
	const ::xercesc::DOMElement& e( *doc.getDocumentElement() );

	const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( e ) );

	if ( f & ::xml_schema::Flags::keep_dom )
		doc.setUserData( ::xml_schema::dom::treeNodeKey, ( c.get() ? &c : &d ), 0 );

	if ( n.name() == "Signature" && n.namespace_() == XMLNS )
	{
		::std::auto_ptr< ::ds::Signature > r( ::xsd::cxx::tree::traits< ::ds::Signature, char >::create( e, f, 0 ) );
		return r;
	}

	throw ::xsd::cxx::tree::unexpected_element < char > ( n.name(), n.namespace_(), "Signature", XMLNS );
}
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace ds
{
void operator<< ( ::xercesc::DOMElement& e, const CryptoBinary& i )
{
	e << static_cast< const ::xml_schema::Base64Binary& >( i );
}

void operator<< ( ::xercesc::DOMAttr& a, const CryptoBinary& i )
{
	a << static_cast< const ::xml_schema::Base64Binary& >( i );
}

void operator<< ( ::xml_schema::ListStream& l, const CryptoBinary& i )
{
	l << static_cast< const ::xml_schema::Base64Binary& >( i );
}

void signature( ::std::ostream& o, const ::ds::Signature& s, const ::xml_schema::NamespaceInfomap& m, const ::std::string& e, ::xml_schema::Flags f )
{
	::xsd::cxx::xml::auto_initializer i(( f & ::xml_schema::Flags::dont_initialize ) == 0 );

	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d( ::ds::signature( s, m, f ) );

	::xsd::cxx::tree::error_handler< char > h;

	::xsd::cxx::xml::dom::ostream_format_target t( o );
	if ( !::xsd::cxx::xml::dom::serialize( t, *d, e, h, f ) )
	{
		h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
	}
}

void signature( ::std::ostream& o, const ::ds::Signature& s, ::xml_schema::ErrorHandler& h, const ::xml_schema::NamespaceInfomap& m, const ::std::string& e, ::xml_schema::Flags f )
{
	::xsd::cxx::xml::auto_initializer i(( f & ::xml_schema::Flags::dont_initialize ) == 0 );

	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d( ::ds::signature( s, m, f ) );
	::xsd::cxx::xml::dom::ostream_format_target t( o );
	if ( !::xsd::cxx::xml::dom::serialize( t, *d, e, h, f ) )
	{
		throw ::xsd::cxx::tree::serialization< char > ();
	}
}

void signature( ::std::ostream& o, const ::ds::Signature& s, ::xercesc::DOMErrorHandler& h, const ::xml_schema::NamespaceInfomap& m, const ::std::string& e, ::xml_schema::Flags f )
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d( ::ds::signature( s, m, f ) );
	::xsd::cxx::xml::dom::ostream_format_target t( o );
	if ( !::xsd::cxx::xml::dom::serialize( t, *d, e, h, f ) )
	{
		throw ::xsd::cxx::tree::serialization< char > ();
	}
}

void signature( ::xercesc::XMLFormatTarget& t, const ::ds::Signature& s, const ::xml_schema::NamespaceInfomap& m, const ::std::string& e, ::xml_schema::Flags f )
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d( ::ds::signature( s, m, f ) );

	::xsd::cxx::tree::error_handler< char > h;

	if ( !::xsd::cxx::xml::dom::serialize( t, *d, e, h, f ) )
	{
		h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
	}
}

void signature( ::xercesc::XMLFormatTarget& t, const ::ds::Signature& s, ::xml_schema::ErrorHandler& h, const ::xml_schema::NamespaceInfomap& m, const ::std::string& e, ::xml_schema::Flags f )
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d( ::ds::signature( s, m, f ) );
	if ( !::xsd::cxx::xml::dom::serialize( t, *d, e, h, f ) )
	{
		throw ::xsd::cxx::tree::serialization< char > ();
	}
}

void signature( ::xercesc::XMLFormatTarget& t, const ::ds::Signature& s, ::xercesc::DOMErrorHandler& h, const ::xml_schema::NamespaceInfomap& m, const ::std::string& e, ::xml_schema::Flags f )
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d( ::ds::signature( s, m, f ) );
	if ( !::xsd::cxx::xml::dom::serialize( t, *d, e, h, f ) )
	{
		throw ::xsd::cxx::tree::serialization< char > ();
	}
}

void signature( ::xercesc::DOMDocument& d, const ::ds::Signature& s, ::xml_schema::Flags )
{
	::xercesc::DOMElement& e( *d.getDocumentElement() );
	const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( e ) );

	if ( n.name() == "Signature" && n.namespace_() == XMLNS )
	{
		e << s;
	}
	else
	{
		throw ::xsd::cxx::tree::unexpected_element < char > ( n.name(), n.namespace_(), "Signature", XMLNS );
	}
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > signature( const ::ds::Signature& s, const ::xml_schema::NamespaceInfomap& m, ::xml_schema::Flags f )
{
	::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d( ::xsd::cxx::xml::dom::serialize< char > ( "Signature", XMLNS, m, f ) );

	::ds::signature( *d, s, f );
	return d;
}

void operator<< ( ::xercesc::DOMElement& e, const Signature& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// SignedInfo
	//
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "SignedInfo", XMLNS, e ) );

		s << i.signedInfo();
	}

	// SignatureValue
	//
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "SignatureValue", XMLNS, e ) );

		s << i.signatureValue();
	}

	// KeyInfo
	//
	if ( i.keyInfo() )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "KeyInfo", XMLNS, e ) );

		s << *i.keyInfo();
	}

	// Object
	//
	for ( Signature::ObjectConstIterator
	        b( i.object().begin() ), n( i.object().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "Object", XMLNS, e ) );

		s << *b;
	}

	// Id
	//
	if ( i.id() )
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "Id", e ) );

		a << *i.id();
	}
}

void operator<< ( ::xercesc::DOMElement& e, const SignatureValue& i )
{
	e << static_cast< const ::xml_schema::Base64Binary& >( i );

	// Id
	//
	if ( i.id() )
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "Id", e ) );

		a << *i.id();
	}
}

void operator<< ( ::xercesc::DOMElement& e, const SignedInfo& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// CanonicalizationMethod
	//
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "CanonicalizationMethod", XMLNS, e ) );

		s << i.canonicalizationMethod();
	}

	// SignatureMethod
	//
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "SignatureMethod", XMLNS, e ) );

		s << i.signatureMethod();
	}

	// Reference
	//
	for ( SignedInfo::ReferenceConstIterator
	        b( i.reference().begin() ), n( i.reference().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "Reference", XMLNS, e ) );

		s << *b;
	}

	// Id
	//
	if ( i.id() )
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "Id", e ) );

		a << *i.id();
	}
}

void operator<< ( ::xercesc::DOMElement& e, const CanonicalizationMethod& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// Algorithm
	//
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "Algorithm", e ) );

		a << i.algorithm();
	}
}

void operator<< ( ::xercesc::DOMElement& e, const SignatureMethod& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// HMACOutputLength
	//
	if ( i.hMACOutputLength() )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "HMACOutputLength", XMLNS, e ) );

		s << *i.hMACOutputLength();
	}

	// Algorithm
	//
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "Algorithm", e ) );

		a << i.algorithm();
	}
}

void operator<< ( ::xercesc::DOMElement& e, const Reference& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// Transforms
	//
	if ( i.transforms() )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "Transforms", XMLNS, e ) );

		s << *i.transforms();
	}

	// DigestMethod
	//
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "DigestMethod", XMLNS, e ) );

		s << i.digestMethod();
	}

	// DigestValue
	//
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "DigestValue", XMLNS, e ) );

		s << i.digestValue();
	}

	// Id
	//
	if ( i.id() )
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "Id", e ) );

		a << *i.id();
	}

	// URI
	//
	if ( i.uRI() )
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "URI", e ) );

		a << *i.uRI();
	}

	// Type
	//
	if ( i.type() )
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "Type", e ) );

		a << *i.type();
	}
}

void operator<< ( ::xercesc::DOMElement& e, const Transforms& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// Transform
	//
	for ( Transforms::TransformConstIterator
	        b( i.transform().begin() ), n( i.transform().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "Transform", XMLNS, e ) );

		s << *b;
	}
}

void operator<< ( ::xercesc::DOMElement& e, const Transform& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// XPath
	//
	for ( Transform::XPathConstIterator
	        b( i.xPath().begin() ), n( i.xPath().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "XPath", XMLNS, e ) );

		s << *b;
	}

	// Algorithm
	//
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "Algorithm", e ) );

		a << i.algorithm();
	}
}

void operator<< ( ::xercesc::DOMElement& e, const DigestMethod& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// Algorithm
	//
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "Algorithm", e ) );

		a << i.algorithm();
	}
}

void operator<< ( ::xercesc::DOMElement& e, const DigestValue& i )
{
	e << static_cast< const ::xml_schema::Base64Binary& >( i );
}

void operator<< ( ::xercesc::DOMAttr& a, const DigestValue& i )
{
	a << static_cast< const ::xml_schema::Base64Binary& >( i );
}

void operator<< ( ::xml_schema::ListStream& l, const DigestValue& i )
{
	l << static_cast< const ::xml_schema::Base64Binary& >( i );
}

void operator<< ( ::xercesc::DOMElement& e, const KeyInfo& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// KeyName
	//
	for ( KeyInfo::KeyNameConstIterator
	        b( i.keyName().begin() ), n( i.keyName().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "KeyName", XMLNS, e ) );

		s << *b;
	}

	// KeyValue
	//
	for ( KeyInfo::KeyValueConstIterator
	        b( i.keyValue().begin() ), n( i.keyValue().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "KeyValue", XMLNS, e ) );

		s << *b;
	}

	// RetrievalMethod
	//
	for ( KeyInfo::RetrievalMethodConstIterator
	        b( i.retrievalMethod().begin() ), n( i.retrievalMethod().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "RetrievalMethod", XMLNS, e ) );

		s << *b;
	}

	// X509Data
	//
	for ( KeyInfo::X509DataConstIterator
	        b( i.x509Data().begin() ), n( i.x509Data().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "X509Data", XMLNS, e ) );

		s << *b;
	}

	// PGPData
	//
	for ( KeyInfo::PGPDataConstIterator
	        b( i.pGPData().begin() ), n( i.pGPData().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "PGPData", XMLNS, e ) );

		s << *b;
	}

	// SPKIData
	//
	for ( KeyInfo::SPKIDataConstIterator
	        b( i.sPKIData().begin() ), n( i.sPKIData().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "SPKIData", XMLNS, e ) );

		s << *b;
	}

	// MgmtData
	//
	for ( KeyInfo::MgmtDataConstIterator
	        b( i.mgmtData().begin() ), n( i.mgmtData().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "MgmtData", XMLNS, e ) );

		s << *b;
	}

	// Id
	//
	if ( i.id() )
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "Id", e ) );

		a << *i.id();
	}
}

void operator<< ( ::xercesc::DOMElement& e, const KeyValue& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// DSAKeyValue
	//
	if ( i.dSAKeyValue() )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "DSAKeyValue", XMLNS, e ) );

		s << *i.dSAKeyValue();
	}

	// RSAKeyValue
	//
	if ( i.rSAKeyValue() )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "RSAKeyValue", XMLNS, e ) );

		s << *i.rSAKeyValue();
	}
}

void operator<< ( ::xercesc::DOMElement& e, const RetrievalMethod& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// Transforms
	//
	if ( i.transforms() )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "Transforms", XMLNS, e ) );

		s << *i.transforms();
	}

	// URI
	//
	if ( i.uRI() )
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "URI", e ) );

		a << *i.uRI();
	}

	// Type
	//
	if ( i.type() )
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "Type", e ) );

		a << *i.type();
	}
}

void operator<< ( ::xercesc::DOMElement& e, const X509Data& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// X509IssuerSerial
	//
	for ( X509Data::X509IssuerSerialConstIterator
	        b( i.x509IssuerSerial().begin() ), n( i.x509IssuerSerial().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "X509IssuerSerial", XMLNS, e ) );

		s << *b;
	}

	// X509SKI
	//
	for ( X509Data::X509SKIConstIterator
	        b( i.x509SKI().begin() ), n( i.x509SKI().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "X509SKI", XMLNS, e ) );

		s << *b;
	}

	// X509SubjectName
	//
	for ( X509Data::X509SubjectNameConstIterator
	        b( i.x509SubjectName().begin() ), n( i.x509SubjectName().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "X509SubjectName", XMLNS, e ) );

		s << *b;
	}

	// X509Certificate
	//
	for ( X509Data::X509CertificateConstIterator
	        b( i.x509Certificate().begin() ), n( i.x509Certificate().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "X509Certificate", XMLNS, e ) );

		s << *b;
	}

	// X509CRL
	//
	for ( X509Data::X509CRLConstIterator
	        b( i.x509CRL().begin() ), n( i.x509CRL().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "X509CRL", XMLNS, e ) );

		s << *b;
	}
}

void operator<< ( ::xercesc::DOMElement& e, const X509IssuerSerial& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// X509IssuerName
	//
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "X509IssuerName", XMLNS, e ) );

		s << i.x509IssuerName();
	}

	// X509SerialNumber
	//
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "X509SerialNumber", XMLNS, e ) );

		s << i.x509SerialNumber();
	}
}

void operator<< ( ::xercesc::DOMElement& e, const PGPData& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// PGPKeyID
	//
	if ( i.pGPKeyID() )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "PGPKeyID", XMLNS, e ) );

		s << *i.pGPKeyID();
	}

	// PGPKeyPacket
	//
	if ( i.pGPKeyPacket() )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "PGPKeyPacket", XMLNS, e ) );

		s << *i.pGPKeyPacket();
	}
}

void operator<< ( ::xercesc::DOMElement& e, const SPKIData& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// SPKISexp
	//
	for ( SPKIData::SPKISexpConstIterator
	        b( i.sPKISexp().begin() ), n( i.sPKISexp().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "SPKISexp", XMLNS, e ) );

		s << *b;
	}
}

void operator<< ( ::xercesc::DOMElement& e, const Object& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// Id
	//
	if ( i.id() )
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "Id", e ) );

		a << *i.id();
	}

	// MimeType
	//
	if ( i.mimeType() )
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "MimeType", e ) );

		a << *i.mimeType();
	}

	// Encoding
	//
	if ( i.encoding() )
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "Encoding", e ) );

		a << *i.encoding();
	}
}

void operator<< ( ::xercesc::DOMElement& e, const Manifest& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// Reference
	//
	for ( Manifest::ReferenceConstIterator
	        b( i.reference().begin() ), n( i.reference().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "Reference", XMLNS, e ) );

		s << *b;
	}

	// Id
	//
	if ( i.id() )
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "Id", e ) );

		a << *i.id();
	}
}

void operator<< ( ::xercesc::DOMElement& e, const SignatureProperties& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// SignatureProperty
	//
	for ( SignatureProperties::SignaturePropertyConstIterator
	        b( i.signatureProperty().begin() ), n( i.signatureProperty().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "SignatureProperty", XMLNS, e ) );

		s << *b;
	}

	// Id
	//
	if ( i.id() )
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "Id", e ) );

		a << *i.id();
	}
}

void operator<< ( ::xercesc::DOMElement& e, const SignatureProperty& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// Target
	//
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "Target", e ) );

		a << i.target();
	}

	// Id
	//
	if ( i.id() )
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "Id", e ) );

		a << *i.id();
	}
}

void operator<< ( ::xercesc::DOMElement& e, const HMACOutputLength& i )
{
	e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& >( i );
}

void operator<< ( ::xercesc::DOMAttr& a, const HMACOutputLength& i )
{
	a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& >( i );
}

void operator<< ( ::xml_schema::ListStream& l, const HMACOutputLength& i )
{
	l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& >( i );
}

void operator<< ( ::xercesc::DOMElement& e, const DSAKeyValue& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// P
	//
	if ( i.p() )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "P", XMLNS, e ) );

		s << *i.p();
	}

	// Q
	//
	if ( i.q() )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "Q", XMLNS, e ) );

		s << *i.q();
	}

	// G
	//
	if ( i.g() )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "G", XMLNS, e ) );

		s << *i.g();
	}

	// Y
	//
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "Y", XMLNS, e ) );

		s << i.y();
	}

	// J
	//
	if ( i.j() )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "J", XMLNS, e ) );

		s << *i.j();
	}

	// Seed
	//
	if ( i.seed() )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "Seed", XMLNS, e ) );

		s << *i.seed();
	}

	// PgenCounter
	//
	if ( i.pgenCounter() )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "PgenCounter", XMLNS, e ) );

		s << *i.pgenCounter();
	}
}

void operator<< ( ::xercesc::DOMElement& e, const RSAKeyValue& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// Modulus
	//
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "Modulus", XMLNS, e ) );

		s << i.modulus();
	}

	// Exponent
	//
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "Exponent", XMLNS, e ) );

		s << i.exponent();
	}
}
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

