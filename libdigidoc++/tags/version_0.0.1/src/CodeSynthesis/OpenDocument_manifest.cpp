// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "OpenDocument_manifest.h"

namespace manifest
{
// Manifest
//

const Manifest::FileEntrySequence& Manifest::file_entry() const
{
	return this->file_entry_;
}

Manifest::FileEntrySequence& Manifest::file_entry()
{
	return this->file_entry_;
}

void Manifest::file_entry( const FileEntrySequence& s )
{
	this->file_entry_ = s;
}


// FileEntry
//

const FileEntry::EncryptionDataOptional& FileEntry::encryption_data() const
{
	return this->encryption_data_;
}

FileEntry::EncryptionDataOptional& FileEntry::encryption_data()
{
	return this->encryption_data_;
}

void FileEntry::encryption_data( const EncryptionDataType& x )
{
	this->encryption_data_.set( x );
}

void FileEntry::encryption_data( const EncryptionDataOptional& x )
{
	this->encryption_data_ = x;
}

void FileEntry::encryption_data( ::std::auto_ptr< EncryptionDataType > x )
{
	this->encryption_data_.set( x );
}

const FileEntry::Full_pathType& FileEntry::full_path() const
{
	return this->full_path_.get();
}

FileEntry::Full_pathType& FileEntry::full_path()
{
	return this->full_path_.get();
}

void FileEntry::full_path( const Full_pathType& x )
{
	this->full_path_.set( x );
}

void FileEntry::full_path( ::std::auto_ptr< Full_pathType > x )
{
	this->full_path_.set( x );
}

const FileEntry::SizeOptional& FileEntry::size() const
{
	return this->size_;
}

FileEntry::SizeOptional& FileEntry::size()
{
	return this->size_;
}

void FileEntry::size( const SizeType& x )
{
	this->size_.set( x );
}

void FileEntry::size( const SizeOptional& x )
{
	this->size_ = x;
}

const FileEntry::Media_typeType& FileEntry::media_type() const
{
	return this->media_type_.get();
}

FileEntry::Media_typeType& FileEntry::media_type()
{
	return this->media_type_.get();
}

void FileEntry::media_type( const Media_typeType& x )
{
	this->media_type_.set( x );
}

void FileEntry::media_type( ::std::auto_ptr< Media_typeType > x )
{
	this->media_type_.set( x );
}


// EncryptionData
//

const EncryptionData::AlgorithmType& EncryptionData::algorithm() const
{
	return this->algorithm_.get();
}

EncryptionData::AlgorithmType& EncryptionData::algorithm()
{
	return this->algorithm_.get();
}

void EncryptionData::algorithm( const AlgorithmType& x )
{
	this->algorithm_.set( x );
}

void EncryptionData::algorithm( ::std::auto_ptr< AlgorithmType > x )
{
	this->algorithm_.set( x );
}

const EncryptionData::KeyDerivationType& EncryptionData::key_derivation() const
{
	return this->key_derivation_.get();
}

EncryptionData::KeyDerivationType& EncryptionData::key_derivation()
{
	return this->key_derivation_.get();
}

void EncryptionData::key_derivation( const KeyDerivationType& x )
{
	this->key_derivation_.set( x );
}

void EncryptionData::key_derivation( ::std::auto_ptr< KeyDerivationType > x )
{
	this->key_derivation_.set( x );
}

const EncryptionData::Checksum_typeType& EncryptionData::checksum_type() const
{
	return this->checksum_type_.get();
}

EncryptionData::Checksum_typeType& EncryptionData::checksum_type()
{
	return this->checksum_type_.get();
}

void EncryptionData::checksum_type( const Checksum_typeType& x )
{
	this->checksum_type_.set( x );
}

void EncryptionData::checksum_type( ::std::auto_ptr< Checksum_typeType > x )
{
	this->checksum_type_.set( x );
}

const EncryptionData::ChecksumType& EncryptionData::checksum() const
{
	return this->checksum_.get();
}

EncryptionData::ChecksumType& EncryptionData::checksum()
{
	return this->checksum_.get();
}

void EncryptionData::checksum( const ChecksumType& x )
{
	this->checksum_.set( x );
}

void EncryptionData::checksum( ::std::auto_ptr< ChecksumType > x )
{
	this->checksum_.set( x );
}


// Algorithm
//

const Algorithm::Algorithm_nameType& Algorithm::algorithm_name() const
{
	return this->algorithm_name_.get();
}

Algorithm::Algorithm_nameType& Algorithm::algorithm_name()
{
	return this->algorithm_name_.get();
}

void Algorithm::algorithm_name( const Algorithm_nameType& x )
{
	this->algorithm_name_.set( x );
}

void Algorithm::algorithm_name( ::std::auto_ptr< Algorithm_nameType > x )
{
	this->algorithm_name_.set( x );
}

const Algorithm::Initialisation_vectorType& Algorithm::initialisation_vector() const
{
	return this->initialisation_vector_.get();
}

Algorithm::Initialisation_vectorType& Algorithm::initialisation_vector()
{
	return this->initialisation_vector_.get();
}

void Algorithm::initialisation_vector( const Initialisation_vectorType& x )
{
	this->initialisation_vector_.set( x );
}

void Algorithm::initialisation_vector( ::std::auto_ptr< Initialisation_vectorType > x )
{
	this->initialisation_vector_.set( x );
}


// KeyDerivation
//

const KeyDerivation::KeyDerivation_nameType& KeyDerivation::key_derivation_name() const
{
	return this->key_derivation_name_.get();
}

KeyDerivation::KeyDerivation_nameType& KeyDerivation::key_derivation_name()
{
	return this->key_derivation_name_.get();
}

void KeyDerivation::key_derivation_name( const KeyDerivation_nameType& x )
{
	this->key_derivation_name_.set( x );
}

void KeyDerivation::key_derivation_name( ::std::auto_ptr< KeyDerivation_nameType > x )
{
	this->key_derivation_name_.set( x );
}

const KeyDerivation::SaltType& KeyDerivation::salt() const
{
	return this->salt_.get();
}

KeyDerivation::SaltType& KeyDerivation::salt()
{
	return this->salt_.get();
}

void KeyDerivation::salt( const SaltType& x )
{
	this->salt_.set( x );
}

void KeyDerivation::salt( ::std::auto_ptr< SaltType > x )
{
	this->salt_.set( x );
}

const KeyDerivation::Iteration_countType& KeyDerivation::iteration_count() const
{
	return this->iteration_count_.get();
}

KeyDerivation::Iteration_countType& KeyDerivation::iteration_count()
{
	return this->iteration_count_.get();
}

void KeyDerivation::iteration_count( const Iteration_countType& x )
{
	this->iteration_count_.set( x );
}
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace manifest
{
// Manifest
//

Manifest::Manifest()
		: ::xml_schema::Type(), file_entry_( ::xml_schema::Flags(), this )
{
}

Manifest::Manifest( const Manifest& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), file_entry_( x.file_entry_, f, this )
{
}

Manifest::Manifest( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), file_entry_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, false );
		this->parse( p, f );
	}
}

void Manifest::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// file-entry
		//
		if ( n.name() == "file-entry" && n.namespace_() == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" )
		{
			::std::auto_ptr< FileEntryType > r( FileEntryTraits::create( i, f, this ) );

			this->file_entry_.push_back( r );
			continue;
		}

		break;
	}
}

Manifest* Manifest::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class Manifest( *this, f, c );
}

Manifest::~Manifest()
{
}

// FileEntry
//

FileEntry::FileEntry( const Full_pathType& full_path, const Media_typeType& media_type )
		: ::xml_schema::Type(), encryption_data_( ::xml_schema::Flags(), this )
		, full_path_( full_path, ::xml_schema::Flags(), this )
		, size_( ::xml_schema::Flags(), this )
		, media_type_( media_type, ::xml_schema::Flags(), this )
{
}

FileEntry::FileEntry( const FileEntry& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), encryption_data_( x.encryption_data_, f, this )
		, full_path_( x.full_path_, f, this )
		, size_( x.size_, f, this )
		, media_type_( x.media_type_, f, this )
{
}

FileEntry::FileEntry( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), encryption_data_( f, this )
		, full_path_( f, this )
		, size_( f, this )
		, media_type_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, true );
		this->parse( p, f );
	}
}

void FileEntry::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// encryption-data
		//
		if ( n.name() == "encryption-data" && n.namespace_() == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" )
		{
			::std::auto_ptr< EncryptionDataType > r( EncryptionDataTraits::create( i, f, this ) );

			if ( !this->encryption_data_ )
			{
				this->encryption_data_.set( r );
				continue;
			}
		}

		break;
	}

	while ( p.more_attributes() )
	{
		const ::xercesc::DOMAttr& i( p.next_attribute() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		if ( n.name() == "full-path" && n.namespace_() == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" )
		{
			::std::auto_ptr< Full_pathType > r( Full_pathTraits::create( i, f, this ) );

			this->full_path_.set( r );
			continue;
		}

		if ( n.name() == "size" && n.namespace_() == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" )
		{
			this->size_.set( SizeTraits::create( i, f, this ) );
			continue;
		}

		if ( n.name() == "media-type" && n.namespace_() == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" )
		{
			::std::auto_ptr< Media_typeType > r( Media_typeTraits::create( i, f, this ) );

			this->media_type_.set( r );
			continue;
		}
	}

	if ( !full_path_.present() )
	{
		throw ::xsd::cxx::tree::expected_attribute< char > ( "full-path", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" );
	}

	if ( !media_type_.present() )
	{
		throw ::xsd::cxx::tree::expected_attribute< char > ( "media-type", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" );
	}
}

FileEntry* FileEntry::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class FileEntry( *this, f, c );
}

FileEntry::~FileEntry()
{
}

// EncryptionData
//

EncryptionData::EncryptionData( const AlgorithmType& algorithm, const KeyDerivationType& key_derivation, const Checksum_typeType& checksum_type, const ChecksumType& checksum )
		: ::xml_schema::Type(), algorithm_( algorithm, ::xml_schema::Flags(), this )
		, key_derivation_( key_derivation, ::xml_schema::Flags(), this )
		, checksum_type_( checksum_type, ::xml_schema::Flags(), this )
		, checksum_( checksum, ::xml_schema::Flags(), this )
{
}

EncryptionData::EncryptionData( ::std::auto_ptr< AlgorithmType >& algorithm, ::std::auto_ptr< KeyDerivationType >& key_derivation, const Checksum_typeType& checksum_type, const ChecksumType& checksum )
		: ::xml_schema::Type(), algorithm_( algorithm, ::xml_schema::Flags(), this )
		, key_derivation_( key_derivation, ::xml_schema::Flags(), this )
		, checksum_type_( checksum_type, ::xml_schema::Flags(), this )
		, checksum_( checksum, ::xml_schema::Flags(), this )
{
}

EncryptionData::EncryptionData( const EncryptionData& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), algorithm_( x.algorithm_, f, this )
		, key_derivation_( x.key_derivation_, f, this )
		, checksum_type_( x.checksum_type_, f, this )
		, checksum_( x.checksum_, f, this )
{
}

EncryptionData::EncryptionData( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), algorithm_( f, this )
		, key_derivation_( f, this )
		, checksum_type_( f, this )
		, checksum_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, true, true );
		this->parse( p, f );
	}
}

void EncryptionData::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	for ( ; p.more_elements(); p.next_element() )
	{
		const ::xercesc::DOMElement& i( p.cur_element() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		// algorithm
		//
		if ( n.name() == "algorithm" && n.namespace_() == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" )
		{
			::std::auto_ptr< AlgorithmType > r( AlgorithmTraits::create( i, f, this ) );

			if ( !algorithm_.present() )
			{
				this->algorithm_.set( r );
				continue;
			}
		}

		// key-derivation
		//
		if ( n.name() == "key-derivation" && n.namespace_() == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" )
		{
			::std::auto_ptr< KeyDerivationType > r( KeyDerivationTraits::create( i, f, this ) );

			if ( !key_derivation_.present() )
			{
				this->key_derivation_.set( r );
				continue;
			}
		}

		break;
	}

	if ( !algorithm_.present() )
	{
		throw ::xsd::cxx::tree::expected_element< char > ( "algorithm", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" );
	}

	if ( !key_derivation_.present() )
	{
		throw ::xsd::cxx::tree::expected_element< char > ( "key-derivation", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" );
	}

	while ( p.more_attributes() )
	{
		const ::xercesc::DOMAttr& i( p.next_attribute() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		if ( n.name() == "checksum-type" && n.namespace_() == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" )
		{
			::std::auto_ptr< Checksum_typeType > r( Checksum_typeTraits::create( i, f, this ) );

			this->checksum_type_.set( r );
			continue;
		}

		if ( n.name() == "checksum" && n.namespace_() == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" )
		{
			::std::auto_ptr< ChecksumType > r( ChecksumTraits::create( i, f, this ) );

			this->checksum_.set( r );
			continue;
		}
	}

	if ( !checksum_type_.present() )
	{
		throw ::xsd::cxx::tree::expected_attribute< char > ( "checksum-type", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" );
	}

	if ( !checksum_.present() )
	{
		throw ::xsd::cxx::tree::expected_attribute< char > ( "checksum", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" );
	}
}

EncryptionData* EncryptionData::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class EncryptionData( *this, f, c );
}

EncryptionData::~EncryptionData()
{
}

// Algorithm
//

Algorithm::Algorithm( const Algorithm_nameType& algorithm_name, const Initialisation_vectorType& initialisation_vector )
		: ::xml_schema::Type(), algorithm_name_( algorithm_name, ::xml_schema::Flags(), this )
		, initialisation_vector_( initialisation_vector, ::xml_schema::Flags(), this )
{
}

Algorithm::Algorithm( const Algorithm& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), algorithm_name_( x.algorithm_name_, f, this )
		, initialisation_vector_( x.initialisation_vector_, f, this )
{
}

Algorithm::Algorithm( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), algorithm_name_( f, this )
		, initialisation_vector_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, false, true );
		this->parse( p, f );
	}
}

void Algorithm::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	while ( p.more_attributes() )
	{
		const ::xercesc::DOMAttr& i( p.next_attribute() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		if ( n.name() == "algorithm-name" && n.namespace_() == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" )
		{
			::std::auto_ptr< Algorithm_nameType > r( Algorithm_nameTraits::create( i, f, this ) );

			this->algorithm_name_.set( r );
			continue;
		}

		if ( n.name() == "initialisation-vector" && n.namespace_() == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" )
		{
			::std::auto_ptr< Initialisation_vectorType > r( Initialisation_vectorTraits::create( i, f, this ) );

			this->initialisation_vector_.set( r );
			continue;
		}
	}

	if ( !algorithm_name_.present() )
	{
		throw ::xsd::cxx::tree::expected_attribute< char > ( "algorithm-name", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" );
	}

	if ( !initialisation_vector_.present() )
	{
		throw ::xsd::cxx::tree::expected_attribute< char > ( "initialisation-vector", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" );
	}
}

Algorithm* Algorithm::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class Algorithm( *this, f, c );
}

Algorithm::~Algorithm()
{
}

// KeyDerivation
//

KeyDerivation::KeyDerivation( const KeyDerivation_nameType& key_derivation_name, const SaltType& salt, const Iteration_countType& iteration_count )
		: ::xml_schema::Type(), key_derivation_name_( key_derivation_name, ::xml_schema::Flags(), this )
		, salt_( salt, ::xml_schema::Flags(), this )
		, iteration_count_( iteration_count, ::xml_schema::Flags(), this )
{
}

KeyDerivation::KeyDerivation( const KeyDerivation& x, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( x, f, c ), key_derivation_name_( x.key_derivation_name_, f, this )
		, salt_( x.salt_, f, this )
		, iteration_count_( x.iteration_count_, f, this )
{
}

KeyDerivation::KeyDerivation( const ::xercesc::DOMElement& e, ::xml_schema::Flags f, ::xml_schema::Container* c )
		: ::xml_schema::Type( e, f | ::xml_schema::Flags::base, c ), key_derivation_name_( f, this )
		, salt_( f, this )
		, iteration_count_( f, this )
{
	if (( f & ::xml_schema::Flags::base ) == 0 )
	{
		::xsd::cxx::xml::dom::parser< char > p( e, false, true );
		this->parse( p, f );
	}
}

void KeyDerivation::parse( ::xsd::cxx::xml::dom::parser< char >& p, ::xml_schema::Flags f )
{
	while ( p.more_attributes() )
	{
		const ::xercesc::DOMAttr& i( p.next_attribute() );
		const ::xsd::cxx::xml::qualified_name< char > n( ::xsd::cxx::xml::dom::name< char > ( i ) );

		if ( n.name() == "key-derivation-name" && n.namespace_() == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" )
		{
			::std::auto_ptr< KeyDerivation_nameType > r( KeyDerivation_nameTraits::create( i, f, this ) );

			this->key_derivation_name_.set( r );
			continue;
		}

		if ( n.name() == "salt" && n.namespace_() == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" )
		{
			::std::auto_ptr< SaltType > r( SaltTraits::create( i, f, this ) );

			this->salt_.set( r );
			continue;
		}

		if ( n.name() == "iteration-count" && n.namespace_() == "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" )
		{
			this->iteration_count_.set( Iteration_countTraits::create( i, f, this ) );
			continue;
		}
	}

	if ( !key_derivation_name_.present() )
	{
		throw ::xsd::cxx::tree::expected_attribute< char > ( "key-derivation-name", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" );
	}

	if ( !salt_.present() )
	{
		throw ::xsd::cxx::tree::expected_attribute< char > ( "salt", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" );
	}

	if ( !iteration_count_.present() )
	{
		throw ::xsd::cxx::tree::expected_attribute< char > ( "iteration-count", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" );
	}
}

KeyDerivation* KeyDerivation::_clone( ::xml_schema::Flags f, ::xml_schema::Container* c ) const
{
	return new class KeyDerivation( *this, f, c );
}

KeyDerivation::~KeyDerivation()
{
}
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace manifest
{
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace manifest
{
void
operator<< ( ::xercesc::DOMElement& e, const Manifest& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// file-entry
	//
	for ( Manifest::FileEntryConstIterator
	        b( i.file_entry().begin() ), n( i.file_entry().end() );
	        b != n; ++b )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "file-entry", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", e ) );

		s << *b;
	}
}

void
operator<< ( ::xercesc::DOMElement& e, const FileEntry& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// encryption-data
	//
	if ( i.encryption_data() )
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "encryption-data", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", e ) );

		s << *i.encryption_data();
	}

	// full-path
	//
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "full-path", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", e ) );

		a << i.full_path();
	}

	// size
	//
	if ( i.size() )
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "size", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", e ) );

		a << *i.size();
	}

	// media-type
	//
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "media-type", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", e ) );

		a << i.media_type();
	}
}

void
operator<< ( ::xercesc::DOMElement& e, const EncryptionData& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// algorithm
	//
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "algorithm", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", e ) );

		s << i.algorithm();
	}

	// key-derivation
	//
	{
		::xercesc::DOMElement& s( ::xsd::cxx::xml::dom::create_element( "key-derivation", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", e ) );

		s << i.key_derivation();
	}

	// checksum-type
	//
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "checksum-type", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", e ) );

		a << i.checksum_type();
	}

	// checksum
	//
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "checksum", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", e ) );

		a << i.checksum();
	}
}

void
operator<< ( ::xercesc::DOMElement& e, const Algorithm& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// algorithm-name
	//
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "algorithm-name", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", e ) );

		a << i.algorithm_name();
	}

	// initialisation-vector
	//
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "initialisation-vector", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", e ) );

		a << i.initialisation_vector();
	}
}

void
operator<< ( ::xercesc::DOMElement& e, const KeyDerivation& i )
{
	e << static_cast< const ::xml_schema::Type& >( i );

	// key-derivation-name
	//
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "key-derivation-name", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", e ) );

		a << i.key_derivation_name();
	}

	// salt
	//
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "salt", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", e ) );

		a << i.salt();
	}

	// iteration-count
	//
	{
		::xercesc::DOMAttr& a( ::xsd::cxx::xml::dom::create_attribute( "iteration-count", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", e ) );

		a << i.iteration_count();
	}
}
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

