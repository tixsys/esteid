// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "xmldsig-core-schema.hxx"

namespace digidoc
{
  namespace dsig
  {
    // CryptoBinary
    // 


    // SignatureType
    // 

    const SignatureType::SignedInfoType& SignatureType::
    signedInfo () const
    {
      return this->SignedInfo_.get ();
    }

    SignatureType::SignedInfoType& SignatureType::
    signedInfo ()
    {
      return this->SignedInfo_.get ();
    }

    void SignatureType::
    signedInfo (const SignedInfoType& x)
    {
      this->SignedInfo_.set (x);
    }

    void SignatureType::
    signedInfo (::std::auto_ptr< SignedInfoType > x)
    {
      this->SignedInfo_.set (x);
    }

    const SignatureType::SignatureValueType& SignatureType::
    signatureValue () const
    {
      return this->SignatureValue_.get ();
    }

    SignatureType::SignatureValueType& SignatureType::
    signatureValue ()
    {
      return this->SignatureValue_.get ();
    }

    void SignatureType::
    signatureValue (const SignatureValueType& x)
    {
      this->SignatureValue_.set (x);
    }

    void SignatureType::
    signatureValue (::std::auto_ptr< SignatureValueType > x)
    {
      this->SignatureValue_.set (x);
    }

    const SignatureType::KeyInfoOptional& SignatureType::
    keyInfo () const
    {
      return this->KeyInfo_;
    }

    SignatureType::KeyInfoOptional& SignatureType::
    keyInfo ()
    {
      return this->KeyInfo_;
    }

    void SignatureType::
    keyInfo (const KeyInfoType& x)
    {
      this->KeyInfo_.set (x);
    }

    void SignatureType::
    keyInfo (const KeyInfoOptional& x)
    {
      this->KeyInfo_ = x;
    }

    void SignatureType::
    keyInfo (::std::auto_ptr< KeyInfoType > x)
    {
      this->KeyInfo_.set (x);
    }

    const SignatureType::ObjectSequence& SignatureType::
    object () const
    {
      return this->Object_;
    }

    SignatureType::ObjectSequence& SignatureType::
    object ()
    {
      return this->Object_;
    }

    void SignatureType::
    object (const ObjectSequence& s)
    {
      this->Object_ = s;
    }

    const SignatureType::IdOptional& SignatureType::
    id () const
    {
      return this->Id_;
    }

    SignatureType::IdOptional& SignatureType::
    id ()
    {
      return this->Id_;
    }

    void SignatureType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void SignatureType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void SignatureType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // SignatureValueType
    // 

    const SignatureValueType::IdOptional& SignatureValueType::
    id () const
    {
      return this->Id_;
    }

    SignatureValueType::IdOptional& SignatureValueType::
    id ()
    {
      return this->Id_;
    }

    void SignatureValueType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void SignatureValueType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void SignatureValueType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // SignedInfoType
    // 

    const SignedInfoType::CanonicalizationMethodType& SignedInfoType::
    canonicalizationMethod () const
    {
      return this->CanonicalizationMethod_.get ();
    }

    SignedInfoType::CanonicalizationMethodType& SignedInfoType::
    canonicalizationMethod ()
    {
      return this->CanonicalizationMethod_.get ();
    }

    void SignedInfoType::
    canonicalizationMethod (const CanonicalizationMethodType& x)
    {
      this->CanonicalizationMethod_.set (x);
    }

    void SignedInfoType::
    canonicalizationMethod (::std::auto_ptr< CanonicalizationMethodType > x)
    {
      this->CanonicalizationMethod_.set (x);
    }

    const SignedInfoType::SignatureMethodType& SignedInfoType::
    signatureMethod () const
    {
      return this->SignatureMethod_.get ();
    }

    SignedInfoType::SignatureMethodType& SignedInfoType::
    signatureMethod ()
    {
      return this->SignatureMethod_.get ();
    }

    void SignedInfoType::
    signatureMethod (const SignatureMethodType& x)
    {
      this->SignatureMethod_.set (x);
    }

    void SignedInfoType::
    signatureMethod (::std::auto_ptr< SignatureMethodType > x)
    {
      this->SignatureMethod_.set (x);
    }

    const SignedInfoType::ReferenceSequence& SignedInfoType::
    reference () const
    {
      return this->Reference_;
    }

    SignedInfoType::ReferenceSequence& SignedInfoType::
    reference ()
    {
      return this->Reference_;
    }

    void SignedInfoType::
    reference (const ReferenceSequence& s)
    {
      this->Reference_ = s;
    }

    const SignedInfoType::IdOptional& SignedInfoType::
    id () const
    {
      return this->Id_;
    }

    SignedInfoType::IdOptional& SignedInfoType::
    id ()
    {
      return this->Id_;
    }

    void SignedInfoType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void SignedInfoType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void SignedInfoType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // CanonicalizationMethodType
    // 

    const CanonicalizationMethodType::AlgorithmType& CanonicalizationMethodType::
    algorithm () const
    {
      return this->Algorithm_.get ();
    }

    CanonicalizationMethodType::AlgorithmType& CanonicalizationMethodType::
    algorithm ()
    {
      return this->Algorithm_.get ();
    }

    void CanonicalizationMethodType::
    algorithm (const AlgorithmType& x)
    {
      this->Algorithm_.set (x);
    }

    void CanonicalizationMethodType::
    algorithm (::std::auto_ptr< AlgorithmType > x)
    {
      this->Algorithm_.set (x);
    }


    // SignatureMethodType
    // 

    const SignatureMethodType::HMACOutputLengthOptional& SignatureMethodType::
    hMACOutputLength () const
    {
      return this->HMACOutputLength_;
    }

    SignatureMethodType::HMACOutputLengthOptional& SignatureMethodType::
    hMACOutputLength ()
    {
      return this->HMACOutputLength_;
    }

    void SignatureMethodType::
    hMACOutputLength (const HMACOutputLengthType& x)
    {
      this->HMACOutputLength_.set (x);
    }

    void SignatureMethodType::
    hMACOutputLength (const HMACOutputLengthOptional& x)
    {
      this->HMACOutputLength_ = x;
    }

    void SignatureMethodType::
    hMACOutputLength (::std::auto_ptr< HMACOutputLengthType > x)
    {
      this->HMACOutputLength_.set (x);
    }

    const SignatureMethodType::AlgorithmType& SignatureMethodType::
    algorithm () const
    {
      return this->Algorithm_.get ();
    }

    SignatureMethodType::AlgorithmType& SignatureMethodType::
    algorithm ()
    {
      return this->Algorithm_.get ();
    }

    void SignatureMethodType::
    algorithm (const AlgorithmType& x)
    {
      this->Algorithm_.set (x);
    }

    void SignatureMethodType::
    algorithm (::std::auto_ptr< AlgorithmType > x)
    {
      this->Algorithm_.set (x);
    }


    // ReferenceType
    // 

    const ReferenceType::TransformsOptional& ReferenceType::
    transforms () const
    {
      return this->Transforms_;
    }

    ReferenceType::TransformsOptional& ReferenceType::
    transforms ()
    {
      return this->Transforms_;
    }

    void ReferenceType::
    transforms (const TransformsType& x)
    {
      this->Transforms_.set (x);
    }

    void ReferenceType::
    transforms (const TransformsOptional& x)
    {
      this->Transforms_ = x;
    }

    void ReferenceType::
    transforms (::std::auto_ptr< TransformsType > x)
    {
      this->Transforms_.set (x);
    }

    const ReferenceType::DigestMethodType& ReferenceType::
    digestMethod () const
    {
      return this->DigestMethod_.get ();
    }

    ReferenceType::DigestMethodType& ReferenceType::
    digestMethod ()
    {
      return this->DigestMethod_.get ();
    }

    void ReferenceType::
    digestMethod (const DigestMethodType& x)
    {
      this->DigestMethod_.set (x);
    }

    void ReferenceType::
    digestMethod (::std::auto_ptr< DigestMethodType > x)
    {
      this->DigestMethod_.set (x);
    }

    const ReferenceType::DigestValueType& ReferenceType::
    digestValue () const
    {
      return this->DigestValue_.get ();
    }

    ReferenceType::DigestValueType& ReferenceType::
    digestValue ()
    {
      return this->DigestValue_.get ();
    }

    void ReferenceType::
    digestValue (const DigestValueType& x)
    {
      this->DigestValue_.set (x);
    }

    void ReferenceType::
    digestValue (::std::auto_ptr< DigestValueType > x)
    {
      this->DigestValue_.set (x);
    }

    const ReferenceType::IdOptional& ReferenceType::
    id () const
    {
      return this->Id_;
    }

    ReferenceType::IdOptional& ReferenceType::
    id ()
    {
      return this->Id_;
    }

    void ReferenceType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void ReferenceType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void ReferenceType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }

    const ReferenceType::URIOptional& ReferenceType::
    uRI () const
    {
      return this->URI_;
    }

    ReferenceType::URIOptional& ReferenceType::
    uRI ()
    {
      return this->URI_;
    }

    void ReferenceType::
    uRI (const URIType& x)
    {
      this->URI_.set (x);
    }

    void ReferenceType::
    uRI (const URIOptional& x)
    {
      this->URI_ = x;
    }

    void ReferenceType::
    uRI (::std::auto_ptr< URIType > x)
    {
      this->URI_.set (x);
    }

    const ReferenceType::TypeOptional& ReferenceType::
    type () const
    {
      return this->Type_;
    }

    ReferenceType::TypeOptional& ReferenceType::
    type ()
    {
      return this->Type_;
    }

    void ReferenceType::
    type (const TypeType& x)
    {
      this->Type_.set (x);
    }

    void ReferenceType::
    type (const TypeOptional& x)
    {
      this->Type_ = x;
    }

    void ReferenceType::
    type (::std::auto_ptr< TypeType > x)
    {
      this->Type_.set (x);
    }


    // TransformsType
    // 

    const TransformsType::TransformSequence& TransformsType::
    transform () const
    {
      return this->Transform_;
    }

    TransformsType::TransformSequence& TransformsType::
    transform ()
    {
      return this->Transform_;
    }

    void TransformsType::
    transform (const TransformSequence& s)
    {
      this->Transform_ = s;
    }


    // TransformType
    // 

    const TransformType::XPathSequence& TransformType::
    xPath () const
    {
      return this->XPath_;
    }

    TransformType::XPathSequence& TransformType::
    xPath ()
    {
      return this->XPath_;
    }

    void TransformType::
    xPath (const XPathSequence& s)
    {
      this->XPath_ = s;
    }

    const TransformType::AlgorithmType& TransformType::
    algorithm () const
    {
      return this->Algorithm_.get ();
    }

    TransformType::AlgorithmType& TransformType::
    algorithm ()
    {
      return this->Algorithm_.get ();
    }

    void TransformType::
    algorithm (const AlgorithmType& x)
    {
      this->Algorithm_.set (x);
    }

    void TransformType::
    algorithm (::std::auto_ptr< AlgorithmType > x)
    {
      this->Algorithm_.set (x);
    }


    // DigestMethodType
    // 

    const DigestMethodType::AlgorithmType& DigestMethodType::
    algorithm () const
    {
      return this->Algorithm_.get ();
    }

    DigestMethodType::AlgorithmType& DigestMethodType::
    algorithm ()
    {
      return this->Algorithm_.get ();
    }

    void DigestMethodType::
    algorithm (const AlgorithmType& x)
    {
      this->Algorithm_.set (x);
    }

    void DigestMethodType::
    algorithm (::std::auto_ptr< AlgorithmType > x)
    {
      this->Algorithm_.set (x);
    }


    // DigestValueType
    // 


    // KeyInfoType
    // 

    const KeyInfoType::KeyNameSequence& KeyInfoType::
    keyName () const
    {
      return this->KeyName_;
    }

    KeyInfoType::KeyNameSequence& KeyInfoType::
    keyName ()
    {
      return this->KeyName_;
    }

    void KeyInfoType::
    keyName (const KeyNameSequence& s)
    {
      this->KeyName_ = s;
    }

    const KeyInfoType::KeyValueSequence& KeyInfoType::
    keyValue () const
    {
      return this->KeyValue_;
    }

    KeyInfoType::KeyValueSequence& KeyInfoType::
    keyValue ()
    {
      return this->KeyValue_;
    }

    void KeyInfoType::
    keyValue (const KeyValueSequence& s)
    {
      this->KeyValue_ = s;
    }

    const KeyInfoType::RetrievalMethodSequence& KeyInfoType::
    retrievalMethod () const
    {
      return this->RetrievalMethod_;
    }

    KeyInfoType::RetrievalMethodSequence& KeyInfoType::
    retrievalMethod ()
    {
      return this->RetrievalMethod_;
    }

    void KeyInfoType::
    retrievalMethod (const RetrievalMethodSequence& s)
    {
      this->RetrievalMethod_ = s;
    }

    const KeyInfoType::X509DataSequence& KeyInfoType::
    x509Data () const
    {
      return this->X509Data_;
    }

    KeyInfoType::X509DataSequence& KeyInfoType::
    x509Data ()
    {
      return this->X509Data_;
    }

    void KeyInfoType::
    x509Data (const X509DataSequence& s)
    {
      this->X509Data_ = s;
    }

    const KeyInfoType::PGPDataSequence& KeyInfoType::
    pGPData () const
    {
      return this->PGPData_;
    }

    KeyInfoType::PGPDataSequence& KeyInfoType::
    pGPData ()
    {
      return this->PGPData_;
    }

    void KeyInfoType::
    pGPData (const PGPDataSequence& s)
    {
      this->PGPData_ = s;
    }

    const KeyInfoType::SPKIDataSequence& KeyInfoType::
    sPKIData () const
    {
      return this->SPKIData_;
    }

    KeyInfoType::SPKIDataSequence& KeyInfoType::
    sPKIData ()
    {
      return this->SPKIData_;
    }

    void KeyInfoType::
    sPKIData (const SPKIDataSequence& s)
    {
      this->SPKIData_ = s;
    }

    const KeyInfoType::MgmtDataSequence& KeyInfoType::
    mgmtData () const
    {
      return this->MgmtData_;
    }

    KeyInfoType::MgmtDataSequence& KeyInfoType::
    mgmtData ()
    {
      return this->MgmtData_;
    }

    void KeyInfoType::
    mgmtData (const MgmtDataSequence& s)
    {
      this->MgmtData_ = s;
    }

    const KeyInfoType::IdOptional& KeyInfoType::
    id () const
    {
      return this->Id_;
    }

    KeyInfoType::IdOptional& KeyInfoType::
    id ()
    {
      return this->Id_;
    }

    void KeyInfoType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void KeyInfoType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void KeyInfoType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // KeyValueType
    // 

    const KeyValueType::DSAKeyValueOptional& KeyValueType::
    dSAKeyValue () const
    {
      return this->DSAKeyValue_;
    }

    KeyValueType::DSAKeyValueOptional& KeyValueType::
    dSAKeyValue ()
    {
      return this->DSAKeyValue_;
    }

    void KeyValueType::
    dSAKeyValue (const DSAKeyValueType& x)
    {
      this->DSAKeyValue_.set (x);
    }

    void KeyValueType::
    dSAKeyValue (const DSAKeyValueOptional& x)
    {
      this->DSAKeyValue_ = x;
    }

    void KeyValueType::
    dSAKeyValue (::std::auto_ptr< DSAKeyValueType > x)
    {
      this->DSAKeyValue_.set (x);
    }

    const KeyValueType::RSAKeyValueOptional& KeyValueType::
    rSAKeyValue () const
    {
      return this->RSAKeyValue_;
    }

    KeyValueType::RSAKeyValueOptional& KeyValueType::
    rSAKeyValue ()
    {
      return this->RSAKeyValue_;
    }

    void KeyValueType::
    rSAKeyValue (const RSAKeyValueType& x)
    {
      this->RSAKeyValue_.set (x);
    }

    void KeyValueType::
    rSAKeyValue (const RSAKeyValueOptional& x)
    {
      this->RSAKeyValue_ = x;
    }

    void KeyValueType::
    rSAKeyValue (::std::auto_ptr< RSAKeyValueType > x)
    {
      this->RSAKeyValue_.set (x);
    }


    // RetrievalMethodType
    // 

    const RetrievalMethodType::TransformsOptional& RetrievalMethodType::
    transforms () const
    {
      return this->Transforms_;
    }

    RetrievalMethodType::TransformsOptional& RetrievalMethodType::
    transforms ()
    {
      return this->Transforms_;
    }

    void RetrievalMethodType::
    transforms (const TransformsType& x)
    {
      this->Transforms_.set (x);
    }

    void RetrievalMethodType::
    transforms (const TransformsOptional& x)
    {
      this->Transforms_ = x;
    }

    void RetrievalMethodType::
    transforms (::std::auto_ptr< TransformsType > x)
    {
      this->Transforms_.set (x);
    }

    const RetrievalMethodType::URIOptional& RetrievalMethodType::
    uRI () const
    {
      return this->URI_;
    }

    RetrievalMethodType::URIOptional& RetrievalMethodType::
    uRI ()
    {
      return this->URI_;
    }

    void RetrievalMethodType::
    uRI (const URIType& x)
    {
      this->URI_.set (x);
    }

    void RetrievalMethodType::
    uRI (const URIOptional& x)
    {
      this->URI_ = x;
    }

    void RetrievalMethodType::
    uRI (::std::auto_ptr< URIType > x)
    {
      this->URI_.set (x);
    }

    const RetrievalMethodType::TypeOptional& RetrievalMethodType::
    type () const
    {
      return this->Type_;
    }

    RetrievalMethodType::TypeOptional& RetrievalMethodType::
    type ()
    {
      return this->Type_;
    }

    void RetrievalMethodType::
    type (const TypeType& x)
    {
      this->Type_.set (x);
    }

    void RetrievalMethodType::
    type (const TypeOptional& x)
    {
      this->Type_ = x;
    }

    void RetrievalMethodType::
    type (::std::auto_ptr< TypeType > x)
    {
      this->Type_.set (x);
    }


    // X509DataType
    // 

    const X509DataType::X509IssuerSerialSequence& X509DataType::
    x509IssuerSerial () const
    {
      return this->X509IssuerSerial_;
    }

    X509DataType::X509IssuerSerialSequence& X509DataType::
    x509IssuerSerial ()
    {
      return this->X509IssuerSerial_;
    }

    void X509DataType::
    x509IssuerSerial (const X509IssuerSerialSequence& s)
    {
      this->X509IssuerSerial_ = s;
    }

    const X509DataType::X509SKISequence& X509DataType::
    x509SKI () const
    {
      return this->X509SKI_;
    }

    X509DataType::X509SKISequence& X509DataType::
    x509SKI ()
    {
      return this->X509SKI_;
    }

    void X509DataType::
    x509SKI (const X509SKISequence& s)
    {
      this->X509SKI_ = s;
    }

    const X509DataType::X509SubjectNameSequence& X509DataType::
    x509SubjectName () const
    {
      return this->X509SubjectName_;
    }

    X509DataType::X509SubjectNameSequence& X509DataType::
    x509SubjectName ()
    {
      return this->X509SubjectName_;
    }

    void X509DataType::
    x509SubjectName (const X509SubjectNameSequence& s)
    {
      this->X509SubjectName_ = s;
    }

    const X509DataType::X509CertificateSequence& X509DataType::
    x509Certificate () const
    {
      return this->X509Certificate_;
    }

    X509DataType::X509CertificateSequence& X509DataType::
    x509Certificate ()
    {
      return this->X509Certificate_;
    }

    void X509DataType::
    x509Certificate (const X509CertificateSequence& s)
    {
      this->X509Certificate_ = s;
    }

    const X509DataType::X509CRLSequence& X509DataType::
    x509CRL () const
    {
      return this->X509CRL_;
    }

    X509DataType::X509CRLSequence& X509DataType::
    x509CRL ()
    {
      return this->X509CRL_;
    }

    void X509DataType::
    x509CRL (const X509CRLSequence& s)
    {
      this->X509CRL_ = s;
    }


    // X509IssuerSerialType
    // 

    const X509IssuerSerialType::X509IssuerNameType& X509IssuerSerialType::
    x509IssuerName () const
    {
      return this->X509IssuerName_.get ();
    }

    X509IssuerSerialType::X509IssuerNameType& X509IssuerSerialType::
    x509IssuerName ()
    {
      return this->X509IssuerName_.get ();
    }

    void X509IssuerSerialType::
    x509IssuerName (const X509IssuerNameType& x)
    {
      this->X509IssuerName_.set (x);
    }

    void X509IssuerSerialType::
    x509IssuerName (::std::auto_ptr< X509IssuerNameType > x)
    {
      this->X509IssuerName_.set (x);
    }

    const X509IssuerSerialType::X509SerialNumberType& X509IssuerSerialType::
    x509SerialNumber () const
    {
      return this->X509SerialNumber_.get ();
    }

    X509IssuerSerialType::X509SerialNumberType& X509IssuerSerialType::
    x509SerialNumber ()
    {
      return this->X509SerialNumber_.get ();
    }

    void X509IssuerSerialType::
    x509SerialNumber (const X509SerialNumberType& x)
    {
      this->X509SerialNumber_.set (x);
    }


    // PGPDataType
    // 

    const PGPDataType::PGPKeyIDOptional& PGPDataType::
    pGPKeyID () const
    {
      return this->PGPKeyID_;
    }

    PGPDataType::PGPKeyIDOptional& PGPDataType::
    pGPKeyID ()
    {
      return this->PGPKeyID_;
    }

    void PGPDataType::
    pGPKeyID (const PGPKeyIDType& x)
    {
      this->PGPKeyID_.set (x);
    }

    void PGPDataType::
    pGPKeyID (const PGPKeyIDOptional& x)
    {
      this->PGPKeyID_ = x;
    }

    void PGPDataType::
    pGPKeyID (::std::auto_ptr< PGPKeyIDType > x)
    {
      this->PGPKeyID_.set (x);
    }

    const PGPDataType::PGPKeyPacketOptional& PGPDataType::
    pGPKeyPacket () const
    {
      return this->PGPKeyPacket_;
    }

    PGPDataType::PGPKeyPacketOptional& PGPDataType::
    pGPKeyPacket ()
    {
      return this->PGPKeyPacket_;
    }

    void PGPDataType::
    pGPKeyPacket (const PGPKeyPacketType& x)
    {
      this->PGPKeyPacket_.set (x);
    }

    void PGPDataType::
    pGPKeyPacket (const PGPKeyPacketOptional& x)
    {
      this->PGPKeyPacket_ = x;
    }

    void PGPDataType::
    pGPKeyPacket (::std::auto_ptr< PGPKeyPacketType > x)
    {
      this->PGPKeyPacket_.set (x);
    }


    // SPKIDataType
    // 

    const SPKIDataType::SPKISexpSequence& SPKIDataType::
    sPKISexp () const
    {
      return this->SPKISexp_;
    }

    SPKIDataType::SPKISexpSequence& SPKIDataType::
    sPKISexp ()
    {
      return this->SPKISexp_;
    }

    void SPKIDataType::
    sPKISexp (const SPKISexpSequence& s)
    {
      this->SPKISexp_ = s;
    }


    // ObjectType
    // 

    const ObjectType::QualifyingPropertiesSequence& ObjectType::
    qualifyingProperties () const
    {
      return this->QualifyingProperties_;
    }

    ObjectType::QualifyingPropertiesSequence& ObjectType::
    qualifyingProperties ()
    {
      return this->QualifyingProperties_;
    }

    void ObjectType::
    qualifyingProperties (const QualifyingPropertiesSequence& s)
    {
      this->QualifyingProperties_ = s;
    }

    const ObjectType::IdOptional& ObjectType::
    id () const
    {
      return this->Id_;
    }

    ObjectType::IdOptional& ObjectType::
    id ()
    {
      return this->Id_;
    }

    void ObjectType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void ObjectType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void ObjectType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }

    const ObjectType::MimeTypeOptional& ObjectType::
    mimeType () const
    {
      return this->MimeType_;
    }

    ObjectType::MimeTypeOptional& ObjectType::
    mimeType ()
    {
      return this->MimeType_;
    }

    void ObjectType::
    mimeType (const MimeTypeType& x)
    {
      this->MimeType_.set (x);
    }

    void ObjectType::
    mimeType (const MimeTypeOptional& x)
    {
      this->MimeType_ = x;
    }

    void ObjectType::
    mimeType (::std::auto_ptr< MimeTypeType > x)
    {
      this->MimeType_.set (x);
    }

    const ObjectType::EncodingOptional& ObjectType::
    encoding () const
    {
      return this->Encoding_;
    }

    ObjectType::EncodingOptional& ObjectType::
    encoding ()
    {
      return this->Encoding_;
    }

    void ObjectType::
    encoding (const EncodingType& x)
    {
      this->Encoding_.set (x);
    }

    void ObjectType::
    encoding (const EncodingOptional& x)
    {
      this->Encoding_ = x;
    }

    void ObjectType::
    encoding (::std::auto_ptr< EncodingType > x)
    {
      this->Encoding_.set (x);
    }


    // ManifestType
    // 

    const ManifestType::ReferenceSequence& ManifestType::
    reference () const
    {
      return this->Reference_;
    }

    ManifestType::ReferenceSequence& ManifestType::
    reference ()
    {
      return this->Reference_;
    }

    void ManifestType::
    reference (const ReferenceSequence& s)
    {
      this->Reference_ = s;
    }

    const ManifestType::IdOptional& ManifestType::
    id () const
    {
      return this->Id_;
    }

    ManifestType::IdOptional& ManifestType::
    id ()
    {
      return this->Id_;
    }

    void ManifestType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void ManifestType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void ManifestType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // SignaturePropertiesType
    // 

    const SignaturePropertiesType::SignaturePropertySequence& SignaturePropertiesType::
    signatureProperty () const
    {
      return this->SignatureProperty_;
    }

    SignaturePropertiesType::SignaturePropertySequence& SignaturePropertiesType::
    signatureProperty ()
    {
      return this->SignatureProperty_;
    }

    void SignaturePropertiesType::
    signatureProperty (const SignaturePropertySequence& s)
    {
      this->SignatureProperty_ = s;
    }

    const SignaturePropertiesType::IdOptional& SignaturePropertiesType::
    id () const
    {
      return this->Id_;
    }

    SignaturePropertiesType::IdOptional& SignaturePropertiesType::
    id ()
    {
      return this->Id_;
    }

    void SignaturePropertiesType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void SignaturePropertiesType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void SignaturePropertiesType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // SignaturePropertyType
    // 

    const SignaturePropertyType::TargetType& SignaturePropertyType::
    target () const
    {
      return this->Target_.get ();
    }

    SignaturePropertyType::TargetType& SignaturePropertyType::
    target ()
    {
      return this->Target_.get ();
    }

    void SignaturePropertyType::
    target (const TargetType& x)
    {
      this->Target_.set (x);
    }

    void SignaturePropertyType::
    target (::std::auto_ptr< TargetType > x)
    {
      this->Target_.set (x);
    }

    const SignaturePropertyType::IdOptional& SignaturePropertyType::
    id () const
    {
      return this->Id_;
    }

    SignaturePropertyType::IdOptional& SignaturePropertyType::
    id ()
    {
      return this->Id_;
    }

    void SignaturePropertyType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void SignaturePropertyType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void SignaturePropertyType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // HMACOutputLengthType
    // 


    // DSAKeyValueType
    // 

    const DSAKeyValueType::POptional& DSAKeyValueType::
    p () const
    {
      return this->P_;
    }

    DSAKeyValueType::POptional& DSAKeyValueType::
    p ()
    {
      return this->P_;
    }

    void DSAKeyValueType::
    p (const PType& x)
    {
      this->P_.set (x);
    }

    void DSAKeyValueType::
    p (const POptional& x)
    {
      this->P_ = x;
    }

    void DSAKeyValueType::
    p (::std::auto_ptr< PType > x)
    {
      this->P_.set (x);
    }

    const DSAKeyValueType::QOptional& DSAKeyValueType::
    q () const
    {
      return this->Q_;
    }

    DSAKeyValueType::QOptional& DSAKeyValueType::
    q ()
    {
      return this->Q_;
    }

    void DSAKeyValueType::
    q (const QType& x)
    {
      this->Q_.set (x);
    }

    void DSAKeyValueType::
    q (const QOptional& x)
    {
      this->Q_ = x;
    }

    void DSAKeyValueType::
    q (::std::auto_ptr< QType > x)
    {
      this->Q_.set (x);
    }

    const DSAKeyValueType::GOptional& DSAKeyValueType::
    g () const
    {
      return this->G_;
    }

    DSAKeyValueType::GOptional& DSAKeyValueType::
    g ()
    {
      return this->G_;
    }

    void DSAKeyValueType::
    g (const GType& x)
    {
      this->G_.set (x);
    }

    void DSAKeyValueType::
    g (const GOptional& x)
    {
      this->G_ = x;
    }

    void DSAKeyValueType::
    g (::std::auto_ptr< GType > x)
    {
      this->G_.set (x);
    }

    const DSAKeyValueType::YType& DSAKeyValueType::
    y () const
    {
      return this->Y_.get ();
    }

    DSAKeyValueType::YType& DSAKeyValueType::
    y ()
    {
      return this->Y_.get ();
    }

    void DSAKeyValueType::
    y (const YType& x)
    {
      this->Y_.set (x);
    }

    void DSAKeyValueType::
    y (::std::auto_ptr< YType > x)
    {
      this->Y_.set (x);
    }

    const DSAKeyValueType::JOptional& DSAKeyValueType::
    j () const
    {
      return this->J_;
    }

    DSAKeyValueType::JOptional& DSAKeyValueType::
    j ()
    {
      return this->J_;
    }

    void DSAKeyValueType::
    j (const JType& x)
    {
      this->J_.set (x);
    }

    void DSAKeyValueType::
    j (const JOptional& x)
    {
      this->J_ = x;
    }

    void DSAKeyValueType::
    j (::std::auto_ptr< JType > x)
    {
      this->J_.set (x);
    }

    const DSAKeyValueType::SeedOptional& DSAKeyValueType::
    seed () const
    {
      return this->Seed_;
    }

    DSAKeyValueType::SeedOptional& DSAKeyValueType::
    seed ()
    {
      return this->Seed_;
    }

    void DSAKeyValueType::
    seed (const SeedType& x)
    {
      this->Seed_.set (x);
    }

    void DSAKeyValueType::
    seed (const SeedOptional& x)
    {
      this->Seed_ = x;
    }

    void DSAKeyValueType::
    seed (::std::auto_ptr< SeedType > x)
    {
      this->Seed_.set (x);
    }

    const DSAKeyValueType::PgenCounterOptional& DSAKeyValueType::
    pgenCounter () const
    {
      return this->PgenCounter_;
    }

    DSAKeyValueType::PgenCounterOptional& DSAKeyValueType::
    pgenCounter ()
    {
      return this->PgenCounter_;
    }

    void DSAKeyValueType::
    pgenCounter (const PgenCounterType& x)
    {
      this->PgenCounter_.set (x);
    }

    void DSAKeyValueType::
    pgenCounter (const PgenCounterOptional& x)
    {
      this->PgenCounter_ = x;
    }

    void DSAKeyValueType::
    pgenCounter (::std::auto_ptr< PgenCounterType > x)
    {
      this->PgenCounter_.set (x);
    }


    // RSAKeyValueType
    // 

    const RSAKeyValueType::ModulusType& RSAKeyValueType::
    modulus () const
    {
      return this->Modulus_.get ();
    }

    RSAKeyValueType::ModulusType& RSAKeyValueType::
    modulus ()
    {
      return this->Modulus_.get ();
    }

    void RSAKeyValueType::
    modulus (const ModulusType& x)
    {
      this->Modulus_.set (x);
    }

    void RSAKeyValueType::
    modulus (::std::auto_ptr< ModulusType > x)
    {
      this->Modulus_.set (x);
    }

    const RSAKeyValueType::ExponentType& RSAKeyValueType::
    exponent () const
    {
      return this->Exponent_.get ();
    }

    RSAKeyValueType::ExponentType& RSAKeyValueType::
    exponent ()
    {
      return this->Exponent_.get ();
    }

    void RSAKeyValueType::
    exponent (const ExponentType& x)
    {
      this->Exponent_.set (x);
    }

    void RSAKeyValueType::
    exponent (::std::auto_ptr< ExponentType > x)
    {
      this->Exponent_.set (x);
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace digidoc
{
  namespace dsig
  {
    // CryptoBinary
    //

    CryptoBinary::
    CryptoBinary ()
    : ::xml_schema::Base64Binary ()
    {
    }

    CryptoBinary::
    CryptoBinary (const ::xml_schema::Base64Binary& _xsd_Base64Binary_base)
    : ::xml_schema::Base64Binary (_xsd_Base64Binary_base)
    {
    }

    CryptoBinary::
    CryptoBinary (const CryptoBinary& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Base64Binary (x, f, c)
    {
    }

    CryptoBinary::
    CryptoBinary (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Base64Binary (e, f, c)
    {
    }

    CryptoBinary::
    CryptoBinary (const xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Base64Binary (a, f, c)
    {
    }

    CryptoBinary::
    CryptoBinary (const ::std::string& s,
                  const xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Base64Binary (s, e, f, c)
    {
    }

    CryptoBinary* CryptoBinary::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CryptoBinary (*this, f, c);
    }

    CryptoBinary::
    ~CryptoBinary ()
    {
    }

    // SignatureType
    //

    SignatureType::
    SignatureType (const SignedInfoType& SignedInfo,
                   const SignatureValueType& SignatureValue)
    : ::xml_schema::Type (),
      SignedInfo_ (SignedInfo, ::xml_schema::Flags (), this),
      SignatureValue_ (SignatureValue, ::xml_schema::Flags (), this),
      KeyInfo_ (::xml_schema::Flags (), this),
      Object_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    SignatureType::
    SignatureType (::std::auto_ptr< SignedInfoType >& SignedInfo,
                   ::std::auto_ptr< SignatureValueType >& SignatureValue)
    : ::xml_schema::Type (),
      SignedInfo_ (SignedInfo, ::xml_schema::Flags (), this),
      SignatureValue_ (SignatureValue, ::xml_schema::Flags (), this),
      KeyInfo_ (::xml_schema::Flags (), this),
      Object_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    SignatureType::
    SignatureType (const SignatureType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      SignedInfo_ (x.SignedInfo_, f, this),
      SignatureValue_ (x.SignatureValue_, f, this),
      KeyInfo_ (x.KeyInfo_, f, this),
      Object_ (x.Object_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    SignatureType::
    SignatureType (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      SignedInfo_ (f, this),
      SignatureValue_ (f, this),
      KeyInfo_ (f, this),
      Object_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SignatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SignedInfo
        //
        if (n.name () == "SignedInfo" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< SignedInfoType > r (
            SignedInfoTraits::create (i, f, this));

          if (!SignedInfo_.present ())
          {
            this->SignedInfo_.set (r);
            continue;
          }
        }

        // SignatureValue
        //
        if (n.name () == "SignatureValue" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< SignatureValueType > r (
            SignatureValueTraits::create (i, f, this));

          if (!SignatureValue_.present ())
          {
            this->SignatureValue_.set (r);
            continue;
          }
        }

        // KeyInfo
        //
        if (n.name () == "KeyInfo" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< KeyInfoType > r (
            KeyInfoTraits::create (i, f, this));

          if (!this->KeyInfo_)
          {
            this->KeyInfo_.set (r);
            continue;
          }
        }

        // Object
        //
        if (n.name () == "Object" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< ObjectType > r (
            ObjectTraits::create (i, f, this));

          this->Object_.push_back (r);
          continue;
        }

        break;
      }

      if (!SignedInfo_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SignedInfo",
          "http://www.w3.org/2000/09/xmldsig#");
      }

      if (!SignatureValue_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SignatureValue",
          "http://www.w3.org/2000/09/xmldsig#");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    SignatureType* SignatureType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SignatureType (*this, f, c);
    }

    SignatureType::
    ~SignatureType ()
    {
    }

    // SignatureValueType
    //

    SignatureValueType::
    SignatureValueType ()
    : ::xml_schema::Base64Binary (),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    SignatureValueType::
    SignatureValueType (const ::xml_schema::Base64Binary& _xsd_Base64Binary_base)
    : ::xml_schema::Base64Binary (_xsd_Base64Binary_base),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    SignatureValueType::
    SignatureValueType (const SignatureValueType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Base64Binary (x, f, c),
      Id_ (x.Id_, f, this)
    {
    }

    SignatureValueType::
    SignatureValueType (const xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Base64Binary (e, f | ::xml_schema::Flags::base, c),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void SignatureValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    SignatureValueType* SignatureValueType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SignatureValueType (*this, f, c);
    }

    SignatureValueType::
    ~SignatureValueType ()
    {
    }

    // SignedInfoType
    //

    SignedInfoType::
    SignedInfoType (const CanonicalizationMethodType& CanonicalizationMethod,
                    const SignatureMethodType& SignatureMethod)
    : ::xml_schema::Type (),
      CanonicalizationMethod_ (CanonicalizationMethod, ::xml_schema::Flags (), this),
      SignatureMethod_ (SignatureMethod, ::xml_schema::Flags (), this),
      Reference_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    SignedInfoType::
    SignedInfoType (::std::auto_ptr< CanonicalizationMethodType >& CanonicalizationMethod,
                    ::std::auto_ptr< SignatureMethodType >& SignatureMethod)
    : ::xml_schema::Type (),
      CanonicalizationMethod_ (CanonicalizationMethod, ::xml_schema::Flags (), this),
      SignatureMethod_ (SignatureMethod, ::xml_schema::Flags (), this),
      Reference_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    SignedInfoType::
    SignedInfoType (const SignedInfoType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      CanonicalizationMethod_ (x.CanonicalizationMethod_, f, this),
      SignatureMethod_ (x.SignatureMethod_, f, this),
      Reference_ (x.Reference_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    SignedInfoType::
    SignedInfoType (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      CanonicalizationMethod_ (f, this),
      SignatureMethod_ (f, this),
      Reference_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SignedInfoType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CanonicalizationMethod
        //
        if (n.name () == "CanonicalizationMethod" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< CanonicalizationMethodType > r (
            CanonicalizationMethodTraits::create (i, f, this));

          if (!CanonicalizationMethod_.present ())
          {
            this->CanonicalizationMethod_.set (r);
            continue;
          }
        }

        // SignatureMethod
        //
        if (n.name () == "SignatureMethod" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< SignatureMethodType > r (
            SignatureMethodTraits::create (i, f, this));

          if (!SignatureMethod_.present ())
          {
            this->SignatureMethod_.set (r);
            continue;
          }
        }

        // Reference
        //
        if (n.name () == "Reference" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< ReferenceType > r (
            ReferenceTraits::create (i, f, this));

          this->Reference_.push_back (r);
          continue;
        }

        break;
      }

      if (!CanonicalizationMethod_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CanonicalizationMethod",
          "http://www.w3.org/2000/09/xmldsig#");
      }

      if (!SignatureMethod_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SignatureMethod",
          "http://www.w3.org/2000/09/xmldsig#");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    SignedInfoType* SignedInfoType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SignedInfoType (*this, f, c);
    }

    SignedInfoType::
    ~SignedInfoType ()
    {
    }

    // CanonicalizationMethodType
    //

    CanonicalizationMethodType::
    CanonicalizationMethodType (const AlgorithmType& Algorithm)
    : ::xml_schema::Type (),
      Algorithm_ (Algorithm, ::xml_schema::Flags (), this)
    {
    }

    CanonicalizationMethodType::
    CanonicalizationMethodType (const CanonicalizationMethodType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Algorithm_ (x.Algorithm_, f, this)
    {
    }

    CanonicalizationMethodType::
    CanonicalizationMethodType (const xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Algorithm_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CanonicalizationMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Algorithm" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< AlgorithmType > r (
            AlgorithmTraits::create (i, f, this));

          this->Algorithm_.set (r);
          continue;
        }
      }

      if (!Algorithm_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "Algorithm",
          "");
      }
    }

    CanonicalizationMethodType* CanonicalizationMethodType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CanonicalizationMethodType (*this, f, c);
    }

    CanonicalizationMethodType::
    ~CanonicalizationMethodType ()
    {
    }

    // SignatureMethodType
    //

    SignatureMethodType::
    SignatureMethodType (const AlgorithmType& Algorithm)
    : ::xml_schema::Type (),
      HMACOutputLength_ (::xml_schema::Flags (), this),
      Algorithm_ (Algorithm, ::xml_schema::Flags (), this)
    {
    }

    SignatureMethodType::
    SignatureMethodType (const SignatureMethodType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      HMACOutputLength_ (x.HMACOutputLength_, f, this),
      Algorithm_ (x.Algorithm_, f, this)
    {
    }

    SignatureMethodType::
    SignatureMethodType (const xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      HMACOutputLength_ (f, this),
      Algorithm_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SignatureMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // HMACOutputLength
        //
        if (n.name () == "HMACOutputLength" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< HMACOutputLengthType > r (
            HMACOutputLengthTraits::create (i, f, this));

          if (!this->HMACOutputLength_)
          {
            this->HMACOutputLength_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Algorithm" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< AlgorithmType > r (
            AlgorithmTraits::create (i, f, this));

          this->Algorithm_.set (r);
          continue;
        }
      }

      if (!Algorithm_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "Algorithm",
          "");
      }
    }

    SignatureMethodType* SignatureMethodType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SignatureMethodType (*this, f, c);
    }

    SignatureMethodType::
    ~SignatureMethodType ()
    {
    }

    // ReferenceType
    //

    ReferenceType::
    ReferenceType (const DigestMethodType& DigestMethod,
                   const DigestValueType& DigestValue)
    : ::xml_schema::Type (),
      Transforms_ (::xml_schema::Flags (), this),
      DigestMethod_ (DigestMethod, ::xml_schema::Flags (), this),
      DigestValue_ (DigestValue, ::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this),
      URI_ (::xml_schema::Flags (), this),
      Type_ (::xml_schema::Flags (), this)
    {
    }

    ReferenceType::
    ReferenceType (::std::auto_ptr< DigestMethodType >& DigestMethod,
                   const DigestValueType& DigestValue)
    : ::xml_schema::Type (),
      Transforms_ (::xml_schema::Flags (), this),
      DigestMethod_ (DigestMethod, ::xml_schema::Flags (), this),
      DigestValue_ (DigestValue, ::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this),
      URI_ (::xml_schema::Flags (), this),
      Type_ (::xml_schema::Flags (), this)
    {
    }

    ReferenceType::
    ReferenceType (const ReferenceType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Transforms_ (x.Transforms_, f, this),
      DigestMethod_ (x.DigestMethod_, f, this),
      DigestValue_ (x.DigestValue_, f, this),
      Id_ (x.Id_, f, this),
      URI_ (x.URI_, f, this),
      Type_ (x.Type_, f, this)
    {
    }

    ReferenceType::
    ReferenceType (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Transforms_ (f, this),
      DigestMethod_ (f, this),
      DigestValue_ (f, this),
      Id_ (f, this),
      URI_ (f, this),
      Type_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ReferenceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Transforms
        //
        if (n.name () == "Transforms" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< TransformsType > r (
            TransformsTraits::create (i, f, this));

          if (!this->Transforms_)
          {
            this->Transforms_.set (r);
            continue;
          }
        }

        // DigestMethod
        //
        if (n.name () == "DigestMethod" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< DigestMethodType > r (
            DigestMethodTraits::create (i, f, this));

          if (!DigestMethod_.present ())
          {
            this->DigestMethod_.set (r);
            continue;
          }
        }

        // DigestValue
        //
        if (n.name () == "DigestValue" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< DigestValueType > r (
            DigestValueTraits::create (i, f, this));

          if (!DigestValue_.present ())
          {
            this->DigestValue_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DigestMethod_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DigestMethod",
          "http://www.w3.org/2000/09/xmldsig#");
      }

      if (!DigestValue_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DigestValue",
          "http://www.w3.org/2000/09/xmldsig#");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }

        if (n.name () == "URI" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< URIType > r (
            URITraits::create (i, f, this));

          this->URI_.set (r);
          continue;
        }

        if (n.name () == "Type" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< TypeType > r (
            TypeTraits::create (i, f, this));

          this->Type_.set (r);
          continue;
        }
      }
    }

    ReferenceType* ReferenceType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ReferenceType (*this, f, c);
    }

    ReferenceType::
    ~ReferenceType ()
    {
    }

    // TransformsType
    //

    TransformsType::
    TransformsType ()
    : ::xml_schema::Type (),
      Transform_ (::xml_schema::Flags (), this)
    {
    }

    TransformsType::
    TransformsType (const TransformsType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Transform_ (x.Transform_, f, this)
    {
    }

    TransformsType::
    TransformsType (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Transform_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TransformsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< TransformType > r (
            TransformTraits::create (i, f, this));

          this->Transform_.push_back (r);
          continue;
        }

        break;
      }
    }

    TransformsType* TransformsType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TransformsType (*this, f, c);
    }

    TransformsType::
    ~TransformsType ()
    {
    }

    // TransformType
    //

    TransformType::
    TransformType (const AlgorithmType& Algorithm)
    : ::xml_schema::Type (),
      XPath_ (::xml_schema::Flags (), this),
      Algorithm_ (Algorithm, ::xml_schema::Flags (), this)
    {
    }

    TransformType::
    TransformType (const TransformType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      XPath_ (x.XPath_, f, this),
      Algorithm_ (x.Algorithm_, f, this)
    {
    }

    TransformType::
    TransformType (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      XPath_ (f, this),
      Algorithm_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void TransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // XPath
        //
        if (n.name () == "XPath" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< XPathType > r (
            XPathTraits::create (i, f, this));

          this->XPath_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Algorithm" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< AlgorithmType > r (
            AlgorithmTraits::create (i, f, this));

          this->Algorithm_.set (r);
          continue;
        }
      }

      if (!Algorithm_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "Algorithm",
          "");
      }
    }

    TransformType* TransformType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TransformType (*this, f, c);
    }

    TransformType::
    ~TransformType ()
    {
    }

    // DigestMethodType
    //

    DigestMethodType::
    DigestMethodType (const AlgorithmType& Algorithm)
    : ::xml_schema::Type (),
      Algorithm_ (Algorithm, ::xml_schema::Flags (), this)
    {
    }

    DigestMethodType::
    DigestMethodType (const DigestMethodType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Algorithm_ (x.Algorithm_, f, this)
    {
    }

    DigestMethodType::
    DigestMethodType (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Algorithm_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void DigestMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Algorithm" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< AlgorithmType > r (
            AlgorithmTraits::create (i, f, this));

          this->Algorithm_.set (r);
          continue;
        }
      }

      if (!Algorithm_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "Algorithm",
          "");
      }
    }

    DigestMethodType* DigestMethodType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DigestMethodType (*this, f, c);
    }

    DigestMethodType::
    ~DigestMethodType ()
    {
    }

    // DigestValueType
    //

    DigestValueType::
    DigestValueType ()
    : ::xml_schema::Base64Binary ()
    {
    }

    DigestValueType::
    DigestValueType (const ::xml_schema::Base64Binary& _xsd_Base64Binary_base)
    : ::xml_schema::Base64Binary (_xsd_Base64Binary_base)
    {
    }

    DigestValueType::
    DigestValueType (const DigestValueType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Base64Binary (x, f, c)
    {
    }

    DigestValueType::
    DigestValueType (const xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Base64Binary (e, f, c)
    {
    }

    DigestValueType::
    DigestValueType (const xercesc::DOMAttr& a,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Base64Binary (a, f, c)
    {
    }

    DigestValueType::
    DigestValueType (const ::std::string& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Base64Binary (s, e, f, c)
    {
    }

    DigestValueType* DigestValueType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DigestValueType (*this, f, c);
    }

    DigestValueType::
    ~DigestValueType ()
    {
    }

    // KeyInfoType
    //

    KeyInfoType::
    KeyInfoType ()
    : ::xml_schema::Type (),
      KeyName_ (::xml_schema::Flags (), this),
      KeyValue_ (::xml_schema::Flags (), this),
      RetrievalMethod_ (::xml_schema::Flags (), this),
      X509Data_ (::xml_schema::Flags (), this),
      PGPData_ (::xml_schema::Flags (), this),
      SPKIData_ (::xml_schema::Flags (), this),
      MgmtData_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    KeyInfoType::
    KeyInfoType (const KeyInfoType& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      KeyName_ (x.KeyName_, f, this),
      KeyValue_ (x.KeyValue_, f, this),
      RetrievalMethod_ (x.RetrievalMethod_, f, this),
      X509Data_ (x.X509Data_, f, this),
      PGPData_ (x.PGPData_, f, this),
      SPKIData_ (x.SPKIData_, f, this),
      MgmtData_ (x.MgmtData_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    KeyInfoType::
    KeyInfoType (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      KeyName_ (f, this),
      KeyValue_ (f, this),
      RetrievalMethod_ (f, this),
      X509Data_ (f, this),
      PGPData_ (f, this),
      SPKIData_ (f, this),
      MgmtData_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void KeyInfoType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // KeyName
        //
        if (n.name () == "KeyName" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< KeyNameType > r (
            KeyNameTraits::create (i, f, this));

          this->KeyName_.push_back (r);
          continue;
        }

        // KeyValue
        //
        if (n.name () == "KeyValue" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< KeyValueType > r (
            KeyValueTraits::create (i, f, this));

          this->KeyValue_.push_back (r);
          continue;
        }

        // RetrievalMethod
        //
        if (n.name () == "RetrievalMethod" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< RetrievalMethodType > r (
            RetrievalMethodTraits::create (i, f, this));

          this->RetrievalMethod_.push_back (r);
          continue;
        }

        // X509Data
        //
        if (n.name () == "X509Data" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< X509DataType > r (
            X509DataTraits::create (i, f, this));

          this->X509Data_.push_back (r);
          continue;
        }

        // PGPData
        //
        if (n.name () == "PGPData" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< PGPDataType > r (
            PGPDataTraits::create (i, f, this));

          this->PGPData_.push_back (r);
          continue;
        }

        // SPKIData
        //
        if (n.name () == "SPKIData" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< SPKIDataType > r (
            SPKIDataTraits::create (i, f, this));

          this->SPKIData_.push_back (r);
          continue;
        }

        // MgmtData
        //
        if (n.name () == "MgmtData" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< MgmtDataType > r (
            MgmtDataTraits::create (i, f, this));

          this->MgmtData_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    KeyInfoType* KeyInfoType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class KeyInfoType (*this, f, c);
    }

    KeyInfoType::
    ~KeyInfoType ()
    {
    }

    // KeyValueType
    //

    KeyValueType::
    KeyValueType ()
    : ::xml_schema::Type (),
      DSAKeyValue_ (::xml_schema::Flags (), this),
      RSAKeyValue_ (::xml_schema::Flags (), this)
    {
    }

    KeyValueType::
    KeyValueType (const KeyValueType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      DSAKeyValue_ (x.DSAKeyValue_, f, this),
      RSAKeyValue_ (x.RSAKeyValue_, f, this)
    {
    }

    KeyValueType::
    KeyValueType (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      DSAKeyValue_ (f, this),
      RSAKeyValue_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void KeyValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DSAKeyValue
        //
        if (n.name () == "DSAKeyValue" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< DSAKeyValueType > r (
            DSAKeyValueTraits::create (i, f, this));

          if (!this->DSAKeyValue_)
          {
            this->DSAKeyValue_.set (r);
            continue;
          }
        }

        // RSAKeyValue
        //
        if (n.name () == "RSAKeyValue" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< RSAKeyValueType > r (
            RSAKeyValueTraits::create (i, f, this));

          if (!this->RSAKeyValue_)
          {
            this->RSAKeyValue_.set (r);
            continue;
          }
        }

        break;
      }
    }

    KeyValueType* KeyValueType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class KeyValueType (*this, f, c);
    }

    KeyValueType::
    ~KeyValueType ()
    {
    }

    // RetrievalMethodType
    //

    RetrievalMethodType::
    RetrievalMethodType ()
    : ::xml_schema::Type (),
      Transforms_ (::xml_schema::Flags (), this),
      URI_ (::xml_schema::Flags (), this),
      Type_ (::xml_schema::Flags (), this)
    {
    }

    RetrievalMethodType::
    RetrievalMethodType (const RetrievalMethodType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Transforms_ (x.Transforms_, f, this),
      URI_ (x.URI_, f, this),
      Type_ (x.Type_, f, this)
    {
    }

    RetrievalMethodType::
    RetrievalMethodType (const xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Transforms_ (f, this),
      URI_ (f, this),
      Type_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void RetrievalMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Transforms
        //
        if (n.name () == "Transforms" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< TransformsType > r (
            TransformsTraits::create (i, f, this));

          if (!this->Transforms_)
          {
            this->Transforms_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "URI" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< URIType > r (
            URITraits::create (i, f, this));

          this->URI_.set (r);
          continue;
        }

        if (n.name () == "Type" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< TypeType > r (
            TypeTraits::create (i, f, this));

          this->Type_.set (r);
          continue;
        }
      }
    }

    RetrievalMethodType* RetrievalMethodType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class RetrievalMethodType (*this, f, c);
    }

    RetrievalMethodType::
    ~RetrievalMethodType ()
    {
    }

    // X509DataType
    //

    X509DataType::
    X509DataType ()
    : ::xml_schema::Type (),
      X509IssuerSerial_ (::xml_schema::Flags (), this),
      X509SKI_ (::xml_schema::Flags (), this),
      X509SubjectName_ (::xml_schema::Flags (), this),
      X509Certificate_ (::xml_schema::Flags (), this),
      X509CRL_ (::xml_schema::Flags (), this)
    {
    }

    X509DataType::
    X509DataType (const X509DataType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      X509IssuerSerial_ (x.X509IssuerSerial_, f, this),
      X509SKI_ (x.X509SKI_, f, this),
      X509SubjectName_ (x.X509SubjectName_, f, this),
      X509Certificate_ (x.X509Certificate_, f, this),
      X509CRL_ (x.X509CRL_, f, this)
    {
    }

    X509DataType::
    X509DataType (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      X509IssuerSerial_ (f, this),
      X509SKI_ (f, this),
      X509SubjectName_ (f, this),
      X509Certificate_ (f, this),
      X509CRL_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void X509DataType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // X509IssuerSerial
        //
        if (n.name () == "X509IssuerSerial" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< X509IssuerSerialType > r (
            X509IssuerSerialTraits::create (i, f, this));

          this->X509IssuerSerial_.push_back (r);
          continue;
        }

        // X509SKI
        //
        if (n.name () == "X509SKI" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< X509SKIType > r (
            X509SKITraits::create (i, f, this));

          this->X509SKI_.push_back (r);
          continue;
        }

        // X509SubjectName
        //
        if (n.name () == "X509SubjectName" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< X509SubjectNameType > r (
            X509SubjectNameTraits::create (i, f, this));

          this->X509SubjectName_.push_back (r);
          continue;
        }

        // X509Certificate
        //
        if (n.name () == "X509Certificate" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< X509CertificateType > r (
            X509CertificateTraits::create (i, f, this));

          this->X509Certificate_.push_back (r);
          continue;
        }

        // X509CRL
        //
        if (n.name () == "X509CRL" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< X509CRLType > r (
            X509CRLTraits::create (i, f, this));

          this->X509CRL_.push_back (r);
          continue;
        }

        break;
      }
    }

    X509DataType* X509DataType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class X509DataType (*this, f, c);
    }

    X509DataType::
    ~X509DataType ()
    {
    }

    // X509IssuerSerialType
    //

    X509IssuerSerialType::
    X509IssuerSerialType (const X509IssuerNameType& X509IssuerName,
                          const X509SerialNumberType& X509SerialNumber)
    : ::xml_schema::Type (),
      X509IssuerName_ (X509IssuerName, ::xml_schema::Flags (), this),
      X509SerialNumber_ (X509SerialNumber, ::xml_schema::Flags (), this)
    {
    }

    X509IssuerSerialType::
    X509IssuerSerialType (const X509IssuerSerialType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      X509IssuerName_ (x.X509IssuerName_, f, this),
      X509SerialNumber_ (x.X509SerialNumber_, f, this)
    {
    }

    X509IssuerSerialType::
    X509IssuerSerialType (const xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      X509IssuerName_ (f, this),
      X509SerialNumber_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void X509IssuerSerialType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // X509IssuerName
        //
        if (n.name () == "X509IssuerName" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< X509IssuerNameType > r (
            X509IssuerNameTraits::create (i, f, this));

          if (!X509IssuerName_.present ())
          {
            this->X509IssuerName_.set (r);
            continue;
          }
        }

        // X509SerialNumber
        //
        if (n.name () == "X509SerialNumber" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          if (!X509SerialNumber_.present ())
          {
            this->X509SerialNumber_.set (X509SerialNumberTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!X509IssuerName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "X509IssuerName",
          "http://www.w3.org/2000/09/xmldsig#");
      }

      if (!X509SerialNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "X509SerialNumber",
          "http://www.w3.org/2000/09/xmldsig#");
      }
    }

    X509IssuerSerialType* X509IssuerSerialType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class X509IssuerSerialType (*this, f, c);
    }

    X509IssuerSerialType::
    ~X509IssuerSerialType ()
    {
    }

    // PGPDataType
    //

    PGPDataType::
    PGPDataType ()
    : ::xml_schema::Type (),
      PGPKeyID_ (::xml_schema::Flags (), this),
      PGPKeyPacket_ (::xml_schema::Flags (), this)
    {
    }

    PGPDataType::
    PGPDataType (const PGPDataType& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      PGPKeyID_ (x.PGPKeyID_, f, this),
      PGPKeyPacket_ (x.PGPKeyPacket_, f, this)
    {
    }

    PGPDataType::
    PGPDataType (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      PGPKeyID_ (f, this),
      PGPKeyPacket_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PGPDataType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PGPKeyID
        //
        if (n.name () == "PGPKeyID" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< PGPKeyIDType > r (
            PGPKeyIDTraits::create (i, f, this));

          if (!this->PGPKeyID_)
          {
            this->PGPKeyID_.set (r);
            continue;
          }
        }

        // PGPKeyPacket
        //
        if (n.name () == "PGPKeyPacket" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< PGPKeyPacketType > r (
            PGPKeyPacketTraits::create (i, f, this));

          if (!this->PGPKeyPacket_)
          {
            this->PGPKeyPacket_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PGPDataType* PGPDataType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class PGPDataType (*this, f, c);
    }

    PGPDataType::
    ~PGPDataType ()
    {
    }

    // SPKIDataType
    //

    SPKIDataType::
    SPKIDataType ()
    : ::xml_schema::Type (),
      SPKISexp_ (::xml_schema::Flags (), this)
    {
    }

    SPKIDataType::
    SPKIDataType (const SPKIDataType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      SPKISexp_ (x.SPKISexp_, f, this)
    {
    }

    SPKIDataType::
    SPKIDataType (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      SPKISexp_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SPKIDataType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SPKISexp
        //
        if (n.name () == "SPKISexp" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< SPKISexpType > r (
            SPKISexpTraits::create (i, f, this));

          this->SPKISexp_.push_back (r);
          continue;
        }

        break;
      }
    }

    SPKIDataType* SPKIDataType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SPKIDataType (*this, f, c);
    }

    SPKIDataType::
    ~SPKIDataType ()
    {
    }

    // ObjectType
    //

    ObjectType::
    ObjectType ()
    : ::xml_schema::Type (),
      QualifyingProperties_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this),
      MimeType_ (::xml_schema::Flags (), this),
      Encoding_ (::xml_schema::Flags (), this)
    {
    }

    ObjectType::
    ObjectType (const ObjectType& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      QualifyingProperties_ (x.QualifyingProperties_, f, this),
      Id_ (x.Id_, f, this),
      MimeType_ (x.MimeType_, f, this),
      Encoding_ (x.Encoding_, f, this)
    {
    }

    ObjectType::
    ObjectType (const xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      QualifyingProperties_ (f, this),
      Id_ (f, this),
      MimeType_ (f, this),
      Encoding_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ObjectType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // QualifyingProperties
        //
        if (n.name () == "QualifyingProperties" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< QualifyingPropertiesType > r (
            QualifyingPropertiesTraits::create (i, f, this));

          this->QualifyingProperties_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }

        if (n.name () == "MimeType" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< MimeTypeType > r (
            MimeTypeTraits::create (i, f, this));

          this->MimeType_.set (r);
          continue;
        }

        if (n.name () == "Encoding" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< EncodingType > r (
            EncodingTraits::create (i, f, this));

          this->Encoding_.set (r);
          continue;
        }
      }
    }

    ObjectType* ObjectType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ObjectType (*this, f, c);
    }

    ObjectType::
    ~ObjectType ()
    {
    }

    // ManifestType
    //

    ManifestType::
    ManifestType ()
    : ::xml_schema::Type (),
      Reference_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    ManifestType::
    ManifestType (const ManifestType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Reference_ (x.Reference_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    ManifestType::
    ManifestType (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Reference_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ManifestType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Reference
        //
        if (n.name () == "Reference" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< ReferenceType > r (
            ReferenceTraits::create (i, f, this));

          this->Reference_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    ManifestType* ManifestType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ManifestType (*this, f, c);
    }

    ManifestType::
    ~ManifestType ()
    {
    }

    // SignaturePropertiesType
    //

    SignaturePropertiesType::
    SignaturePropertiesType ()
    : ::xml_schema::Type (),
      SignatureProperty_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    SignaturePropertiesType::
    SignaturePropertiesType (const SignaturePropertiesType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      SignatureProperty_ (x.SignatureProperty_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    SignaturePropertiesType::
    SignaturePropertiesType (const xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      SignatureProperty_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SignaturePropertiesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SignatureProperty
        //
        if (n.name () == "SignatureProperty" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< SignaturePropertyType > r (
            SignaturePropertyTraits::create (i, f, this));

          this->SignatureProperty_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    SignaturePropertiesType* SignaturePropertiesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SignaturePropertiesType (*this, f, c);
    }

    SignaturePropertiesType::
    ~SignaturePropertiesType ()
    {
    }

    // SignaturePropertyType
    //

    SignaturePropertyType::
    SignaturePropertyType (const TargetType& Target)
    : ::xml_schema::Type (),
      Target_ (Target, ::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    SignaturePropertyType::
    SignaturePropertyType (const SignaturePropertyType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Target_ (x.Target_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    SignaturePropertyType::
    SignaturePropertyType (const xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Target_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SignaturePropertyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Target" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< TargetType > r (
            TargetTraits::create (i, f, this));

          this->Target_.set (r);
          continue;
        }

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }

      if (!Target_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "Target",
          "");
      }
    }

    SignaturePropertyType* SignaturePropertyType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SignaturePropertyType (*this, f, c);
    }

    SignaturePropertyType::
    ~SignaturePropertyType ()
    {
    }

    // HMACOutputLengthType
    //

    HMACOutputLengthType::
    HMACOutputLengthType (const ::xml_schema::Integer& _xsd_Integer_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (_xsd_Integer_base)
    {
    }

    HMACOutputLengthType::
    HMACOutputLengthType (const HMACOutputLengthType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (x, f, c)
    {
    }

    HMACOutputLengthType::
    HMACOutputLengthType (const xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (e, f, c)
    {
    }

    HMACOutputLengthType::
    HMACOutputLengthType (const xercesc::DOMAttr& a,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (a, f, c)
    {
    }

    HMACOutputLengthType::
    HMACOutputLengthType (const ::std::string& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (s, e, f, c)
    {
    }

    HMACOutputLengthType* HMACOutputLengthType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class HMACOutputLengthType (*this, f, c);
    }

    HMACOutputLengthType::
    ~HMACOutputLengthType ()
    {
    }

    // DSAKeyValueType
    //

    DSAKeyValueType::
    DSAKeyValueType (const YType& Y)
    : ::xml_schema::Type (),
      P_ (::xml_schema::Flags (), this),
      Q_ (::xml_schema::Flags (), this),
      G_ (::xml_schema::Flags (), this),
      Y_ (Y, ::xml_schema::Flags (), this),
      J_ (::xml_schema::Flags (), this),
      Seed_ (::xml_schema::Flags (), this),
      PgenCounter_ (::xml_schema::Flags (), this)
    {
    }

    DSAKeyValueType::
    DSAKeyValueType (const DSAKeyValueType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      P_ (x.P_, f, this),
      Q_ (x.Q_, f, this),
      G_ (x.G_, f, this),
      Y_ (x.Y_, f, this),
      J_ (x.J_, f, this),
      Seed_ (x.Seed_, f, this),
      PgenCounter_ (x.PgenCounter_, f, this)
    {
    }

    DSAKeyValueType::
    DSAKeyValueType (const xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      P_ (f, this),
      Q_ (f, this),
      G_ (f, this),
      Y_ (f, this),
      J_ (f, this),
      Seed_ (f, this),
      PgenCounter_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void DSAKeyValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // P
        //
        if (n.name () == "P" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< PType > r (
            PTraits::create (i, f, this));

          if (!this->P_)
          {
            this->P_.set (r);
            continue;
          }
        }

        // Q
        //
        if (n.name () == "Q" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< QType > r (
            QTraits::create (i, f, this));

          if (!this->Q_)
          {
            this->Q_.set (r);
            continue;
          }
        }

        // G
        //
        if (n.name () == "G" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< GType > r (
            GTraits::create (i, f, this));

          if (!this->G_)
          {
            this->G_.set (r);
            continue;
          }
        }

        // Y
        //
        if (n.name () == "Y" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< YType > r (
            YTraits::create (i, f, this));

          if (!Y_.present ())
          {
            this->Y_.set (r);
            continue;
          }
        }

        // J
        //
        if (n.name () == "J" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< JType > r (
            JTraits::create (i, f, this));

          if (!this->J_)
          {
            this->J_.set (r);
            continue;
          }
        }

        // Seed
        //
        if (n.name () == "Seed" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< SeedType > r (
            SeedTraits::create (i, f, this));

          if (!this->Seed_)
          {
            this->Seed_.set (r);
            continue;
          }
        }

        // PgenCounter
        //
        if (n.name () == "PgenCounter" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< PgenCounterType > r (
            PgenCounterTraits::create (i, f, this));

          if (!this->PgenCounter_)
          {
            this->PgenCounter_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Y_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Y",
          "http://www.w3.org/2000/09/xmldsig#");
      }
    }

    DSAKeyValueType* DSAKeyValueType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DSAKeyValueType (*this, f, c);
    }

    DSAKeyValueType::
    ~DSAKeyValueType ()
    {
    }

    // RSAKeyValueType
    //

    RSAKeyValueType::
    RSAKeyValueType (const ModulusType& Modulus,
                     const ExponentType& Exponent)
    : ::xml_schema::Type (),
      Modulus_ (Modulus, ::xml_schema::Flags (), this),
      Exponent_ (Exponent, ::xml_schema::Flags (), this)
    {
    }

    RSAKeyValueType::
    RSAKeyValueType (const RSAKeyValueType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Modulus_ (x.Modulus_, f, this),
      Exponent_ (x.Exponent_, f, this)
    {
    }

    RSAKeyValueType::
    RSAKeyValueType (const xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Modulus_ (f, this),
      Exponent_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void RSAKeyValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Modulus
        //
        if (n.name () == "Modulus" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< ModulusType > r (
            ModulusTraits::create (i, f, this));

          if (!Modulus_.present ())
          {
            this->Modulus_.set (r);
            continue;
          }
        }

        // Exponent
        //
        if (n.name () == "Exponent" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< ExponentType > r (
            ExponentTraits::create (i, f, this));

          if (!Exponent_.present ())
          {
            this->Exponent_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Modulus_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Modulus",
          "http://www.w3.org/2000/09/xmldsig#");
      }

      if (!Exponent_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Exponent",
          "http://www.w3.org/2000/09/xmldsig#");
      }
    }

    RSAKeyValueType* RSAKeyValueType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class RSAKeyValueType (*this, f, c);
    }

    RSAKeyValueType::
    ~RSAKeyValueType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace digidoc
{
  namespace dsig
  {
    ::std::auto_ptr< ::digidoc::dsig::SignatureType >
    signature (const ::std::string& u,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::digidoc::dsig::SignatureType > r (
        ::digidoc::dsig::signature (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::digidoc::dsig::SignatureType >
    signature (const ::std::string& u,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::digidoc::dsig::SignatureType > r (
        ::digidoc::dsig::signature (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::digidoc::dsig::SignatureType >
    signature (const ::std::string& u,
               xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::digidoc::dsig::SignatureType > r (
        ::digidoc::dsig::signature (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::digidoc::dsig::SignatureType >
    signature (::std::istream& is,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::digidoc::dsig::signature (isrc, f, p);
    }

    ::std::auto_ptr< ::digidoc::dsig::SignatureType >
    signature (::std::istream& is,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::digidoc::dsig::signature (isrc, h, f, p);
    }

    ::std::auto_ptr< ::digidoc::dsig::SignatureType >
    signature (::std::istream& is,
               xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::digidoc::dsig::signature (isrc, h, f, p);
    }

    ::std::auto_ptr< ::digidoc::dsig::SignatureType >
    signature (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::digidoc::dsig::signature (isrc, f, p);
    }

    ::std::auto_ptr< ::digidoc::dsig::SignatureType >
    signature (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::digidoc::dsig::signature (isrc, h, f, p);
    }

    ::std::auto_ptr< ::digidoc::dsig::SignatureType >
    signature (::std::istream& is,
               const ::std::string& sid,
               xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::digidoc::dsig::signature (isrc, h, f, p);
    }

    ::std::auto_ptr< ::digidoc::dsig::SignatureType >
    signature (xercesc::InputSource& i,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::digidoc::dsig::SignatureType > r (
        ::digidoc::dsig::signature (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::digidoc::dsig::SignatureType >
    signature (xercesc::InputSource& i,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::digidoc::dsig::SignatureType > r (
        ::digidoc::dsig::signature (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::digidoc::dsig::SignatureType >
    signature (xercesc::InputSource& i,
               xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::digidoc::dsig::SignatureType > r (
        ::digidoc::dsig::signature (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::digidoc::dsig::SignatureType >
    signature (const xercesc::DOMDocument& d,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::digidoc::dsig::SignatureType > r (
          ::digidoc::dsig::signature (
            c, f | ::xml_schema::Flags::own_dom, p));

        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Signature" &&
          n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::auto_ptr< ::digidoc::dsig::SignatureType > r (
          ::xsd::cxx::tree::traits< ::digidoc::dsig::SignatureType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Signature",
        "http://www.w3.org/2000/09/xmldsig#");
    }

    ::std::auto_ptr< ::digidoc::dsig::SignatureType >
    signature (::xml_schema::dom::auto_ptr< xercesc::DOMDocument >& d,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Signature" &&
          n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::auto_ptr< ::digidoc::dsig::SignatureType > r (
          ::xsd::cxx::tree::traits< ::digidoc::dsig::SignatureType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Signature",
        "http://www.w3.org/2000/09/xmldsig#");
    }
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace digidoc
{
  namespace dsig
  {
    void
    operator<< (xercesc::DOMElement& e, const CryptoBinary& i)
    {
      e << static_cast< const ::xml_schema::Base64Binary& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a,const CryptoBinary& i)
    {
      a << static_cast< const ::xml_schema::Base64Binary& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const CryptoBinary& i)
    {
      l << static_cast< const ::xml_schema::Base64Binary& > (i);
    }

    void
    signature (::std::ostream& o,
               const ::digidoc::dsig::SignatureType& s,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::digidoc::dsig::signature (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    signature (::std::ostream& o,
               const ::digidoc::dsig::SignatureType& s,
               ::xml_schema::ErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::digidoc::dsig::signature (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    signature (::std::ostream& o,
               const ::digidoc::dsig::SignatureType& s,
               xercesc::DOMErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::digidoc::dsig::signature (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    signature (xercesc::XMLFormatTarget& t,
               const ::digidoc::dsig::SignatureType& s,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::digidoc::dsig::signature (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    signature (xercesc::XMLFormatTarget& t,
               const ::digidoc::dsig::SignatureType& s,
               ::xml_schema::ErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::digidoc::dsig::signature (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    signature (xercesc::XMLFormatTarget& t,
               const ::digidoc::dsig::SignatureType& s,
               xercesc::DOMErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::digidoc::dsig::signature (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    signature (xercesc::DOMDocument& d,
               const ::digidoc::dsig::SignatureType& s,
               ::xml_schema::Flags)
    {
      xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Signature" &&
          n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "Signature",
          "http://www.w3.org/2000/09/xmldsig#");
      }
    }

    ::xml_schema::dom::auto_ptr< xercesc::DOMDocument >
    signature (const ::digidoc::dsig::SignatureType& s,
               const ::xml_schema::NamespaceInfomap& m,
               ::xml_schema::Flags f)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "Signature",
          "http://www.w3.org/2000/09/xmldsig#",
          m, f));

      ::digidoc::dsig::signature (*d, s, f);
      return d;
    }

    void
    operator<< (xercesc::DOMElement& e, const SignatureType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // SignedInfo
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SignedInfo",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << i.signedInfo ();
      }

      // SignatureValue
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SignatureValue",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << i.signatureValue ();
      }

      // KeyInfo
      //
      if (i.keyInfo ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "KeyInfo",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *i.keyInfo ();
      }

      // Object
      //
      for (SignatureType::ObjectConstIterator
           b (i.object ().begin ()), n (i.object ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Object",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SignatureValueType& i)
    {
      e << static_cast< const ::xml_schema::Base64Binary& > (i);

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SignedInfoType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // CanonicalizationMethod
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CanonicalizationMethod",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << i.canonicalizationMethod ();
      }

      // SignatureMethod
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SignatureMethod",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << i.signatureMethod ();
      }

      // Reference
      //
      for (SignedInfoType::ReferenceConstIterator
           b (i.reference ().begin ()), n (i.reference ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Reference",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CanonicalizationMethodType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Algorithm
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Algorithm",
            e));

        a << i.algorithm ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SignatureMethodType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // HMACOutputLength
      //
      if (i.hMACOutputLength ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "HMACOutputLength",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *i.hMACOutputLength ();
      }

      // Algorithm
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Algorithm",
            e));

        a << i.algorithm ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ReferenceType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Transforms
      //
      if (i.transforms ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transforms",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *i.transforms ();
      }

      // DigestMethod
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DigestMethod",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << i.digestMethod ();
      }

      // DigestValue
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DigestValue",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << i.digestValue ();
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }

      // URI
      //
      if (i.uRI ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "URI",
            e));

        a << *i.uRI ();
      }

      // Type
      //
      if (i.type ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Type",
            e));

        a << *i.type ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TransformsType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Transform
      //
      for (TransformsType::TransformConstIterator
           b (i.transform ().begin ()), n (i.transform ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TransformType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // XPath
      //
      for (TransformType::XPathConstIterator
           b (i.xPath ().begin ()), n (i.xPath ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XPath",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }

      // Algorithm
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Algorithm",
            e));

        a << i.algorithm ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DigestMethodType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Algorithm
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Algorithm",
            e));

        a << i.algorithm ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DigestValueType& i)
    {
      e << static_cast< const ::xml_schema::Base64Binary& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a,const DigestValueType& i)
    {
      a << static_cast< const ::xml_schema::Base64Binary& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DigestValueType& i)
    {
      l << static_cast< const ::xml_schema::Base64Binary& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const KeyInfoType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // KeyName
      //
      for (KeyInfoType::KeyNameConstIterator
           b (i.keyName ().begin ()), n (i.keyName ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "KeyName",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }

      // KeyValue
      //
      for (KeyInfoType::KeyValueConstIterator
           b (i.keyValue ().begin ()), n (i.keyValue ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "KeyValue",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }

      // RetrievalMethod
      //
      for (KeyInfoType::RetrievalMethodConstIterator
           b (i.retrievalMethod ().begin ()), n (i.retrievalMethod ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RetrievalMethod",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }

      // X509Data
      //
      for (KeyInfoType::X509DataConstIterator
           b (i.x509Data ().begin ()), n (i.x509Data ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "X509Data",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }

      // PGPData
      //
      for (KeyInfoType::PGPDataConstIterator
           b (i.pGPData ().begin ()), n (i.pGPData ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PGPData",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }

      // SPKIData
      //
      for (KeyInfoType::SPKIDataConstIterator
           b (i.sPKIData ().begin ()), n (i.sPKIData ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SPKIData",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }

      // MgmtData
      //
      for (KeyInfoType::MgmtDataConstIterator
           b (i.mgmtData ().begin ()), n (i.mgmtData ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MgmtData",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const KeyValueType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // DSAKeyValue
      //
      if (i.dSAKeyValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DSAKeyValue",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *i.dSAKeyValue ();
      }

      // RSAKeyValue
      //
      if (i.rSAKeyValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RSAKeyValue",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *i.rSAKeyValue ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const RetrievalMethodType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Transforms
      //
      if (i.transforms ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transforms",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *i.transforms ();
      }

      // URI
      //
      if (i.uRI ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "URI",
            e));

        a << *i.uRI ();
      }

      // Type
      //
      if (i.type ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Type",
            e));

        a << *i.type ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const X509DataType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // X509IssuerSerial
      //
      for (X509DataType::X509IssuerSerialConstIterator
           b (i.x509IssuerSerial ().begin ()), n (i.x509IssuerSerial ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "X509IssuerSerial",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }

      // X509SKI
      //
      for (X509DataType::X509SKIConstIterator
           b (i.x509SKI ().begin ()), n (i.x509SKI ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "X509SKI",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }

      // X509SubjectName
      //
      for (X509DataType::X509SubjectNameConstIterator
           b (i.x509SubjectName ().begin ()), n (i.x509SubjectName ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "X509SubjectName",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }

      // X509Certificate
      //
      for (X509DataType::X509CertificateConstIterator
           b (i.x509Certificate ().begin ()), n (i.x509Certificate ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "X509Certificate",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }

      // X509CRL
      //
      for (X509DataType::X509CRLConstIterator
           b (i.x509CRL ().begin ()), n (i.x509CRL ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "X509CRL",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const X509IssuerSerialType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // X509IssuerName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "X509IssuerName",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << i.x509IssuerName ();
      }

      // X509SerialNumber
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "X509SerialNumber",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << i.x509SerialNumber ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PGPDataType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // PGPKeyID
      //
      if (i.pGPKeyID ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PGPKeyID",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *i.pGPKeyID ();
      }

      // PGPKeyPacket
      //
      if (i.pGPKeyPacket ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PGPKeyPacket",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *i.pGPKeyPacket ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SPKIDataType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // SPKISexp
      //
      for (SPKIDataType::SPKISexpConstIterator
           b (i.sPKISexp ().begin ()), n (i.sPKISexp ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SPKISexp",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ObjectType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // QualifyingProperties
      //
      for (ObjectType::QualifyingPropertiesConstIterator
           b (i.qualifyingProperties ().begin ()), n (i.qualifyingProperties ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "QualifyingProperties",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }

      // MimeType
      //
      if (i.mimeType ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "MimeType",
            e));

        a << *i.mimeType ();
      }

      // Encoding
      //
      if (i.encoding ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Encoding",
            e));

        a << *i.encoding ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ManifestType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Reference
      //
      for (ManifestType::ReferenceConstIterator
           b (i.reference ().begin ()), n (i.reference ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Reference",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SignaturePropertiesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // SignatureProperty
      //
      for (SignaturePropertiesType::SignaturePropertyConstIterator
           b (i.signatureProperty ().begin ()), n (i.signatureProperty ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SignatureProperty",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *b;
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SignaturePropertyType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Target
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Target",
            e));

        a << i.target ();
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const HMACOutputLengthType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a,const HMACOutputLengthType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const HMACOutputLengthType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const DSAKeyValueType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // P
      //
      if (i.p ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "P",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *i.p ();
      }

      // Q
      //
      if (i.q ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Q",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *i.q ();
      }

      // G
      //
      if (i.g ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "G",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *i.g ();
      }

      // Y
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Y",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << i.y ();
      }

      // J
      //
      if (i.j ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "J",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *i.j ();
      }

      // Seed
      //
      if (i.seed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Seed",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *i.seed ();
      }

      // PgenCounter
      //
      if (i.pgenCounter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PgenCounter",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *i.pgenCounter ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const RSAKeyValueType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Modulus
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Modulus",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << i.modulus ();
      }

      // Exponent
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Exponent",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << i.exponent ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

