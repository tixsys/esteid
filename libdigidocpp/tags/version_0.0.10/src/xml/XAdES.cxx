// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "XAdES.hxx"

namespace digidoc
{
  namespace xades
  {
    // AnyType
    // 


    // ObjectIdentifierType
    // 

    const ObjectIdentifierType::IdentifierType& ObjectIdentifierType::
    identifier () const
    {
      return this->Identifier_.get ();
    }

    ObjectIdentifierType::IdentifierType& ObjectIdentifierType::
    identifier ()
    {
      return this->Identifier_.get ();
    }

    void ObjectIdentifierType::
    identifier (const IdentifierType& x)
    {
      this->Identifier_.set (x);
    }

    void ObjectIdentifierType::
    identifier (::std::auto_ptr< IdentifierType > x)
    {
      this->Identifier_.set (x);
    }

    const ObjectIdentifierType::DescriptionOptional& ObjectIdentifierType::
    description () const
    {
      return this->Description_;
    }

    ObjectIdentifierType::DescriptionOptional& ObjectIdentifierType::
    description ()
    {
      return this->Description_;
    }

    void ObjectIdentifierType::
    description (const DescriptionType& x)
    {
      this->Description_.set (x);
    }

    void ObjectIdentifierType::
    description (const DescriptionOptional& x)
    {
      this->Description_ = x;
    }

    void ObjectIdentifierType::
    description (::std::auto_ptr< DescriptionType > x)
    {
      this->Description_.set (x);
    }

    const ObjectIdentifierType::DocumentationReferencesOptional& ObjectIdentifierType::
    documentationReferences () const
    {
      return this->DocumentationReferences_;
    }

    ObjectIdentifierType::DocumentationReferencesOptional& ObjectIdentifierType::
    documentationReferences ()
    {
      return this->DocumentationReferences_;
    }

    void ObjectIdentifierType::
    documentationReferences (const DocumentationReferencesType& x)
    {
      this->DocumentationReferences_.set (x);
    }

    void ObjectIdentifierType::
    documentationReferences (const DocumentationReferencesOptional& x)
    {
      this->DocumentationReferences_ = x;
    }

    void ObjectIdentifierType::
    documentationReferences (::std::auto_ptr< DocumentationReferencesType > x)
    {
      this->DocumentationReferences_.set (x);
    }


    // IdentifierType
    // 

    const IdentifierType::QualifierOptional& IdentifierType::
    qualifier () const
    {
      return this->Qualifier_;
    }

    IdentifierType::QualifierOptional& IdentifierType::
    qualifier ()
    {
      return this->Qualifier_;
    }

    void IdentifierType::
    qualifier (const QualifierType& x)
    {
      this->Qualifier_.set (x);
    }

    void IdentifierType::
    qualifier (const QualifierOptional& x)
    {
      this->Qualifier_ = x;
    }

    void IdentifierType::
    qualifier (::std::auto_ptr< QualifierType > x)
    {
      this->Qualifier_.set (x);
    }


    // QualifierType
    // 

    QualifierType::
    QualifierType (Value v)
    : ::xml_schema::String (_xsd_QualifierType_literals_[v])
    {
    }

    QualifierType::
    QualifierType (const char* v)
    : ::xml_schema::String (v)
    {
    }

    QualifierType::
    QualifierType (const ::std::string& v)
    : ::xml_schema::String (v)
    {
    }

    QualifierType::
    QualifierType (const ::xml_schema::String& v)
    : ::xml_schema::String (v)
    {
    }

    QualifierType::
    QualifierType (const QualifierType& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (v, f, c)
    {
    }

    QualifierType& QualifierType::
    operator= (Value v)
    {
      static_cast< ::xml_schema::String& > (*this) = 
      ::xml_schema::String (_xsd_QualifierType_literals_[v]);

      return *this;
    }


    // DocumentationReferencesType
    // 

    const DocumentationReferencesType::DocumentationReferenceSequence& DocumentationReferencesType::
    documentationReference () const
    {
      return this->DocumentationReference_;
    }

    DocumentationReferencesType::DocumentationReferenceSequence& DocumentationReferencesType::
    documentationReference ()
    {
      return this->DocumentationReference_;
    }

    void DocumentationReferencesType::
    documentationReference (const DocumentationReferenceSequence& s)
    {
      this->DocumentationReference_ = s;
    }


    // EncapsulatedPKIDataType
    // 

    const EncapsulatedPKIDataType::IdOptional& EncapsulatedPKIDataType::
    id () const
    {
      return this->Id_;
    }

    EncapsulatedPKIDataType::IdOptional& EncapsulatedPKIDataType::
    id ()
    {
      return this->Id_;
    }

    void EncapsulatedPKIDataType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void EncapsulatedPKIDataType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void EncapsulatedPKIDataType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }

    const EncapsulatedPKIDataType::EncodingOptional& EncapsulatedPKIDataType::
    encoding () const
    {
      return this->Encoding_;
    }

    EncapsulatedPKIDataType::EncodingOptional& EncapsulatedPKIDataType::
    encoding ()
    {
      return this->Encoding_;
    }

    void EncapsulatedPKIDataType::
    encoding (const EncodingType& x)
    {
      this->Encoding_.set (x);
    }

    void EncapsulatedPKIDataType::
    encoding (const EncodingOptional& x)
    {
      this->Encoding_ = x;
    }

    void EncapsulatedPKIDataType::
    encoding (::std::auto_ptr< EncodingType > x)
    {
      this->Encoding_.set (x);
    }


    // IncludeType
    // 

    const IncludeType::URIType& IncludeType::
    uRI () const
    {
      return this->URI_.get ();
    }

    IncludeType::URIType& IncludeType::
    uRI ()
    {
      return this->URI_.get ();
    }

    void IncludeType::
    uRI (const URIType& x)
    {
      this->URI_.set (x);
    }

    void IncludeType::
    uRI (::std::auto_ptr< URIType > x)
    {
      this->URI_.set (x);
    }

    const IncludeType::ReferencedDataOptional& IncludeType::
    referencedData () const
    {
      return this->referencedData_;
    }

    IncludeType::ReferencedDataOptional& IncludeType::
    referencedData ()
    {
      return this->referencedData_;
    }

    void IncludeType::
    referencedData (const ReferencedDataType& x)
    {
      this->referencedData_.set (x);
    }

    void IncludeType::
    referencedData (const ReferencedDataOptional& x)
    {
      this->referencedData_ = x;
    }


    // ReferenceInfoType
    // 

    const ReferenceInfoType::DigestMethodType& ReferenceInfoType::
    digestMethod () const
    {
      return this->DigestMethod_.get ();
    }

    ReferenceInfoType::DigestMethodType& ReferenceInfoType::
    digestMethod ()
    {
      return this->DigestMethod_.get ();
    }

    void ReferenceInfoType::
    digestMethod (const DigestMethodType& x)
    {
      this->DigestMethod_.set (x);
    }

    void ReferenceInfoType::
    digestMethod (::std::auto_ptr< DigestMethodType > x)
    {
      this->DigestMethod_.set (x);
    }

    const ReferenceInfoType::DigestValueType& ReferenceInfoType::
    digestValue () const
    {
      return this->DigestValue_.get ();
    }

    ReferenceInfoType::DigestValueType& ReferenceInfoType::
    digestValue ()
    {
      return this->DigestValue_.get ();
    }

    void ReferenceInfoType::
    digestValue (const DigestValueType& x)
    {
      this->DigestValue_.set (x);
    }

    void ReferenceInfoType::
    digestValue (::std::auto_ptr< DigestValueType > x)
    {
      this->DigestValue_.set (x);
    }

    const ReferenceInfoType::IdOptional& ReferenceInfoType::
    id () const
    {
      return this->Id_;
    }

    ReferenceInfoType::IdOptional& ReferenceInfoType::
    id ()
    {
      return this->Id_;
    }

    void ReferenceInfoType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void ReferenceInfoType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void ReferenceInfoType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }

    const ReferenceInfoType::URIOptional& ReferenceInfoType::
    uRI () const
    {
      return this->URI_;
    }

    ReferenceInfoType::URIOptional& ReferenceInfoType::
    uRI ()
    {
      return this->URI_;
    }

    void ReferenceInfoType::
    uRI (const URIType& x)
    {
      this->URI_.set (x);
    }

    void ReferenceInfoType::
    uRI (const URIOptional& x)
    {
      this->URI_ = x;
    }

    void ReferenceInfoType::
    uRI (::std::auto_ptr< URIType > x)
    {
      this->URI_.set (x);
    }


    // GenericTimeStampType
    // 

    const GenericTimeStampType::IncludeSequence& GenericTimeStampType::
    include () const
    {
      return this->Include_;
    }

    GenericTimeStampType::IncludeSequence& GenericTimeStampType::
    include ()
    {
      return this->Include_;
    }

    void GenericTimeStampType::
    include (const IncludeSequence& s)
    {
      this->Include_ = s;
    }

    const GenericTimeStampType::ReferenceInfoSequence& GenericTimeStampType::
    referenceInfo () const
    {
      return this->ReferenceInfo_;
    }

    GenericTimeStampType::ReferenceInfoSequence& GenericTimeStampType::
    referenceInfo ()
    {
      return this->ReferenceInfo_;
    }

    void GenericTimeStampType::
    referenceInfo (const ReferenceInfoSequence& s)
    {
      this->ReferenceInfo_ = s;
    }

    const GenericTimeStampType::CanonicalizationMethodOptional& GenericTimeStampType::
    canonicalizationMethod () const
    {
      return this->CanonicalizationMethod_;
    }

    GenericTimeStampType::CanonicalizationMethodOptional& GenericTimeStampType::
    canonicalizationMethod ()
    {
      return this->CanonicalizationMethod_;
    }

    void GenericTimeStampType::
    canonicalizationMethod (const CanonicalizationMethodType& x)
    {
      this->CanonicalizationMethod_.set (x);
    }

    void GenericTimeStampType::
    canonicalizationMethod (const CanonicalizationMethodOptional& x)
    {
      this->CanonicalizationMethod_ = x;
    }

    void GenericTimeStampType::
    canonicalizationMethod (::std::auto_ptr< CanonicalizationMethodType > x)
    {
      this->CanonicalizationMethod_.set (x);
    }

    const GenericTimeStampType::EncapsulatedTimeStampSequence& GenericTimeStampType::
    encapsulatedTimeStamp () const
    {
      return this->EncapsulatedTimeStamp_;
    }

    GenericTimeStampType::EncapsulatedTimeStampSequence& GenericTimeStampType::
    encapsulatedTimeStamp ()
    {
      return this->EncapsulatedTimeStamp_;
    }

    void GenericTimeStampType::
    encapsulatedTimeStamp (const EncapsulatedTimeStampSequence& s)
    {
      this->EncapsulatedTimeStamp_ = s;
    }

    const GenericTimeStampType::XMLTimeStampSequence& GenericTimeStampType::
    xMLTimeStamp () const
    {
      return this->XMLTimeStamp_;
    }

    GenericTimeStampType::XMLTimeStampSequence& GenericTimeStampType::
    xMLTimeStamp ()
    {
      return this->XMLTimeStamp_;
    }

    void GenericTimeStampType::
    xMLTimeStamp (const XMLTimeStampSequence& s)
    {
      this->XMLTimeStamp_ = s;
    }

    const GenericTimeStampType::IdOptional& GenericTimeStampType::
    id () const
    {
      return this->Id_;
    }

    GenericTimeStampType::IdOptional& GenericTimeStampType::
    id ()
    {
      return this->Id_;
    }

    void GenericTimeStampType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void GenericTimeStampType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void GenericTimeStampType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // XAdESTimeStampType
    // 

    const XAdESTimeStampType::IncludeSequence& XAdESTimeStampType::
    include () const
    {
      return this->Include_;
    }

    XAdESTimeStampType::IncludeSequence& XAdESTimeStampType::
    include ()
    {
      return this->Include_;
    }

    void XAdESTimeStampType::
    include (const IncludeSequence& s)
    {
      this->Include_ = s;
    }

    const XAdESTimeStampType::CanonicalizationMethodOptional& XAdESTimeStampType::
    canonicalizationMethod () const
    {
      return this->CanonicalizationMethod_;
    }

    XAdESTimeStampType::CanonicalizationMethodOptional& XAdESTimeStampType::
    canonicalizationMethod ()
    {
      return this->CanonicalizationMethod_;
    }

    void XAdESTimeStampType::
    canonicalizationMethod (const CanonicalizationMethodType& x)
    {
      this->CanonicalizationMethod_.set (x);
    }

    void XAdESTimeStampType::
    canonicalizationMethod (const CanonicalizationMethodOptional& x)
    {
      this->CanonicalizationMethod_ = x;
    }

    void XAdESTimeStampType::
    canonicalizationMethod (::std::auto_ptr< CanonicalizationMethodType > x)
    {
      this->CanonicalizationMethod_.set (x);
    }

    const XAdESTimeStampType::EncapsulatedTimeStampSequence& XAdESTimeStampType::
    encapsulatedTimeStamp () const
    {
      return this->EncapsulatedTimeStamp_;
    }

    XAdESTimeStampType::EncapsulatedTimeStampSequence& XAdESTimeStampType::
    encapsulatedTimeStamp ()
    {
      return this->EncapsulatedTimeStamp_;
    }

    void XAdESTimeStampType::
    encapsulatedTimeStamp (const EncapsulatedTimeStampSequence& s)
    {
      this->EncapsulatedTimeStamp_ = s;
    }

    const XAdESTimeStampType::XMLTimeStampSequence& XAdESTimeStampType::
    xMLTimeStamp () const
    {
      return this->XMLTimeStamp_;
    }

    XAdESTimeStampType::XMLTimeStampSequence& XAdESTimeStampType::
    xMLTimeStamp ()
    {
      return this->XMLTimeStamp_;
    }

    void XAdESTimeStampType::
    xMLTimeStamp (const XMLTimeStampSequence& s)
    {
      this->XMLTimeStamp_ = s;
    }

    const XAdESTimeStampType::IdOptional& XAdESTimeStampType::
    id () const
    {
      return this->Id_;
    }

    XAdESTimeStampType::IdOptional& XAdESTimeStampType::
    id ()
    {
      return this->Id_;
    }

    void XAdESTimeStampType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void XAdESTimeStampType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void XAdESTimeStampType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // OtherTimeStampType
    // 


    // QualifyingPropertiesType
    // 

    const QualifyingPropertiesType::SignedPropertiesOptional& QualifyingPropertiesType::
    signedProperties () const
    {
      return this->SignedProperties_;
    }

    QualifyingPropertiesType::SignedPropertiesOptional& QualifyingPropertiesType::
    signedProperties ()
    {
      return this->SignedProperties_;
    }

    void QualifyingPropertiesType::
    signedProperties (const SignedPropertiesType& x)
    {
      this->SignedProperties_.set (x);
    }

    void QualifyingPropertiesType::
    signedProperties (const SignedPropertiesOptional& x)
    {
      this->SignedProperties_ = x;
    }

    void QualifyingPropertiesType::
    signedProperties (::std::auto_ptr< SignedPropertiesType > x)
    {
      this->SignedProperties_.set (x);
    }

    const QualifyingPropertiesType::UnsignedPropertiesOptional& QualifyingPropertiesType::
    unsignedProperties () const
    {
      return this->UnsignedProperties_;
    }

    QualifyingPropertiesType::UnsignedPropertiesOptional& QualifyingPropertiesType::
    unsignedProperties ()
    {
      return this->UnsignedProperties_;
    }

    void QualifyingPropertiesType::
    unsignedProperties (const UnsignedPropertiesType& x)
    {
      this->UnsignedProperties_.set (x);
    }

    void QualifyingPropertiesType::
    unsignedProperties (const UnsignedPropertiesOptional& x)
    {
      this->UnsignedProperties_ = x;
    }

    void QualifyingPropertiesType::
    unsignedProperties (::std::auto_ptr< UnsignedPropertiesType > x)
    {
      this->UnsignedProperties_.set (x);
    }

    const QualifyingPropertiesType::TargetType& QualifyingPropertiesType::
    target () const
    {
      return this->Target_.get ();
    }

    QualifyingPropertiesType::TargetType& QualifyingPropertiesType::
    target ()
    {
      return this->Target_.get ();
    }

    void QualifyingPropertiesType::
    target (const TargetType& x)
    {
      this->Target_.set (x);
    }

    void QualifyingPropertiesType::
    target (::std::auto_ptr< TargetType > x)
    {
      this->Target_.set (x);
    }

    const QualifyingPropertiesType::IdOptional& QualifyingPropertiesType::
    id () const
    {
      return this->Id_;
    }

    QualifyingPropertiesType::IdOptional& QualifyingPropertiesType::
    id ()
    {
      return this->Id_;
    }

    void QualifyingPropertiesType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void QualifyingPropertiesType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void QualifyingPropertiesType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // SignedPropertiesType
    // 

    const SignedPropertiesType::SignedSignaturePropertiesType& SignedPropertiesType::
    signedSignatureProperties () const
    {
      return this->SignedSignatureProperties_.get ();
    }

    SignedPropertiesType::SignedSignaturePropertiesType& SignedPropertiesType::
    signedSignatureProperties ()
    {
      return this->SignedSignatureProperties_.get ();
    }

    void SignedPropertiesType::
    signedSignatureProperties (const SignedSignaturePropertiesType& x)
    {
      this->SignedSignatureProperties_.set (x);
    }

    void SignedPropertiesType::
    signedSignatureProperties (::std::auto_ptr< SignedSignaturePropertiesType > x)
    {
      this->SignedSignatureProperties_.set (x);
    }

    const SignedPropertiesType::SignedDataObjectPropertiesOptional& SignedPropertiesType::
    signedDataObjectProperties () const
    {
      return this->SignedDataObjectProperties_;
    }

    SignedPropertiesType::SignedDataObjectPropertiesOptional& SignedPropertiesType::
    signedDataObjectProperties ()
    {
      return this->SignedDataObjectProperties_;
    }

    void SignedPropertiesType::
    signedDataObjectProperties (const SignedDataObjectPropertiesType& x)
    {
      this->SignedDataObjectProperties_.set (x);
    }

    void SignedPropertiesType::
    signedDataObjectProperties (const SignedDataObjectPropertiesOptional& x)
    {
      this->SignedDataObjectProperties_ = x;
    }

    void SignedPropertiesType::
    signedDataObjectProperties (::std::auto_ptr< SignedDataObjectPropertiesType > x)
    {
      this->SignedDataObjectProperties_.set (x);
    }

    const SignedPropertiesType::IdOptional& SignedPropertiesType::
    id () const
    {
      return this->Id_;
    }

    SignedPropertiesType::IdOptional& SignedPropertiesType::
    id ()
    {
      return this->Id_;
    }

    void SignedPropertiesType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void SignedPropertiesType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void SignedPropertiesType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // UnsignedPropertiesType
    // 

    const UnsignedPropertiesType::UnsignedSignaturePropertiesOptional& UnsignedPropertiesType::
    unsignedSignatureProperties () const
    {
      return this->UnsignedSignatureProperties_;
    }

    UnsignedPropertiesType::UnsignedSignaturePropertiesOptional& UnsignedPropertiesType::
    unsignedSignatureProperties ()
    {
      return this->UnsignedSignatureProperties_;
    }

    void UnsignedPropertiesType::
    unsignedSignatureProperties (const UnsignedSignaturePropertiesType& x)
    {
      this->UnsignedSignatureProperties_.set (x);
    }

    void UnsignedPropertiesType::
    unsignedSignatureProperties (const UnsignedSignaturePropertiesOptional& x)
    {
      this->UnsignedSignatureProperties_ = x;
    }

    void UnsignedPropertiesType::
    unsignedSignatureProperties (::std::auto_ptr< UnsignedSignaturePropertiesType > x)
    {
      this->UnsignedSignatureProperties_.set (x);
    }

    const UnsignedPropertiesType::UnsignedDataObjectPropertiesOptional& UnsignedPropertiesType::
    unsignedDataObjectProperties () const
    {
      return this->UnsignedDataObjectProperties_;
    }

    UnsignedPropertiesType::UnsignedDataObjectPropertiesOptional& UnsignedPropertiesType::
    unsignedDataObjectProperties ()
    {
      return this->UnsignedDataObjectProperties_;
    }

    void UnsignedPropertiesType::
    unsignedDataObjectProperties (const UnsignedDataObjectPropertiesType& x)
    {
      this->UnsignedDataObjectProperties_.set (x);
    }

    void UnsignedPropertiesType::
    unsignedDataObjectProperties (const UnsignedDataObjectPropertiesOptional& x)
    {
      this->UnsignedDataObjectProperties_ = x;
    }

    void UnsignedPropertiesType::
    unsignedDataObjectProperties (::std::auto_ptr< UnsignedDataObjectPropertiesType > x)
    {
      this->UnsignedDataObjectProperties_.set (x);
    }

    const UnsignedPropertiesType::IdOptional& UnsignedPropertiesType::
    id () const
    {
      return this->Id_;
    }

    UnsignedPropertiesType::IdOptional& UnsignedPropertiesType::
    id ()
    {
      return this->Id_;
    }

    void UnsignedPropertiesType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void UnsignedPropertiesType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void UnsignedPropertiesType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // SignedSignaturePropertiesType
    // 

    const SignedSignaturePropertiesType::SigningTimeOptional& SignedSignaturePropertiesType::
    signingTime () const
    {
      return this->SigningTime_;
    }

    SignedSignaturePropertiesType::SigningTimeOptional& SignedSignaturePropertiesType::
    signingTime ()
    {
      return this->SigningTime_;
    }

    void SignedSignaturePropertiesType::
    signingTime (const SigningTimeType& x)
    {
      this->SigningTime_.set (x);
    }

    void SignedSignaturePropertiesType::
    signingTime (const SigningTimeOptional& x)
    {
      this->SigningTime_ = x;
    }

    void SignedSignaturePropertiesType::
    signingTime (::std::auto_ptr< SigningTimeType > x)
    {
      this->SigningTime_.set (x);
    }

    const SignedSignaturePropertiesType::SigningCertificateOptional& SignedSignaturePropertiesType::
    signingCertificate () const
    {
      return this->SigningCertificate_;
    }

    SignedSignaturePropertiesType::SigningCertificateOptional& SignedSignaturePropertiesType::
    signingCertificate ()
    {
      return this->SigningCertificate_;
    }

    void SignedSignaturePropertiesType::
    signingCertificate (const SigningCertificateType& x)
    {
      this->SigningCertificate_.set (x);
    }

    void SignedSignaturePropertiesType::
    signingCertificate (const SigningCertificateOptional& x)
    {
      this->SigningCertificate_ = x;
    }

    void SignedSignaturePropertiesType::
    signingCertificate (::std::auto_ptr< SigningCertificateType > x)
    {
      this->SigningCertificate_.set (x);
    }

    const SignedSignaturePropertiesType::SignaturePolicyIdentifierOptional& SignedSignaturePropertiesType::
    signaturePolicyIdentifier () const
    {
      return this->SignaturePolicyIdentifier_;
    }

    SignedSignaturePropertiesType::SignaturePolicyIdentifierOptional& SignedSignaturePropertiesType::
    signaturePolicyIdentifier ()
    {
      return this->SignaturePolicyIdentifier_;
    }

    void SignedSignaturePropertiesType::
    signaturePolicyIdentifier (const SignaturePolicyIdentifierType& x)
    {
      this->SignaturePolicyIdentifier_.set (x);
    }

    void SignedSignaturePropertiesType::
    signaturePolicyIdentifier (const SignaturePolicyIdentifierOptional& x)
    {
      this->SignaturePolicyIdentifier_ = x;
    }

    void SignedSignaturePropertiesType::
    signaturePolicyIdentifier (::std::auto_ptr< SignaturePolicyIdentifierType > x)
    {
      this->SignaturePolicyIdentifier_.set (x);
    }

    const SignedSignaturePropertiesType::SignatureProductionPlaceOptional& SignedSignaturePropertiesType::
    signatureProductionPlace () const
    {
      return this->SignatureProductionPlace_;
    }

    SignedSignaturePropertiesType::SignatureProductionPlaceOptional& SignedSignaturePropertiesType::
    signatureProductionPlace ()
    {
      return this->SignatureProductionPlace_;
    }

    void SignedSignaturePropertiesType::
    signatureProductionPlace (const SignatureProductionPlaceType& x)
    {
      this->SignatureProductionPlace_.set (x);
    }

    void SignedSignaturePropertiesType::
    signatureProductionPlace (const SignatureProductionPlaceOptional& x)
    {
      this->SignatureProductionPlace_ = x;
    }

    void SignedSignaturePropertiesType::
    signatureProductionPlace (::std::auto_ptr< SignatureProductionPlaceType > x)
    {
      this->SignatureProductionPlace_.set (x);
    }

    const SignedSignaturePropertiesType::SignerRoleOptional& SignedSignaturePropertiesType::
    signerRole () const
    {
      return this->SignerRole_;
    }

    SignedSignaturePropertiesType::SignerRoleOptional& SignedSignaturePropertiesType::
    signerRole ()
    {
      return this->SignerRole_;
    }

    void SignedSignaturePropertiesType::
    signerRole (const SignerRoleType& x)
    {
      this->SignerRole_.set (x);
    }

    void SignedSignaturePropertiesType::
    signerRole (const SignerRoleOptional& x)
    {
      this->SignerRole_ = x;
    }

    void SignedSignaturePropertiesType::
    signerRole (::std::auto_ptr< SignerRoleType > x)
    {
      this->SignerRole_.set (x);
    }

    const SignedSignaturePropertiesType::IdOptional& SignedSignaturePropertiesType::
    id () const
    {
      return this->Id_;
    }

    SignedSignaturePropertiesType::IdOptional& SignedSignaturePropertiesType::
    id ()
    {
      return this->Id_;
    }

    void SignedSignaturePropertiesType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void SignedSignaturePropertiesType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void SignedSignaturePropertiesType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // SignedDataObjectPropertiesType
    // 

    const SignedDataObjectPropertiesType::DataObjectFormatSequence& SignedDataObjectPropertiesType::
    dataObjectFormat () const
    {
      return this->DataObjectFormat_;
    }

    SignedDataObjectPropertiesType::DataObjectFormatSequence& SignedDataObjectPropertiesType::
    dataObjectFormat ()
    {
      return this->DataObjectFormat_;
    }

    void SignedDataObjectPropertiesType::
    dataObjectFormat (const DataObjectFormatSequence& s)
    {
      this->DataObjectFormat_ = s;
    }

    const SignedDataObjectPropertiesType::CommitmentTypeIndicationSequence& SignedDataObjectPropertiesType::
    commitmentTypeIndication () const
    {
      return this->CommitmentTypeIndication_;
    }

    SignedDataObjectPropertiesType::CommitmentTypeIndicationSequence& SignedDataObjectPropertiesType::
    commitmentTypeIndication ()
    {
      return this->CommitmentTypeIndication_;
    }

    void SignedDataObjectPropertiesType::
    commitmentTypeIndication (const CommitmentTypeIndicationSequence& s)
    {
      this->CommitmentTypeIndication_ = s;
    }

    const SignedDataObjectPropertiesType::AllDataObjectsTimeStampSequence& SignedDataObjectPropertiesType::
    allDataObjectsTimeStamp () const
    {
      return this->AllDataObjectsTimeStamp_;
    }

    SignedDataObjectPropertiesType::AllDataObjectsTimeStampSequence& SignedDataObjectPropertiesType::
    allDataObjectsTimeStamp ()
    {
      return this->AllDataObjectsTimeStamp_;
    }

    void SignedDataObjectPropertiesType::
    allDataObjectsTimeStamp (const AllDataObjectsTimeStampSequence& s)
    {
      this->AllDataObjectsTimeStamp_ = s;
    }

    const SignedDataObjectPropertiesType::IndividualDataObjectsTimeStampSequence& SignedDataObjectPropertiesType::
    individualDataObjectsTimeStamp () const
    {
      return this->IndividualDataObjectsTimeStamp_;
    }

    SignedDataObjectPropertiesType::IndividualDataObjectsTimeStampSequence& SignedDataObjectPropertiesType::
    individualDataObjectsTimeStamp ()
    {
      return this->IndividualDataObjectsTimeStamp_;
    }

    void SignedDataObjectPropertiesType::
    individualDataObjectsTimeStamp (const IndividualDataObjectsTimeStampSequence& s)
    {
      this->IndividualDataObjectsTimeStamp_ = s;
    }

    const SignedDataObjectPropertiesType::IdOptional& SignedDataObjectPropertiesType::
    id () const
    {
      return this->Id_;
    }

    SignedDataObjectPropertiesType::IdOptional& SignedDataObjectPropertiesType::
    id ()
    {
      return this->Id_;
    }

    void SignedDataObjectPropertiesType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void SignedDataObjectPropertiesType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void SignedDataObjectPropertiesType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // UnsignedSignaturePropertiesType
    // 

    const UnsignedSignaturePropertiesType::CounterSignatureSequence& UnsignedSignaturePropertiesType::
    counterSignature () const
    {
      return this->CounterSignature_;
    }

    UnsignedSignaturePropertiesType::CounterSignatureSequence& UnsignedSignaturePropertiesType::
    counterSignature ()
    {
      return this->CounterSignature_;
    }

    void UnsignedSignaturePropertiesType::
    counterSignature (const CounterSignatureSequence& s)
    {
      this->CounterSignature_ = s;
    }

    const UnsignedSignaturePropertiesType::SignatureTimeStampSequence& UnsignedSignaturePropertiesType::
    signatureTimeStamp () const
    {
      return this->SignatureTimeStamp_;
    }

    UnsignedSignaturePropertiesType::SignatureTimeStampSequence& UnsignedSignaturePropertiesType::
    signatureTimeStamp ()
    {
      return this->SignatureTimeStamp_;
    }

    void UnsignedSignaturePropertiesType::
    signatureTimeStamp (const SignatureTimeStampSequence& s)
    {
      this->SignatureTimeStamp_ = s;
    }

    const UnsignedSignaturePropertiesType::CompleteCertificateRefsSequence& UnsignedSignaturePropertiesType::
    completeCertificateRefs () const
    {
      return this->CompleteCertificateRefs_;
    }

    UnsignedSignaturePropertiesType::CompleteCertificateRefsSequence& UnsignedSignaturePropertiesType::
    completeCertificateRefs ()
    {
      return this->CompleteCertificateRefs_;
    }

    void UnsignedSignaturePropertiesType::
    completeCertificateRefs (const CompleteCertificateRefsSequence& s)
    {
      this->CompleteCertificateRefs_ = s;
    }

    const UnsignedSignaturePropertiesType::CompleteRevocationRefsSequence& UnsignedSignaturePropertiesType::
    completeRevocationRefs () const
    {
      return this->CompleteRevocationRefs_;
    }

    UnsignedSignaturePropertiesType::CompleteRevocationRefsSequence& UnsignedSignaturePropertiesType::
    completeRevocationRefs ()
    {
      return this->CompleteRevocationRefs_;
    }

    void UnsignedSignaturePropertiesType::
    completeRevocationRefs (const CompleteRevocationRefsSequence& s)
    {
      this->CompleteRevocationRefs_ = s;
    }

    const UnsignedSignaturePropertiesType::AttributeCertificateRefsSequence& UnsignedSignaturePropertiesType::
    attributeCertificateRefs () const
    {
      return this->AttributeCertificateRefs_;
    }

    UnsignedSignaturePropertiesType::AttributeCertificateRefsSequence& UnsignedSignaturePropertiesType::
    attributeCertificateRefs ()
    {
      return this->AttributeCertificateRefs_;
    }

    void UnsignedSignaturePropertiesType::
    attributeCertificateRefs (const AttributeCertificateRefsSequence& s)
    {
      this->AttributeCertificateRefs_ = s;
    }

    const UnsignedSignaturePropertiesType::AttributeRevocationRefsSequence& UnsignedSignaturePropertiesType::
    attributeRevocationRefs () const
    {
      return this->AttributeRevocationRefs_;
    }

    UnsignedSignaturePropertiesType::AttributeRevocationRefsSequence& UnsignedSignaturePropertiesType::
    attributeRevocationRefs ()
    {
      return this->AttributeRevocationRefs_;
    }

    void UnsignedSignaturePropertiesType::
    attributeRevocationRefs (const AttributeRevocationRefsSequence& s)
    {
      this->AttributeRevocationRefs_ = s;
    }

    const UnsignedSignaturePropertiesType::SigAndRefsTimeStampSequence& UnsignedSignaturePropertiesType::
    sigAndRefsTimeStamp () const
    {
      return this->SigAndRefsTimeStamp_;
    }

    UnsignedSignaturePropertiesType::SigAndRefsTimeStampSequence& UnsignedSignaturePropertiesType::
    sigAndRefsTimeStamp ()
    {
      return this->SigAndRefsTimeStamp_;
    }

    void UnsignedSignaturePropertiesType::
    sigAndRefsTimeStamp (const SigAndRefsTimeStampSequence& s)
    {
      this->SigAndRefsTimeStamp_ = s;
    }

    const UnsignedSignaturePropertiesType::RefsOnlyTimeStampSequence& UnsignedSignaturePropertiesType::
    refsOnlyTimeStamp () const
    {
      return this->RefsOnlyTimeStamp_;
    }

    UnsignedSignaturePropertiesType::RefsOnlyTimeStampSequence& UnsignedSignaturePropertiesType::
    refsOnlyTimeStamp ()
    {
      return this->RefsOnlyTimeStamp_;
    }

    void UnsignedSignaturePropertiesType::
    refsOnlyTimeStamp (const RefsOnlyTimeStampSequence& s)
    {
      this->RefsOnlyTimeStamp_ = s;
    }

    const UnsignedSignaturePropertiesType::CertificateValuesSequence& UnsignedSignaturePropertiesType::
    certificateValues () const
    {
      return this->CertificateValues_;
    }

    UnsignedSignaturePropertiesType::CertificateValuesSequence& UnsignedSignaturePropertiesType::
    certificateValues ()
    {
      return this->CertificateValues_;
    }

    void UnsignedSignaturePropertiesType::
    certificateValues (const CertificateValuesSequence& s)
    {
      this->CertificateValues_ = s;
    }

    const UnsignedSignaturePropertiesType::RevocationValuesSequence& UnsignedSignaturePropertiesType::
    revocationValues () const
    {
      return this->RevocationValues_;
    }

    UnsignedSignaturePropertiesType::RevocationValuesSequence& UnsignedSignaturePropertiesType::
    revocationValues ()
    {
      return this->RevocationValues_;
    }

    void UnsignedSignaturePropertiesType::
    revocationValues (const RevocationValuesSequence& s)
    {
      this->RevocationValues_ = s;
    }

    const UnsignedSignaturePropertiesType::AttrAuthoritiesCertValuesSequence& UnsignedSignaturePropertiesType::
    attrAuthoritiesCertValues () const
    {
      return this->AttrAuthoritiesCertValues_;
    }

    UnsignedSignaturePropertiesType::AttrAuthoritiesCertValuesSequence& UnsignedSignaturePropertiesType::
    attrAuthoritiesCertValues ()
    {
      return this->AttrAuthoritiesCertValues_;
    }

    void UnsignedSignaturePropertiesType::
    attrAuthoritiesCertValues (const AttrAuthoritiesCertValuesSequence& s)
    {
      this->AttrAuthoritiesCertValues_ = s;
    }

    const UnsignedSignaturePropertiesType::AttributeRevocationValuesSequence& UnsignedSignaturePropertiesType::
    attributeRevocationValues () const
    {
      return this->AttributeRevocationValues_;
    }

    UnsignedSignaturePropertiesType::AttributeRevocationValuesSequence& UnsignedSignaturePropertiesType::
    attributeRevocationValues ()
    {
      return this->AttributeRevocationValues_;
    }

    void UnsignedSignaturePropertiesType::
    attributeRevocationValues (const AttributeRevocationValuesSequence& s)
    {
      this->AttributeRevocationValues_ = s;
    }

    const UnsignedSignaturePropertiesType::ArchiveTimeStampSequence& UnsignedSignaturePropertiesType::
    archiveTimeStamp () const
    {
      return this->ArchiveTimeStamp_;
    }

    UnsignedSignaturePropertiesType::ArchiveTimeStampSequence& UnsignedSignaturePropertiesType::
    archiveTimeStamp ()
    {
      return this->ArchiveTimeStamp_;
    }

    void UnsignedSignaturePropertiesType::
    archiveTimeStamp (const ArchiveTimeStampSequence& s)
    {
      this->ArchiveTimeStamp_ = s;
    }

    const UnsignedSignaturePropertiesType::IdOptional& UnsignedSignaturePropertiesType::
    id () const
    {
      return this->Id_;
    }

    UnsignedSignaturePropertiesType::IdOptional& UnsignedSignaturePropertiesType::
    id ()
    {
      return this->Id_;
    }

    void UnsignedSignaturePropertiesType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void UnsignedSignaturePropertiesType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void UnsignedSignaturePropertiesType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // UnsignedDataObjectPropertiesType
    // 

    const UnsignedDataObjectPropertiesType::UnsignedDataObjectPropertySequence& UnsignedDataObjectPropertiesType::
    unsignedDataObjectProperty () const
    {
      return this->UnsignedDataObjectProperty_;
    }

    UnsignedDataObjectPropertiesType::UnsignedDataObjectPropertySequence& UnsignedDataObjectPropertiesType::
    unsignedDataObjectProperty ()
    {
      return this->UnsignedDataObjectProperty_;
    }

    void UnsignedDataObjectPropertiesType::
    unsignedDataObjectProperty (const UnsignedDataObjectPropertySequence& s)
    {
      this->UnsignedDataObjectProperty_ = s;
    }

    const UnsignedDataObjectPropertiesType::IdOptional& UnsignedDataObjectPropertiesType::
    id () const
    {
      return this->Id_;
    }

    UnsignedDataObjectPropertiesType::IdOptional& UnsignedDataObjectPropertiesType::
    id ()
    {
      return this->Id_;
    }

    void UnsignedDataObjectPropertiesType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void UnsignedDataObjectPropertiesType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void UnsignedDataObjectPropertiesType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // QualifyingPropertiesReferenceType
    // 

    const QualifyingPropertiesReferenceType::URIType& QualifyingPropertiesReferenceType::
    uRI () const
    {
      return this->URI_.get ();
    }

    QualifyingPropertiesReferenceType::URIType& QualifyingPropertiesReferenceType::
    uRI ()
    {
      return this->URI_.get ();
    }

    void QualifyingPropertiesReferenceType::
    uRI (const URIType& x)
    {
      this->URI_.set (x);
    }

    void QualifyingPropertiesReferenceType::
    uRI (::std::auto_ptr< URIType > x)
    {
      this->URI_.set (x);
    }

    const QualifyingPropertiesReferenceType::IdOptional& QualifyingPropertiesReferenceType::
    id () const
    {
      return this->Id_;
    }

    QualifyingPropertiesReferenceType::IdOptional& QualifyingPropertiesReferenceType::
    id ()
    {
      return this->Id_;
    }

    void QualifyingPropertiesReferenceType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void QualifyingPropertiesReferenceType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void QualifyingPropertiesReferenceType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // CertIDListType
    // 

    const CertIDListType::CertSequence& CertIDListType::
    cert () const
    {
      return this->Cert_;
    }

    CertIDListType::CertSequence& CertIDListType::
    cert ()
    {
      return this->Cert_;
    }

    void CertIDListType::
    cert (const CertSequence& s)
    {
      this->Cert_ = s;
    }


    // CertIDType
    // 

    const CertIDType::CertDigestType& CertIDType::
    certDigest () const
    {
      return this->CertDigest_.get ();
    }

    CertIDType::CertDigestType& CertIDType::
    certDigest ()
    {
      return this->CertDigest_.get ();
    }

    void CertIDType::
    certDigest (const CertDigestType& x)
    {
      this->CertDigest_.set (x);
    }

    void CertIDType::
    certDigest (::std::auto_ptr< CertDigestType > x)
    {
      this->CertDigest_.set (x);
    }

    const CertIDType::IssuerSerialType& CertIDType::
    issuerSerial () const
    {
      return this->IssuerSerial_.get ();
    }

    CertIDType::IssuerSerialType& CertIDType::
    issuerSerial ()
    {
      return this->IssuerSerial_.get ();
    }

    void CertIDType::
    issuerSerial (const IssuerSerialType& x)
    {
      this->IssuerSerial_.set (x);
    }

    void CertIDType::
    issuerSerial (::std::auto_ptr< IssuerSerialType > x)
    {
      this->IssuerSerial_.set (x);
    }

    const CertIDType::URIOptional& CertIDType::
    uRI () const
    {
      return this->URI_;
    }

    CertIDType::URIOptional& CertIDType::
    uRI ()
    {
      return this->URI_;
    }

    void CertIDType::
    uRI (const URIType& x)
    {
      this->URI_.set (x);
    }

    void CertIDType::
    uRI (const URIOptional& x)
    {
      this->URI_ = x;
    }

    void CertIDType::
    uRI (::std::auto_ptr< URIType > x)
    {
      this->URI_.set (x);
    }


    // DigestAlgAndValueType
    // 

    const DigestAlgAndValueType::DigestMethodType& DigestAlgAndValueType::
    digestMethod () const
    {
      return this->DigestMethod_.get ();
    }

    DigestAlgAndValueType::DigestMethodType& DigestAlgAndValueType::
    digestMethod ()
    {
      return this->DigestMethod_.get ();
    }

    void DigestAlgAndValueType::
    digestMethod (const DigestMethodType& x)
    {
      this->DigestMethod_.set (x);
    }

    void DigestAlgAndValueType::
    digestMethod (::std::auto_ptr< DigestMethodType > x)
    {
      this->DigestMethod_.set (x);
    }

    const DigestAlgAndValueType::DigestValueType& DigestAlgAndValueType::
    digestValue () const
    {
      return this->DigestValue_.get ();
    }

    DigestAlgAndValueType::DigestValueType& DigestAlgAndValueType::
    digestValue ()
    {
      return this->DigestValue_.get ();
    }

    void DigestAlgAndValueType::
    digestValue (const DigestValueType& x)
    {
      this->DigestValue_.set (x);
    }

    void DigestAlgAndValueType::
    digestValue (::std::auto_ptr< DigestValueType > x)
    {
      this->DigestValue_.set (x);
    }


    // SignaturePolicyIdentifierType
    // 

    const SignaturePolicyIdentifierType::SignaturePolicyIdOptional& SignaturePolicyIdentifierType::
    signaturePolicyId () const
    {
      return this->SignaturePolicyId_;
    }

    SignaturePolicyIdentifierType::SignaturePolicyIdOptional& SignaturePolicyIdentifierType::
    signaturePolicyId ()
    {
      return this->SignaturePolicyId_;
    }

    void SignaturePolicyIdentifierType::
    signaturePolicyId (const SignaturePolicyIdType& x)
    {
      this->SignaturePolicyId_.set (x);
    }

    void SignaturePolicyIdentifierType::
    signaturePolicyId (const SignaturePolicyIdOptional& x)
    {
      this->SignaturePolicyId_ = x;
    }

    void SignaturePolicyIdentifierType::
    signaturePolicyId (::std::auto_ptr< SignaturePolicyIdType > x)
    {
      this->SignaturePolicyId_.set (x);
    }

    const SignaturePolicyIdentifierType::SignaturePolicyImpliedOptional& SignaturePolicyIdentifierType::
    signaturePolicyImplied () const
    {
      return this->SignaturePolicyImplied_;
    }

    SignaturePolicyIdentifierType::SignaturePolicyImpliedOptional& SignaturePolicyIdentifierType::
    signaturePolicyImplied ()
    {
      return this->SignaturePolicyImplied_;
    }

    void SignaturePolicyIdentifierType::
    signaturePolicyImplied (const SignaturePolicyImpliedType& x)
    {
      this->SignaturePolicyImplied_.set (x);
    }

    void SignaturePolicyIdentifierType::
    signaturePolicyImplied (const SignaturePolicyImpliedOptional& x)
    {
      this->SignaturePolicyImplied_ = x;
    }

    void SignaturePolicyIdentifierType::
    signaturePolicyImplied (::std::auto_ptr< SignaturePolicyImpliedType > x)
    {
      this->SignaturePolicyImplied_.set (x);
    }


    // SignaturePolicyIdType
    // 

    const SignaturePolicyIdType::SigPolicyIdType& SignaturePolicyIdType::
    sigPolicyId () const
    {
      return this->SigPolicyId_.get ();
    }

    SignaturePolicyIdType::SigPolicyIdType& SignaturePolicyIdType::
    sigPolicyId ()
    {
      return this->SigPolicyId_.get ();
    }

    void SignaturePolicyIdType::
    sigPolicyId (const SigPolicyIdType& x)
    {
      this->SigPolicyId_.set (x);
    }

    void SignaturePolicyIdType::
    sigPolicyId (::std::auto_ptr< SigPolicyIdType > x)
    {
      this->SigPolicyId_.set (x);
    }

    const SignaturePolicyIdType::TransformsOptional& SignaturePolicyIdType::
    transforms () const
    {
      return this->Transforms_;
    }

    SignaturePolicyIdType::TransformsOptional& SignaturePolicyIdType::
    transforms ()
    {
      return this->Transforms_;
    }

    void SignaturePolicyIdType::
    transforms (const TransformsType& x)
    {
      this->Transforms_.set (x);
    }

    void SignaturePolicyIdType::
    transforms (const TransformsOptional& x)
    {
      this->Transforms_ = x;
    }

    void SignaturePolicyIdType::
    transforms (::std::auto_ptr< TransformsType > x)
    {
      this->Transforms_.set (x);
    }

    const SignaturePolicyIdType::SigPolicyHashType& SignaturePolicyIdType::
    sigPolicyHash () const
    {
      return this->SigPolicyHash_.get ();
    }

    SignaturePolicyIdType::SigPolicyHashType& SignaturePolicyIdType::
    sigPolicyHash ()
    {
      return this->SigPolicyHash_.get ();
    }

    void SignaturePolicyIdType::
    sigPolicyHash (const SigPolicyHashType& x)
    {
      this->SigPolicyHash_.set (x);
    }

    void SignaturePolicyIdType::
    sigPolicyHash (::std::auto_ptr< SigPolicyHashType > x)
    {
      this->SigPolicyHash_.set (x);
    }

    const SignaturePolicyIdType::SigPolicyQualifiersOptional& SignaturePolicyIdType::
    sigPolicyQualifiers () const
    {
      return this->SigPolicyQualifiers_;
    }

    SignaturePolicyIdType::SigPolicyQualifiersOptional& SignaturePolicyIdType::
    sigPolicyQualifiers ()
    {
      return this->SigPolicyQualifiers_;
    }

    void SignaturePolicyIdType::
    sigPolicyQualifiers (const SigPolicyQualifiersType& x)
    {
      this->SigPolicyQualifiers_.set (x);
    }

    void SignaturePolicyIdType::
    sigPolicyQualifiers (const SigPolicyQualifiersOptional& x)
    {
      this->SigPolicyQualifiers_ = x;
    }

    void SignaturePolicyIdType::
    sigPolicyQualifiers (::std::auto_ptr< SigPolicyQualifiersType > x)
    {
      this->SigPolicyQualifiers_.set (x);
    }


    // SigPolicyQualifiersListType
    // 

    const SigPolicyQualifiersListType::SigPolicyQualifierSequence& SigPolicyQualifiersListType::
    sigPolicyQualifier () const
    {
      return this->SigPolicyQualifier_;
    }

    SigPolicyQualifiersListType::SigPolicyQualifierSequence& SigPolicyQualifiersListType::
    sigPolicyQualifier ()
    {
      return this->SigPolicyQualifier_;
    }

    void SigPolicyQualifiersListType::
    sigPolicyQualifier (const SigPolicyQualifierSequence& s)
    {
      this->SigPolicyQualifier_ = s;
    }


    // SPUserNoticeType
    // 

    const SPUserNoticeType::NoticeRefOptional& SPUserNoticeType::
    noticeRef () const
    {
      return this->NoticeRef_;
    }

    SPUserNoticeType::NoticeRefOptional& SPUserNoticeType::
    noticeRef ()
    {
      return this->NoticeRef_;
    }

    void SPUserNoticeType::
    noticeRef (const NoticeRefType& x)
    {
      this->NoticeRef_.set (x);
    }

    void SPUserNoticeType::
    noticeRef (const NoticeRefOptional& x)
    {
      this->NoticeRef_ = x;
    }

    void SPUserNoticeType::
    noticeRef (::std::auto_ptr< NoticeRefType > x)
    {
      this->NoticeRef_.set (x);
    }

    const SPUserNoticeType::ExplicitTextOptional& SPUserNoticeType::
    explicitText () const
    {
      return this->ExplicitText_;
    }

    SPUserNoticeType::ExplicitTextOptional& SPUserNoticeType::
    explicitText ()
    {
      return this->ExplicitText_;
    }

    void SPUserNoticeType::
    explicitText (const ExplicitTextType& x)
    {
      this->ExplicitText_.set (x);
    }

    void SPUserNoticeType::
    explicitText (const ExplicitTextOptional& x)
    {
      this->ExplicitText_ = x;
    }

    void SPUserNoticeType::
    explicitText (::std::auto_ptr< ExplicitTextType > x)
    {
      this->ExplicitText_.set (x);
    }


    // NoticeReferenceType
    // 

    const NoticeReferenceType::OrganizationType& NoticeReferenceType::
    organization () const
    {
      return this->Organization_.get ();
    }

    NoticeReferenceType::OrganizationType& NoticeReferenceType::
    organization ()
    {
      return this->Organization_.get ();
    }

    void NoticeReferenceType::
    organization (const OrganizationType& x)
    {
      this->Organization_.set (x);
    }

    void NoticeReferenceType::
    organization (::std::auto_ptr< OrganizationType > x)
    {
      this->Organization_.set (x);
    }

    const NoticeReferenceType::NoticeNumbersType& NoticeReferenceType::
    noticeNumbers () const
    {
      return this->NoticeNumbers_.get ();
    }

    NoticeReferenceType::NoticeNumbersType& NoticeReferenceType::
    noticeNumbers ()
    {
      return this->NoticeNumbers_.get ();
    }

    void NoticeReferenceType::
    noticeNumbers (const NoticeNumbersType& x)
    {
      this->NoticeNumbers_.set (x);
    }

    void NoticeReferenceType::
    noticeNumbers (::std::auto_ptr< NoticeNumbersType > x)
    {
      this->NoticeNumbers_.set (x);
    }


    // IntegerListType
    // 

    const IntegerListType::IntSequence& IntegerListType::
    int_ () const
    {
      return this->int__;
    }

    IntegerListType::IntSequence& IntegerListType::
    int_ ()
    {
      return this->int__;
    }

    void IntegerListType::
    int_ (const IntSequence& s)
    {
      this->int__ = s;
    }


    // CounterSignatureType
    // 

    const CounterSignatureType::SignatureType& CounterSignatureType::
    signature () const
    {
      return this->Signature_.get ();
    }

    CounterSignatureType::SignatureType& CounterSignatureType::
    signature ()
    {
      return this->Signature_.get ();
    }

    void CounterSignatureType::
    signature (const SignatureType& x)
    {
      this->Signature_.set (x);
    }

    void CounterSignatureType::
    signature (::std::auto_ptr< SignatureType > x)
    {
      this->Signature_.set (x);
    }


    // DataObjectFormatType
    // 

    const DataObjectFormatType::DescriptionOptional& DataObjectFormatType::
    description () const
    {
      return this->Description_;
    }

    DataObjectFormatType::DescriptionOptional& DataObjectFormatType::
    description ()
    {
      return this->Description_;
    }

    void DataObjectFormatType::
    description (const DescriptionType& x)
    {
      this->Description_.set (x);
    }

    void DataObjectFormatType::
    description (const DescriptionOptional& x)
    {
      this->Description_ = x;
    }

    void DataObjectFormatType::
    description (::std::auto_ptr< DescriptionType > x)
    {
      this->Description_.set (x);
    }

    const DataObjectFormatType::ObjectIdentifierOptional& DataObjectFormatType::
    objectIdentifier () const
    {
      return this->ObjectIdentifier_;
    }

    DataObjectFormatType::ObjectIdentifierOptional& DataObjectFormatType::
    objectIdentifier ()
    {
      return this->ObjectIdentifier_;
    }

    void DataObjectFormatType::
    objectIdentifier (const ObjectIdentifierType& x)
    {
      this->ObjectIdentifier_.set (x);
    }

    void DataObjectFormatType::
    objectIdentifier (const ObjectIdentifierOptional& x)
    {
      this->ObjectIdentifier_ = x;
    }

    void DataObjectFormatType::
    objectIdentifier (::std::auto_ptr< ObjectIdentifierType > x)
    {
      this->ObjectIdentifier_.set (x);
    }

    const DataObjectFormatType::MimeTypeOptional& DataObjectFormatType::
    mimeType () const
    {
      return this->MimeType_;
    }

    DataObjectFormatType::MimeTypeOptional& DataObjectFormatType::
    mimeType ()
    {
      return this->MimeType_;
    }

    void DataObjectFormatType::
    mimeType (const MimeTypeType& x)
    {
      this->MimeType_.set (x);
    }

    void DataObjectFormatType::
    mimeType (const MimeTypeOptional& x)
    {
      this->MimeType_ = x;
    }

    void DataObjectFormatType::
    mimeType (::std::auto_ptr< MimeTypeType > x)
    {
      this->MimeType_.set (x);
    }

    const DataObjectFormatType::EncodingOptional& DataObjectFormatType::
    encoding () const
    {
      return this->Encoding_;
    }

    DataObjectFormatType::EncodingOptional& DataObjectFormatType::
    encoding ()
    {
      return this->Encoding_;
    }

    void DataObjectFormatType::
    encoding (const EncodingType& x)
    {
      this->Encoding_.set (x);
    }

    void DataObjectFormatType::
    encoding (const EncodingOptional& x)
    {
      this->Encoding_ = x;
    }

    void DataObjectFormatType::
    encoding (::std::auto_ptr< EncodingType > x)
    {
      this->Encoding_.set (x);
    }

    const DataObjectFormatType::ObjectReferenceType& DataObjectFormatType::
    objectReference () const
    {
      return this->ObjectReference_.get ();
    }

    DataObjectFormatType::ObjectReferenceType& DataObjectFormatType::
    objectReference ()
    {
      return this->ObjectReference_.get ();
    }

    void DataObjectFormatType::
    objectReference (const ObjectReferenceType& x)
    {
      this->ObjectReference_.set (x);
    }

    void DataObjectFormatType::
    objectReference (::std::auto_ptr< ObjectReferenceType > x)
    {
      this->ObjectReference_.set (x);
    }


    // CommitmentTypeIndicationType
    // 

    const CommitmentTypeIndicationType::CommitmentTypeIdType& CommitmentTypeIndicationType::
    commitmentTypeId () const
    {
      return this->CommitmentTypeId_.get ();
    }

    CommitmentTypeIndicationType::CommitmentTypeIdType& CommitmentTypeIndicationType::
    commitmentTypeId ()
    {
      return this->CommitmentTypeId_.get ();
    }

    void CommitmentTypeIndicationType::
    commitmentTypeId (const CommitmentTypeIdType& x)
    {
      this->CommitmentTypeId_.set (x);
    }

    void CommitmentTypeIndicationType::
    commitmentTypeId (::std::auto_ptr< CommitmentTypeIdType > x)
    {
      this->CommitmentTypeId_.set (x);
    }

    const CommitmentTypeIndicationType::ObjectReferenceSequence& CommitmentTypeIndicationType::
    objectReference () const
    {
      return this->ObjectReference_;
    }

    CommitmentTypeIndicationType::ObjectReferenceSequence& CommitmentTypeIndicationType::
    objectReference ()
    {
      return this->ObjectReference_;
    }

    void CommitmentTypeIndicationType::
    objectReference (const ObjectReferenceSequence& s)
    {
      this->ObjectReference_ = s;
    }

    const CommitmentTypeIndicationType::AllSignedDataObjectsOptional& CommitmentTypeIndicationType::
    allSignedDataObjects () const
    {
      return this->AllSignedDataObjects_;
    }

    CommitmentTypeIndicationType::AllSignedDataObjectsOptional& CommitmentTypeIndicationType::
    allSignedDataObjects ()
    {
      return this->AllSignedDataObjects_;
    }

    void CommitmentTypeIndicationType::
    allSignedDataObjects (const AllSignedDataObjectsType& x)
    {
      this->AllSignedDataObjects_.set (x);
    }

    void CommitmentTypeIndicationType::
    allSignedDataObjects (const AllSignedDataObjectsOptional& x)
    {
      this->AllSignedDataObjects_ = x;
    }

    void CommitmentTypeIndicationType::
    allSignedDataObjects (::std::auto_ptr< AllSignedDataObjectsType > x)
    {
      this->AllSignedDataObjects_.set (x);
    }

    const CommitmentTypeIndicationType::CommitmentTypeQualifiersOptional& CommitmentTypeIndicationType::
    commitmentTypeQualifiers () const
    {
      return this->CommitmentTypeQualifiers_;
    }

    CommitmentTypeIndicationType::CommitmentTypeQualifiersOptional& CommitmentTypeIndicationType::
    commitmentTypeQualifiers ()
    {
      return this->CommitmentTypeQualifiers_;
    }

    void CommitmentTypeIndicationType::
    commitmentTypeQualifiers (const CommitmentTypeQualifiersType& x)
    {
      this->CommitmentTypeQualifiers_.set (x);
    }

    void CommitmentTypeIndicationType::
    commitmentTypeQualifiers (const CommitmentTypeQualifiersOptional& x)
    {
      this->CommitmentTypeQualifiers_ = x;
    }

    void CommitmentTypeIndicationType::
    commitmentTypeQualifiers (::std::auto_ptr< CommitmentTypeQualifiersType > x)
    {
      this->CommitmentTypeQualifiers_.set (x);
    }


    // CommitmentTypeQualifiersListType
    // 

    const CommitmentTypeQualifiersListType::CommitmentTypeQualifierSequence& CommitmentTypeQualifiersListType::
    commitmentTypeQualifier () const
    {
      return this->CommitmentTypeQualifier_;
    }

    CommitmentTypeQualifiersListType::CommitmentTypeQualifierSequence& CommitmentTypeQualifiersListType::
    commitmentTypeQualifier ()
    {
      return this->CommitmentTypeQualifier_;
    }

    void CommitmentTypeQualifiersListType::
    commitmentTypeQualifier (const CommitmentTypeQualifierSequence& s)
    {
      this->CommitmentTypeQualifier_ = s;
    }


    // SignatureProductionPlaceType
    // 

    const SignatureProductionPlaceType::CityOptional& SignatureProductionPlaceType::
    city () const
    {
      return this->City_;
    }

    SignatureProductionPlaceType::CityOptional& SignatureProductionPlaceType::
    city ()
    {
      return this->City_;
    }

    void SignatureProductionPlaceType::
    city (const CityType& x)
    {
      this->City_.set (x);
    }

    void SignatureProductionPlaceType::
    city (const CityOptional& x)
    {
      this->City_ = x;
    }

    void SignatureProductionPlaceType::
    city (::std::auto_ptr< CityType > x)
    {
      this->City_.set (x);
    }

    const SignatureProductionPlaceType::StateOrProvinceOptional& SignatureProductionPlaceType::
    stateOrProvince () const
    {
      return this->StateOrProvince_;
    }

    SignatureProductionPlaceType::StateOrProvinceOptional& SignatureProductionPlaceType::
    stateOrProvince ()
    {
      return this->StateOrProvince_;
    }

    void SignatureProductionPlaceType::
    stateOrProvince (const StateOrProvinceType& x)
    {
      this->StateOrProvince_.set (x);
    }

    void SignatureProductionPlaceType::
    stateOrProvince (const StateOrProvinceOptional& x)
    {
      this->StateOrProvince_ = x;
    }

    void SignatureProductionPlaceType::
    stateOrProvince (::std::auto_ptr< StateOrProvinceType > x)
    {
      this->StateOrProvince_.set (x);
    }

    const SignatureProductionPlaceType::PostalCodeOptional& SignatureProductionPlaceType::
    postalCode () const
    {
      return this->PostalCode_;
    }

    SignatureProductionPlaceType::PostalCodeOptional& SignatureProductionPlaceType::
    postalCode ()
    {
      return this->PostalCode_;
    }

    void SignatureProductionPlaceType::
    postalCode (const PostalCodeType& x)
    {
      this->PostalCode_.set (x);
    }

    void SignatureProductionPlaceType::
    postalCode (const PostalCodeOptional& x)
    {
      this->PostalCode_ = x;
    }

    void SignatureProductionPlaceType::
    postalCode (::std::auto_ptr< PostalCodeType > x)
    {
      this->PostalCode_.set (x);
    }

    const SignatureProductionPlaceType::CountryNameOptional& SignatureProductionPlaceType::
    countryName () const
    {
      return this->CountryName_;
    }

    SignatureProductionPlaceType::CountryNameOptional& SignatureProductionPlaceType::
    countryName ()
    {
      return this->CountryName_;
    }

    void SignatureProductionPlaceType::
    countryName (const CountryNameType& x)
    {
      this->CountryName_.set (x);
    }

    void SignatureProductionPlaceType::
    countryName (const CountryNameOptional& x)
    {
      this->CountryName_ = x;
    }

    void SignatureProductionPlaceType::
    countryName (::std::auto_ptr< CountryNameType > x)
    {
      this->CountryName_.set (x);
    }


    // SignerRoleType
    // 

    const SignerRoleType::ClaimedRolesOptional& SignerRoleType::
    claimedRoles () const
    {
      return this->ClaimedRoles_;
    }

    SignerRoleType::ClaimedRolesOptional& SignerRoleType::
    claimedRoles ()
    {
      return this->ClaimedRoles_;
    }

    void SignerRoleType::
    claimedRoles (const ClaimedRolesType& x)
    {
      this->ClaimedRoles_.set (x);
    }

    void SignerRoleType::
    claimedRoles (const ClaimedRolesOptional& x)
    {
      this->ClaimedRoles_ = x;
    }

    void SignerRoleType::
    claimedRoles (::std::auto_ptr< ClaimedRolesType > x)
    {
      this->ClaimedRoles_.set (x);
    }

    const SignerRoleType::CertifiedRolesOptional& SignerRoleType::
    certifiedRoles () const
    {
      return this->CertifiedRoles_;
    }

    SignerRoleType::CertifiedRolesOptional& SignerRoleType::
    certifiedRoles ()
    {
      return this->CertifiedRoles_;
    }

    void SignerRoleType::
    certifiedRoles (const CertifiedRolesType& x)
    {
      this->CertifiedRoles_.set (x);
    }

    void SignerRoleType::
    certifiedRoles (const CertifiedRolesOptional& x)
    {
      this->CertifiedRoles_ = x;
    }

    void SignerRoleType::
    certifiedRoles (::std::auto_ptr< CertifiedRolesType > x)
    {
      this->CertifiedRoles_.set (x);
    }


    // ClaimedRolesListType
    // 

    const ClaimedRolesListType::ClaimedRoleSequence& ClaimedRolesListType::
    claimedRole () const
    {
      return this->ClaimedRole_;
    }

    ClaimedRolesListType::ClaimedRoleSequence& ClaimedRolesListType::
    claimedRole ()
    {
      return this->ClaimedRole_;
    }

    void ClaimedRolesListType::
    claimedRole (const ClaimedRoleSequence& s)
    {
      this->ClaimedRole_ = s;
    }


    // CertifiedRolesListType
    // 

    const CertifiedRolesListType::CertifiedRoleSequence& CertifiedRolesListType::
    certifiedRole () const
    {
      return this->CertifiedRole_;
    }

    CertifiedRolesListType::CertifiedRoleSequence& CertifiedRolesListType::
    certifiedRole ()
    {
      return this->CertifiedRole_;
    }

    void CertifiedRolesListType::
    certifiedRole (const CertifiedRoleSequence& s)
    {
      this->CertifiedRole_ = s;
    }


    // CompleteCertificateRefsType
    // 

    const CompleteCertificateRefsType::CertRefsType& CompleteCertificateRefsType::
    certRefs () const
    {
      return this->CertRefs_.get ();
    }

    CompleteCertificateRefsType::CertRefsType& CompleteCertificateRefsType::
    certRefs ()
    {
      return this->CertRefs_.get ();
    }

    void CompleteCertificateRefsType::
    certRefs (const CertRefsType& x)
    {
      this->CertRefs_.set (x);
    }

    void CompleteCertificateRefsType::
    certRefs (::std::auto_ptr< CertRefsType > x)
    {
      this->CertRefs_.set (x);
    }

    const CompleteCertificateRefsType::IdOptional& CompleteCertificateRefsType::
    id () const
    {
      return this->Id_;
    }

    CompleteCertificateRefsType::IdOptional& CompleteCertificateRefsType::
    id ()
    {
      return this->Id_;
    }

    void CompleteCertificateRefsType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void CompleteCertificateRefsType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void CompleteCertificateRefsType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // CompleteRevocationRefsType
    // 

    const CompleteRevocationRefsType::CRLRefsOptional& CompleteRevocationRefsType::
    cRLRefs () const
    {
      return this->CRLRefs_;
    }

    CompleteRevocationRefsType::CRLRefsOptional& CompleteRevocationRefsType::
    cRLRefs ()
    {
      return this->CRLRefs_;
    }

    void CompleteRevocationRefsType::
    cRLRefs (const CRLRefsType& x)
    {
      this->CRLRefs_.set (x);
    }

    void CompleteRevocationRefsType::
    cRLRefs (const CRLRefsOptional& x)
    {
      this->CRLRefs_ = x;
    }

    void CompleteRevocationRefsType::
    cRLRefs (::std::auto_ptr< CRLRefsType > x)
    {
      this->CRLRefs_.set (x);
    }

    const CompleteRevocationRefsType::OCSPRefsOptional& CompleteRevocationRefsType::
    oCSPRefs () const
    {
      return this->OCSPRefs_;
    }

    CompleteRevocationRefsType::OCSPRefsOptional& CompleteRevocationRefsType::
    oCSPRefs ()
    {
      return this->OCSPRefs_;
    }

    void CompleteRevocationRefsType::
    oCSPRefs (const OCSPRefsType& x)
    {
      this->OCSPRefs_.set (x);
    }

    void CompleteRevocationRefsType::
    oCSPRefs (const OCSPRefsOptional& x)
    {
      this->OCSPRefs_ = x;
    }

    void CompleteRevocationRefsType::
    oCSPRefs (::std::auto_ptr< OCSPRefsType > x)
    {
      this->OCSPRefs_.set (x);
    }

    const CompleteRevocationRefsType::OtherRefsOptional& CompleteRevocationRefsType::
    otherRefs () const
    {
      return this->OtherRefs_;
    }

    CompleteRevocationRefsType::OtherRefsOptional& CompleteRevocationRefsType::
    otherRefs ()
    {
      return this->OtherRefs_;
    }

    void CompleteRevocationRefsType::
    otherRefs (const OtherRefsType& x)
    {
      this->OtherRefs_.set (x);
    }

    void CompleteRevocationRefsType::
    otherRefs (const OtherRefsOptional& x)
    {
      this->OtherRefs_ = x;
    }

    void CompleteRevocationRefsType::
    otherRefs (::std::auto_ptr< OtherRefsType > x)
    {
      this->OtherRefs_.set (x);
    }

    const CompleteRevocationRefsType::IdOptional& CompleteRevocationRefsType::
    id () const
    {
      return this->Id_;
    }

    CompleteRevocationRefsType::IdOptional& CompleteRevocationRefsType::
    id ()
    {
      return this->Id_;
    }

    void CompleteRevocationRefsType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void CompleteRevocationRefsType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void CompleteRevocationRefsType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // CRLRefsType
    // 

    const CRLRefsType::CRLRefSequence& CRLRefsType::
    cRLRef () const
    {
      return this->CRLRef_;
    }

    CRLRefsType::CRLRefSequence& CRLRefsType::
    cRLRef ()
    {
      return this->CRLRef_;
    }

    void CRLRefsType::
    cRLRef (const CRLRefSequence& s)
    {
      this->CRLRef_ = s;
    }


    // CRLRefType
    // 

    const CRLRefType::DigestAlgAndValueType& CRLRefType::
    digestAlgAndValue () const
    {
      return this->DigestAlgAndValue_.get ();
    }

    CRLRefType::DigestAlgAndValueType& CRLRefType::
    digestAlgAndValue ()
    {
      return this->DigestAlgAndValue_.get ();
    }

    void CRLRefType::
    digestAlgAndValue (const DigestAlgAndValueType& x)
    {
      this->DigestAlgAndValue_.set (x);
    }

    void CRLRefType::
    digestAlgAndValue (::std::auto_ptr< DigestAlgAndValueType > x)
    {
      this->DigestAlgAndValue_.set (x);
    }

    const CRLRefType::CRLIdentifierOptional& CRLRefType::
    cRLIdentifier () const
    {
      return this->CRLIdentifier_;
    }

    CRLRefType::CRLIdentifierOptional& CRLRefType::
    cRLIdentifier ()
    {
      return this->CRLIdentifier_;
    }

    void CRLRefType::
    cRLIdentifier (const CRLIdentifierType& x)
    {
      this->CRLIdentifier_.set (x);
    }

    void CRLRefType::
    cRLIdentifier (const CRLIdentifierOptional& x)
    {
      this->CRLIdentifier_ = x;
    }

    void CRLRefType::
    cRLIdentifier (::std::auto_ptr< CRLIdentifierType > x)
    {
      this->CRLIdentifier_.set (x);
    }


    // CRLIdentifierType
    // 

    const CRLIdentifierType::IssuerType& CRLIdentifierType::
    issuer () const
    {
      return this->Issuer_.get ();
    }

    CRLIdentifierType::IssuerType& CRLIdentifierType::
    issuer ()
    {
      return this->Issuer_.get ();
    }

    void CRLIdentifierType::
    issuer (const IssuerType& x)
    {
      this->Issuer_.set (x);
    }

    void CRLIdentifierType::
    issuer (::std::auto_ptr< IssuerType > x)
    {
      this->Issuer_.set (x);
    }

    const CRLIdentifierType::IssueTimeType& CRLIdentifierType::
    issueTime () const
    {
      return this->IssueTime_.get ();
    }

    CRLIdentifierType::IssueTimeType& CRLIdentifierType::
    issueTime ()
    {
      return this->IssueTime_.get ();
    }

    void CRLIdentifierType::
    issueTime (const IssueTimeType& x)
    {
      this->IssueTime_.set (x);
    }

    void CRLIdentifierType::
    issueTime (::std::auto_ptr< IssueTimeType > x)
    {
      this->IssueTime_.set (x);
    }

    const CRLIdentifierType::NumberOptional& CRLIdentifierType::
    number () const
    {
      return this->Number_;
    }

    CRLIdentifierType::NumberOptional& CRLIdentifierType::
    number ()
    {
      return this->Number_;
    }

    void CRLIdentifierType::
    number (const NumberType& x)
    {
      this->Number_.set (x);
    }

    void CRLIdentifierType::
    number (const NumberOptional& x)
    {
      this->Number_ = x;
    }

    const CRLIdentifierType::URIOptional& CRLIdentifierType::
    uRI () const
    {
      return this->URI_;
    }

    CRLIdentifierType::URIOptional& CRLIdentifierType::
    uRI ()
    {
      return this->URI_;
    }

    void CRLIdentifierType::
    uRI (const URIType& x)
    {
      this->URI_.set (x);
    }

    void CRLIdentifierType::
    uRI (const URIOptional& x)
    {
      this->URI_ = x;
    }

    void CRLIdentifierType::
    uRI (::std::auto_ptr< URIType > x)
    {
      this->URI_.set (x);
    }


    // OCSPRefsType
    // 

    const OCSPRefsType::OCSPRefSequence& OCSPRefsType::
    oCSPRef () const
    {
      return this->OCSPRef_;
    }

    OCSPRefsType::OCSPRefSequence& OCSPRefsType::
    oCSPRef ()
    {
      return this->OCSPRef_;
    }

    void OCSPRefsType::
    oCSPRef (const OCSPRefSequence& s)
    {
      this->OCSPRef_ = s;
    }


    // OCSPRefType
    // 

    const OCSPRefType::OCSPIdentifierType& OCSPRefType::
    oCSPIdentifier () const
    {
      return this->OCSPIdentifier_.get ();
    }

    OCSPRefType::OCSPIdentifierType& OCSPRefType::
    oCSPIdentifier ()
    {
      return this->OCSPIdentifier_.get ();
    }

    void OCSPRefType::
    oCSPIdentifier (const OCSPIdentifierType& x)
    {
      this->OCSPIdentifier_.set (x);
    }

    void OCSPRefType::
    oCSPIdentifier (::std::auto_ptr< OCSPIdentifierType > x)
    {
      this->OCSPIdentifier_.set (x);
    }

    const OCSPRefType::DigestAlgAndValueOptional& OCSPRefType::
    digestAlgAndValue () const
    {
      return this->DigestAlgAndValue_;
    }

    OCSPRefType::DigestAlgAndValueOptional& OCSPRefType::
    digestAlgAndValue ()
    {
      return this->DigestAlgAndValue_;
    }

    void OCSPRefType::
    digestAlgAndValue (const DigestAlgAndValueType& x)
    {
      this->DigestAlgAndValue_.set (x);
    }

    void OCSPRefType::
    digestAlgAndValue (const DigestAlgAndValueOptional& x)
    {
      this->DigestAlgAndValue_ = x;
    }

    void OCSPRefType::
    digestAlgAndValue (::std::auto_ptr< DigestAlgAndValueType > x)
    {
      this->DigestAlgAndValue_.set (x);
    }


    // ResponderIDType
    // 

    const ResponderIDType::ByNameOptional& ResponderIDType::
    byName () const
    {
      return this->ByName_;
    }

    ResponderIDType::ByNameOptional& ResponderIDType::
    byName ()
    {
      return this->ByName_;
    }

    void ResponderIDType::
    byName (const ByNameType& x)
    {
      this->ByName_.set (x);
    }

    void ResponderIDType::
    byName (const ByNameOptional& x)
    {
      this->ByName_ = x;
    }

    void ResponderIDType::
    byName (::std::auto_ptr< ByNameType > x)
    {
      this->ByName_.set (x);
    }

    const ResponderIDType::ByKeyOptional& ResponderIDType::
    byKey () const
    {
      return this->ByKey_;
    }

    ResponderIDType::ByKeyOptional& ResponderIDType::
    byKey ()
    {
      return this->ByKey_;
    }

    void ResponderIDType::
    byKey (const ByKeyType& x)
    {
      this->ByKey_.set (x);
    }

    void ResponderIDType::
    byKey (const ByKeyOptional& x)
    {
      this->ByKey_ = x;
    }

    void ResponderIDType::
    byKey (::std::auto_ptr< ByKeyType > x)
    {
      this->ByKey_.set (x);
    }


    // OCSPIdentifierType
    // 

    const OCSPIdentifierType::ResponderIDType& OCSPIdentifierType::
    responderID () const
    {
      return this->ResponderID_.get ();
    }

    OCSPIdentifierType::ResponderIDType& OCSPIdentifierType::
    responderID ()
    {
      return this->ResponderID_.get ();
    }

    void OCSPIdentifierType::
    responderID (const ResponderIDType& x)
    {
      this->ResponderID_.set (x);
    }

    void OCSPIdentifierType::
    responderID (::std::auto_ptr< ResponderIDType > x)
    {
      this->ResponderID_.set (x);
    }

    const OCSPIdentifierType::ProducedAtType& OCSPIdentifierType::
    producedAt () const
    {
      return this->ProducedAt_.get ();
    }

    OCSPIdentifierType::ProducedAtType& OCSPIdentifierType::
    producedAt ()
    {
      return this->ProducedAt_.get ();
    }

    void OCSPIdentifierType::
    producedAt (const ProducedAtType& x)
    {
      this->ProducedAt_.set (x);
    }

    void OCSPIdentifierType::
    producedAt (::std::auto_ptr< ProducedAtType > x)
    {
      this->ProducedAt_.set (x);
    }

    const OCSPIdentifierType::URIOptional& OCSPIdentifierType::
    uRI () const
    {
      return this->URI_;
    }

    OCSPIdentifierType::URIOptional& OCSPIdentifierType::
    uRI ()
    {
      return this->URI_;
    }

    void OCSPIdentifierType::
    uRI (const URIType& x)
    {
      this->URI_.set (x);
    }

    void OCSPIdentifierType::
    uRI (const URIOptional& x)
    {
      this->URI_ = x;
    }

    void OCSPIdentifierType::
    uRI (::std::auto_ptr< URIType > x)
    {
      this->URI_.set (x);
    }


    // OtherCertStatusRefsType
    // 

    const OtherCertStatusRefsType::OtherRefSequence& OtherCertStatusRefsType::
    otherRef () const
    {
      return this->OtherRef_;
    }

    OtherCertStatusRefsType::OtherRefSequence& OtherCertStatusRefsType::
    otherRef ()
    {
      return this->OtherRef_;
    }

    void OtherCertStatusRefsType::
    otherRef (const OtherRefSequence& s)
    {
      this->OtherRef_ = s;
    }


    // CertificateValuesType
    // 

    const CertificateValuesType::EncapsulatedX509CertificateSequence& CertificateValuesType::
    encapsulatedX509Certificate () const
    {
      return this->EncapsulatedX509Certificate_;
    }

    CertificateValuesType::EncapsulatedX509CertificateSequence& CertificateValuesType::
    encapsulatedX509Certificate ()
    {
      return this->EncapsulatedX509Certificate_;
    }

    void CertificateValuesType::
    encapsulatedX509Certificate (const EncapsulatedX509CertificateSequence& s)
    {
      this->EncapsulatedX509Certificate_ = s;
    }

    const CertificateValuesType::OtherCertificateSequence& CertificateValuesType::
    otherCertificate () const
    {
      return this->OtherCertificate_;
    }

    CertificateValuesType::OtherCertificateSequence& CertificateValuesType::
    otherCertificate ()
    {
      return this->OtherCertificate_;
    }

    void CertificateValuesType::
    otherCertificate (const OtherCertificateSequence& s)
    {
      this->OtherCertificate_ = s;
    }

    const CertificateValuesType::IdOptional& CertificateValuesType::
    id () const
    {
      return this->Id_;
    }

    CertificateValuesType::IdOptional& CertificateValuesType::
    id ()
    {
      return this->Id_;
    }

    void CertificateValuesType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void CertificateValuesType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void CertificateValuesType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // RevocationValuesType
    // 

    const RevocationValuesType::CRLValuesOptional& RevocationValuesType::
    cRLValues () const
    {
      return this->CRLValues_;
    }

    RevocationValuesType::CRLValuesOptional& RevocationValuesType::
    cRLValues ()
    {
      return this->CRLValues_;
    }

    void RevocationValuesType::
    cRLValues (const CRLValuesType& x)
    {
      this->CRLValues_.set (x);
    }

    void RevocationValuesType::
    cRLValues (const CRLValuesOptional& x)
    {
      this->CRLValues_ = x;
    }

    void RevocationValuesType::
    cRLValues (::std::auto_ptr< CRLValuesType > x)
    {
      this->CRLValues_.set (x);
    }

    const RevocationValuesType::OCSPValuesOptional& RevocationValuesType::
    oCSPValues () const
    {
      return this->OCSPValues_;
    }

    RevocationValuesType::OCSPValuesOptional& RevocationValuesType::
    oCSPValues ()
    {
      return this->OCSPValues_;
    }

    void RevocationValuesType::
    oCSPValues (const OCSPValuesType& x)
    {
      this->OCSPValues_.set (x);
    }

    void RevocationValuesType::
    oCSPValues (const OCSPValuesOptional& x)
    {
      this->OCSPValues_ = x;
    }

    void RevocationValuesType::
    oCSPValues (::std::auto_ptr< OCSPValuesType > x)
    {
      this->OCSPValues_.set (x);
    }

    const RevocationValuesType::OtherValuesOptional& RevocationValuesType::
    otherValues () const
    {
      return this->OtherValues_;
    }

    RevocationValuesType::OtherValuesOptional& RevocationValuesType::
    otherValues ()
    {
      return this->OtherValues_;
    }

    void RevocationValuesType::
    otherValues (const OtherValuesType& x)
    {
      this->OtherValues_.set (x);
    }

    void RevocationValuesType::
    otherValues (const OtherValuesOptional& x)
    {
      this->OtherValues_ = x;
    }

    void RevocationValuesType::
    otherValues (::std::auto_ptr< OtherValuesType > x)
    {
      this->OtherValues_.set (x);
    }

    const RevocationValuesType::IdOptional& RevocationValuesType::
    id () const
    {
      return this->Id_;
    }

    RevocationValuesType::IdOptional& RevocationValuesType::
    id ()
    {
      return this->Id_;
    }

    void RevocationValuesType::
    id (const IdType& x)
    {
      this->Id_.set (x);
    }

    void RevocationValuesType::
    id (const IdOptional& x)
    {
      this->Id_ = x;
    }

    void RevocationValuesType::
    id (::std::auto_ptr< IdType > x)
    {
      this->Id_.set (x);
    }


    // CRLValuesType
    // 

    const CRLValuesType::EncapsulatedCRLValueSequence& CRLValuesType::
    encapsulatedCRLValue () const
    {
      return this->EncapsulatedCRLValue_;
    }

    CRLValuesType::EncapsulatedCRLValueSequence& CRLValuesType::
    encapsulatedCRLValue ()
    {
      return this->EncapsulatedCRLValue_;
    }

    void CRLValuesType::
    encapsulatedCRLValue (const EncapsulatedCRLValueSequence& s)
    {
      this->EncapsulatedCRLValue_ = s;
    }


    // OCSPValuesType
    // 

    const OCSPValuesType::EncapsulatedOCSPValueSequence& OCSPValuesType::
    encapsulatedOCSPValue () const
    {
      return this->EncapsulatedOCSPValue_;
    }

    OCSPValuesType::EncapsulatedOCSPValueSequence& OCSPValuesType::
    encapsulatedOCSPValue ()
    {
      return this->EncapsulatedOCSPValue_;
    }

    void OCSPValuesType::
    encapsulatedOCSPValue (const EncapsulatedOCSPValueSequence& s)
    {
      this->EncapsulatedOCSPValue_ = s;
    }


    // OtherCertStatusValuesType
    // 

    const OtherCertStatusValuesType::OtherValueSequence& OtherCertStatusValuesType::
    otherValue () const
    {
      return this->OtherValue_;
    }

    OtherCertStatusValuesType::OtherValueSequence& OtherCertStatusValuesType::
    otherValue ()
    {
      return this->OtherValue_;
    }

    void OtherCertStatusValuesType::
    otherValue (const OtherValueSequence& s)
    {
      this->OtherValue_ = s;
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace digidoc
{
  namespace xades
  {
    // AnyType
    //

    AnyType::
    AnyType ()
    : ::xml_schema::Type ()
    {
    }

    AnyType::
    AnyType (const AnyType& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c)
    {
    }

    AnyType::
    AnyType (const xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void AnyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        break;
      }
    }

    AnyType* AnyType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class AnyType (*this, f, c);
    }

    AnyType::
    ~AnyType ()
    {
    }

    // ObjectIdentifierType
    //

    ObjectIdentifierType::
    ObjectIdentifierType (const IdentifierType& Identifier)
    : ::xml_schema::Type (),
      Identifier_ (Identifier, ::xml_schema::Flags (), this),
      Description_ (::xml_schema::Flags (), this),
      DocumentationReferences_ (::xml_schema::Flags (), this)
    {
    }

    ObjectIdentifierType::
    ObjectIdentifierType (::std::auto_ptr< IdentifierType >& Identifier)
    : ::xml_schema::Type (),
      Identifier_ (Identifier, ::xml_schema::Flags (), this),
      Description_ (::xml_schema::Flags (), this),
      DocumentationReferences_ (::xml_schema::Flags (), this)
    {
    }

    ObjectIdentifierType::
    ObjectIdentifierType (const ObjectIdentifierType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Identifier_ (x.Identifier_, f, this),
      Description_ (x.Description_, f, this),
      DocumentationReferences_ (x.DocumentationReferences_, f, this)
    {
    }

    ObjectIdentifierType::
    ObjectIdentifierType (const xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Identifier_ (f, this),
      Description_ (f, this),
      DocumentationReferences_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ObjectIdentifierType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Identifier
        //
        if (n.name () == "Identifier" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< IdentifierType > r (
            IdentifierTraits::create (i, f, this));

          if (!Identifier_.present ())
          {
            this->Identifier_.set (r);
            continue;
          }
        }

        // Description
        //
        if (n.name () == "Description" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< DescriptionType > r (
            DescriptionTraits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (r);
            continue;
          }
        }

        // DocumentationReferences
        //
        if (n.name () == "DocumentationReferences" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< DocumentationReferencesType > r (
            DocumentationReferencesTraits::create (i, f, this));

          if (!this->DocumentationReferences_)
          {
            this->DocumentationReferences_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Identifier_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Identifier",
          "http://uri.etsi.org/01903/v1.3.2#");
      }
    }

    ObjectIdentifierType* ObjectIdentifierType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ObjectIdentifierType (*this, f, c);
    }

    ObjectIdentifierType::
    ~ObjectIdentifierType ()
    {
    }

    // IdentifierType
    //

    IdentifierType::
    IdentifierType (const ::xml_schema::Uri& _xsd_Uri_base)
    : ::xml_schema::Uri (_xsd_Uri_base),
      Qualifier_ (::xml_schema::Flags (), this)
    {
    }

    IdentifierType::
    IdentifierType (const IdentifierType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Uri (x, f, c),
      Qualifier_ (x.Qualifier_, f, this)
    {
    }

    IdentifierType::
    IdentifierType (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Uri (e, f | ::xml_schema::Flags::base, c),
      Qualifier_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void IdentifierType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Qualifier" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< QualifierType > r (
            QualifierTraits::create (i, f, this));

          this->Qualifier_.set (r);
          continue;
        }
      }
    }

    IdentifierType* IdentifierType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IdentifierType (*this, f, c);
    }

    IdentifierType::
    ~IdentifierType ()
    {
    }

    // QualifierType
    //

    QualifierType::
    QualifierType (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
      _xsd_QualifierType_convert ();
    }

    QualifierType::
    QualifierType (const xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
      _xsd_QualifierType_convert ();
    }

    QualifierType::
    QualifierType (const ::std::string& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
      _xsd_QualifierType_convert ();
    }

    QualifierType* QualifierType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class QualifierType (*this, f, c);
    }

    QualifierType::Value QualifierType::
    _xsd_QualifierType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_QualifierType_literals_);
      const Value* i (::std::lower_bound (
                        _xsd_QualifierType_indexes_,
                        _xsd_QualifierType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_QualifierType_indexes_ + 2 || _xsd_QualifierType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const QualifierType::
    _xsd_QualifierType_literals_[2] =
    {
      "OIDAsURI",
      "OIDAsURN"
    };

    const QualifierType::Value QualifierType::
    _xsd_QualifierType_indexes_[2] =
    {
      ::digidoc::xades::QualifierType::OIDAsURI,
      ::digidoc::xades::QualifierType::OIDAsURN
    };

    // DocumentationReferencesType
    //

    DocumentationReferencesType::
    DocumentationReferencesType ()
    : ::xml_schema::Type (),
      DocumentationReference_ (::xml_schema::Flags (), this)
    {
    }

    DocumentationReferencesType::
    DocumentationReferencesType (const DocumentationReferencesType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      DocumentationReference_ (x.DocumentationReference_, f, this)
    {
    }

    DocumentationReferencesType::
    DocumentationReferencesType (const xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      DocumentationReference_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void DocumentationReferencesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DocumentationReference
        //
        if (n.name () == "DocumentationReference" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< DocumentationReferenceType > r (
            DocumentationReferenceTraits::create (i, f, this));

          this->DocumentationReference_.push_back (r);
          continue;
        }

        break;
      }
    }

    DocumentationReferencesType* DocumentationReferencesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DocumentationReferencesType (*this, f, c);
    }

    DocumentationReferencesType::
    ~DocumentationReferencesType ()
    {
    }

    // EncapsulatedPKIDataType
    //

    EncapsulatedPKIDataType::
    EncapsulatedPKIDataType ()
    : ::xml_schema::Base64Binary (),
      Id_ (::xml_schema::Flags (), this),
      Encoding_ (::xml_schema::Flags (), this)
    {
    }

    EncapsulatedPKIDataType::
    EncapsulatedPKIDataType (const ::xml_schema::Base64Binary& _xsd_Base64Binary_base)
    : ::xml_schema::Base64Binary (_xsd_Base64Binary_base),
      Id_ (::xml_schema::Flags (), this),
      Encoding_ (::xml_schema::Flags (), this)
    {
    }

    EncapsulatedPKIDataType::
    EncapsulatedPKIDataType (const EncapsulatedPKIDataType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::Base64Binary (x, f, c),
      Id_ (x.Id_, f, this),
      Encoding_ (x.Encoding_, f, this)
    {
    }

    EncapsulatedPKIDataType::
    EncapsulatedPKIDataType (const xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::Base64Binary (e, f | ::xml_schema::Flags::base, c),
      Id_ (f, this),
      Encoding_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void EncapsulatedPKIDataType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }

        if (n.name () == "Encoding" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< EncodingType > r (
            EncodingTraits::create (i, f, this));

          this->Encoding_.set (r);
          continue;
        }
      }
    }

    EncapsulatedPKIDataType* EncapsulatedPKIDataType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EncapsulatedPKIDataType (*this, f, c);
    }

    EncapsulatedPKIDataType::
    ~EncapsulatedPKIDataType ()
    {
    }

    // IncludeType
    //

    IncludeType::
    IncludeType (const URIType& URI)
    : ::xml_schema::Type (),
      URI_ (URI, ::xml_schema::Flags (), this),
      referencedData_ (::xml_schema::Flags (), this)
    {
    }

    IncludeType::
    IncludeType (const IncludeType& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      URI_ (x.URI_, f, this),
      referencedData_ (x.referencedData_, f, this)
    {
    }

    IncludeType::
    IncludeType (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      URI_ (f, this),
      referencedData_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void IncludeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "URI" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< URIType > r (
            URITraits::create (i, f, this));

          this->URI_.set (r);
          continue;
        }

        if (n.name () == "referencedData" && n.namespace_ ().empty ())
        {
          this->referencedData_.set (ReferencedDataTraits::create (i, f, this));
          continue;
        }
      }

      if (!URI_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "URI",
          "");
      }
    }

    IncludeType* IncludeType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IncludeType (*this, f, c);
    }

    IncludeType::
    ~IncludeType ()
    {
    }

    // ReferenceInfoType
    //

    ReferenceInfoType::
    ReferenceInfoType (const DigestMethodType& DigestMethod,
                       const DigestValueType& DigestValue)
    : ::xml_schema::Type (),
      DigestMethod_ (DigestMethod, ::xml_schema::Flags (), this),
      DigestValue_ (DigestValue, ::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this),
      URI_ (::xml_schema::Flags (), this)
    {
    }

    ReferenceInfoType::
    ReferenceInfoType (::std::auto_ptr< DigestMethodType >& DigestMethod,
                       const DigestValueType& DigestValue)
    : ::xml_schema::Type (),
      DigestMethod_ (DigestMethod, ::xml_schema::Flags (), this),
      DigestValue_ (DigestValue, ::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this),
      URI_ (::xml_schema::Flags (), this)
    {
    }

    ReferenceInfoType::
    ReferenceInfoType (const ReferenceInfoType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      DigestMethod_ (x.DigestMethod_, f, this),
      DigestValue_ (x.DigestValue_, f, this),
      Id_ (x.Id_, f, this),
      URI_ (x.URI_, f, this)
    {
    }

    ReferenceInfoType::
    ReferenceInfoType (const xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      DigestMethod_ (f, this),
      DigestValue_ (f, this),
      Id_ (f, this),
      URI_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ReferenceInfoType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DigestMethod
        //
        if (n.name () == "DigestMethod" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< DigestMethodType > r (
            DigestMethodTraits::create (i, f, this));

          if (!DigestMethod_.present ())
          {
            this->DigestMethod_.set (r);
            continue;
          }
        }

        // DigestValue
        //
        if (n.name () == "DigestValue" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< DigestValueType > r (
            DigestValueTraits::create (i, f, this));

          if (!DigestValue_.present ())
          {
            this->DigestValue_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DigestMethod_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DigestMethod",
          "http://www.w3.org/2000/09/xmldsig#");
      }

      if (!DigestValue_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DigestValue",
          "http://www.w3.org/2000/09/xmldsig#");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }

        if (n.name () == "URI" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< URIType > r (
            URITraits::create (i, f, this));

          this->URI_.set (r);
          continue;
        }
      }
    }

    ReferenceInfoType* ReferenceInfoType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ReferenceInfoType (*this, f, c);
    }

    ReferenceInfoType::
    ~ReferenceInfoType ()
    {
    }

    // GenericTimeStampType
    //

    GenericTimeStampType::
    GenericTimeStampType ()
    : ::xml_schema::Type (),
      Include_ (::xml_schema::Flags (), this),
      ReferenceInfo_ (::xml_schema::Flags (), this),
      CanonicalizationMethod_ (::xml_schema::Flags (), this),
      EncapsulatedTimeStamp_ (::xml_schema::Flags (), this),
      XMLTimeStamp_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    GenericTimeStampType::
    GenericTimeStampType (const GenericTimeStampType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Include_ (x.Include_, f, this),
      ReferenceInfo_ (x.ReferenceInfo_, f, this),
      CanonicalizationMethod_ (x.CanonicalizationMethod_, f, this),
      EncapsulatedTimeStamp_ (x.EncapsulatedTimeStamp_, f, this),
      XMLTimeStamp_ (x.XMLTimeStamp_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    GenericTimeStampType::
    GenericTimeStampType (const xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Include_ (f, this),
      ReferenceInfo_ (f, this),
      CanonicalizationMethod_ (f, this),
      EncapsulatedTimeStamp_ (f, this),
      XMLTimeStamp_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void GenericTimeStampType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Include
        //
        if (n.name () == "Include" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< IncludeType > r (
            IncludeTraits::create (i, f, this));

          this->Include_.push_back (r);
          continue;
        }

        // ReferenceInfo
        //
        if (n.name () == "ReferenceInfo" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< ReferenceInfoType > r (
            ReferenceInfoTraits::create (i, f, this));

          this->ReferenceInfo_.push_back (r);
          continue;
        }

        // CanonicalizationMethod
        //
        if (n.name () == "CanonicalizationMethod" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< CanonicalizationMethodType > r (
            CanonicalizationMethodTraits::create (i, f, this));

          if (!this->CanonicalizationMethod_)
          {
            this->CanonicalizationMethod_.set (r);
            continue;
          }
        }

        // EncapsulatedTimeStamp
        //
        if (n.name () == "EncapsulatedTimeStamp" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< EncapsulatedTimeStampType > r (
            EncapsulatedTimeStampTraits::create (i, f, this));

          this->EncapsulatedTimeStamp_.push_back (r);
          continue;
        }

        // XMLTimeStamp
        //
        if (n.name () == "XMLTimeStamp" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< XMLTimeStampType > r (
            XMLTimeStampTraits::create (i, f, this));

          this->XMLTimeStamp_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    GenericTimeStampType* GenericTimeStampType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class GenericTimeStampType (*this, f, c);
    }

    GenericTimeStampType::
    ~GenericTimeStampType ()
    {
    }

    // XAdESTimeStampType
    //

    XAdESTimeStampType::
    XAdESTimeStampType ()
    : ::xml_schema::Type (),
      Include_ (::xml_schema::Flags (), this),
      CanonicalizationMethod_ (::xml_schema::Flags (), this),
      EncapsulatedTimeStamp_ (::xml_schema::Flags (), this),
      XMLTimeStamp_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    XAdESTimeStampType::
    XAdESTimeStampType (const XAdESTimeStampType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Include_ (x.Include_, f, this),
      CanonicalizationMethod_ (x.CanonicalizationMethod_, f, this),
      EncapsulatedTimeStamp_ (x.EncapsulatedTimeStamp_, f, this),
      XMLTimeStamp_ (x.XMLTimeStamp_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    XAdESTimeStampType::
    XAdESTimeStampType (const xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Include_ (f, this),
      CanonicalizationMethod_ (f, this),
      EncapsulatedTimeStamp_ (f, this),
      XMLTimeStamp_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void XAdESTimeStampType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Include
        //
        if (n.name () == "Include" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< IncludeType > r (
            IncludeTraits::create (i, f, this));

          this->Include_.push_back (r);
          continue;
        }

        // CanonicalizationMethod
        //
        if (n.name () == "CanonicalizationMethod" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< CanonicalizationMethodType > r (
            CanonicalizationMethodTraits::create (i, f, this));

          if (!this->CanonicalizationMethod_)
          {
            this->CanonicalizationMethod_.set (r);
            continue;
          }
        }

        // EncapsulatedTimeStamp
        //
        if (n.name () == "EncapsulatedTimeStamp" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< EncapsulatedTimeStampType > r (
            EncapsulatedTimeStampTraits::create (i, f, this));

          this->EncapsulatedTimeStamp_.push_back (r);
          continue;
        }

        // XMLTimeStamp
        //
        if (n.name () == "XMLTimeStamp" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< XMLTimeStampType > r (
            XMLTimeStampTraits::create (i, f, this));

          this->XMLTimeStamp_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    XAdESTimeStampType* XAdESTimeStampType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class XAdESTimeStampType (*this, f, c);
    }

    XAdESTimeStampType::
    ~XAdESTimeStampType ()
    {
    }

    // OtherTimeStampType
    //

    OtherTimeStampType::
    OtherTimeStampType ()
    : ::digidoc::xades::GenericTimeStampType ()
    {
    }

    OtherTimeStampType::
    OtherTimeStampType (const OtherTimeStampType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::digidoc::xades::GenericTimeStampType (x, f, c)
    {
    }

    OtherTimeStampType::
    OtherTimeStampType (const xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::digidoc::xades::GenericTimeStampType (e, f, c)
    {
    }

    OtherTimeStampType* OtherTimeStampType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class OtherTimeStampType (*this, f, c);
    }

    OtherTimeStampType::
    ~OtherTimeStampType ()
    {
    }

    // QualifyingPropertiesType
    //

    QualifyingPropertiesType::
    QualifyingPropertiesType (const TargetType& Target)
    : ::xml_schema::Type (),
      SignedProperties_ (::xml_schema::Flags (), this),
      UnsignedProperties_ (::xml_schema::Flags (), this),
      Target_ (Target, ::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    QualifyingPropertiesType::
    QualifyingPropertiesType (const QualifyingPropertiesType& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      SignedProperties_ (x.SignedProperties_, f, this),
      UnsignedProperties_ (x.UnsignedProperties_, f, this),
      Target_ (x.Target_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    QualifyingPropertiesType::
    QualifyingPropertiesType (const xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      SignedProperties_ (f, this),
      UnsignedProperties_ (f, this),
      Target_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void QualifyingPropertiesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SignedProperties
        //
        if (n.name () == "SignedProperties" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< SignedPropertiesType > r (
            SignedPropertiesTraits::create (i, f, this));

          if (!this->SignedProperties_)
          {
            this->SignedProperties_.set (r);
            continue;
          }
        }

        // UnsignedProperties
        //
        if (n.name () == "UnsignedProperties" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< UnsignedPropertiesType > r (
            UnsignedPropertiesTraits::create (i, f, this));

          if (!this->UnsignedProperties_)
          {
            this->UnsignedProperties_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Target" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< TargetType > r (
            TargetTraits::create (i, f, this));

          this->Target_.set (r);
          continue;
        }

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }

      if (!Target_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "Target",
          "");
      }
    }

    QualifyingPropertiesType* QualifyingPropertiesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class QualifyingPropertiesType (*this, f, c);
    }

    QualifyingPropertiesType::
    ~QualifyingPropertiesType ()
    {
    }

    // SignedPropertiesType
    //

    SignedPropertiesType::
    SignedPropertiesType (const SignedSignaturePropertiesType& SignedSignatureProperties)
    : ::xml_schema::Type (),
      SignedSignatureProperties_ (SignedSignatureProperties, ::xml_schema::Flags (), this),
      SignedDataObjectProperties_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    SignedPropertiesType::
    SignedPropertiesType (::std::auto_ptr< SignedSignaturePropertiesType >& SignedSignatureProperties)
    : ::xml_schema::Type (),
      SignedSignatureProperties_ (SignedSignatureProperties, ::xml_schema::Flags (), this),
      SignedDataObjectProperties_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    SignedPropertiesType::
    SignedPropertiesType (const SignedPropertiesType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      SignedSignatureProperties_ (x.SignedSignatureProperties_, f, this),
      SignedDataObjectProperties_ (x.SignedDataObjectProperties_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    SignedPropertiesType::
    SignedPropertiesType (const xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      SignedSignatureProperties_ (f, this),
      SignedDataObjectProperties_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SignedPropertiesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SignedSignatureProperties
        //
        if (n.name () == "SignedSignatureProperties" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< SignedSignaturePropertiesType > r (
            SignedSignaturePropertiesTraits::create (i, f, this));

          if (!SignedSignatureProperties_.present ())
          {
            this->SignedSignatureProperties_.set (r);
            continue;
          }
        }

        // SignedDataObjectProperties
        //
        if (n.name () == "SignedDataObjectProperties" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< SignedDataObjectPropertiesType > r (
            SignedDataObjectPropertiesTraits::create (i, f, this));

          if (!this->SignedDataObjectProperties_)
          {
            this->SignedDataObjectProperties_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SignedSignatureProperties_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SignedSignatureProperties",
          "http://uri.etsi.org/01903/v1.3.2#");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    SignedPropertiesType* SignedPropertiesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SignedPropertiesType (*this, f, c);
    }

    SignedPropertiesType::
    ~SignedPropertiesType ()
    {
    }

    // UnsignedPropertiesType
    //

    UnsignedPropertiesType::
    UnsignedPropertiesType ()
    : ::xml_schema::Type (),
      UnsignedSignatureProperties_ (::xml_schema::Flags (), this),
      UnsignedDataObjectProperties_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    UnsignedPropertiesType::
    UnsignedPropertiesType (const UnsignedPropertiesType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      UnsignedSignatureProperties_ (x.UnsignedSignatureProperties_, f, this),
      UnsignedDataObjectProperties_ (x.UnsignedDataObjectProperties_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    UnsignedPropertiesType::
    UnsignedPropertiesType (const xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      UnsignedSignatureProperties_ (f, this),
      UnsignedDataObjectProperties_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void UnsignedPropertiesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // UnsignedSignatureProperties
        //
        if (n.name () == "UnsignedSignatureProperties" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< UnsignedSignaturePropertiesType > r (
            UnsignedSignaturePropertiesTraits::create (i, f, this));

          if (!this->UnsignedSignatureProperties_)
          {
            this->UnsignedSignatureProperties_.set (r);
            continue;
          }
        }

        // UnsignedDataObjectProperties
        //
        if (n.name () == "UnsignedDataObjectProperties" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< UnsignedDataObjectPropertiesType > r (
            UnsignedDataObjectPropertiesTraits::create (i, f, this));

          if (!this->UnsignedDataObjectProperties_)
          {
            this->UnsignedDataObjectProperties_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    UnsignedPropertiesType* UnsignedPropertiesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class UnsignedPropertiesType (*this, f, c);
    }

    UnsignedPropertiesType::
    ~UnsignedPropertiesType ()
    {
    }

    // SignedSignaturePropertiesType
    //

    SignedSignaturePropertiesType::
    SignedSignaturePropertiesType ()
    : ::xml_schema::Type (),
      SigningTime_ (::xml_schema::Flags (), this),
      SigningCertificate_ (::xml_schema::Flags (), this),
      SignaturePolicyIdentifier_ (::xml_schema::Flags (), this),
      SignatureProductionPlace_ (::xml_schema::Flags (), this),
      SignerRole_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    SignedSignaturePropertiesType::
    SignedSignaturePropertiesType (const SignedSignaturePropertiesType& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      SigningTime_ (x.SigningTime_, f, this),
      SigningCertificate_ (x.SigningCertificate_, f, this),
      SignaturePolicyIdentifier_ (x.SignaturePolicyIdentifier_, f, this),
      SignatureProductionPlace_ (x.SignatureProductionPlace_, f, this),
      SignerRole_ (x.SignerRole_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    SignedSignaturePropertiesType::
    SignedSignaturePropertiesType (const xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      SigningTime_ (f, this),
      SigningCertificate_ (f, this),
      SignaturePolicyIdentifier_ (f, this),
      SignatureProductionPlace_ (f, this),
      SignerRole_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SignedSignaturePropertiesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SigningTime
        //
        if (n.name () == "SigningTime" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< SigningTimeType > r (
            SigningTimeTraits::create (i, f, this));

          if (!this->SigningTime_)
          {
            this->SigningTime_.set (r);
            continue;
          }
        }

        // SigningCertificate
        //
        if (n.name () == "SigningCertificate" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< SigningCertificateType > r (
            SigningCertificateTraits::create (i, f, this));

          if (!this->SigningCertificate_)
          {
            this->SigningCertificate_.set (r);
            continue;
          }
        }

        // SignaturePolicyIdentifier
        //
        if (n.name () == "SignaturePolicyIdentifier" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< SignaturePolicyIdentifierType > r (
            SignaturePolicyIdentifierTraits::create (i, f, this));

          if (!this->SignaturePolicyIdentifier_)
          {
            this->SignaturePolicyIdentifier_.set (r);
            continue;
          }
        }

        // SignatureProductionPlace
        //
        if (n.name () == "SignatureProductionPlace" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< SignatureProductionPlaceType > r (
            SignatureProductionPlaceTraits::create (i, f, this));

          if (!this->SignatureProductionPlace_)
          {
            this->SignatureProductionPlace_.set (r);
            continue;
          }
        }

        // SignerRole
        //
        if (n.name () == "SignerRole" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< SignerRoleType > r (
            SignerRoleTraits::create (i, f, this));

          if (!this->SignerRole_)
          {
            this->SignerRole_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    SignedSignaturePropertiesType* SignedSignaturePropertiesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SignedSignaturePropertiesType (*this, f, c);
    }

    SignedSignaturePropertiesType::
    ~SignedSignaturePropertiesType ()
    {
    }

    // SignedDataObjectPropertiesType
    //

    SignedDataObjectPropertiesType::
    SignedDataObjectPropertiesType ()
    : ::xml_schema::Type (),
      DataObjectFormat_ (::xml_schema::Flags (), this),
      CommitmentTypeIndication_ (::xml_schema::Flags (), this),
      AllDataObjectsTimeStamp_ (::xml_schema::Flags (), this),
      IndividualDataObjectsTimeStamp_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    SignedDataObjectPropertiesType::
    SignedDataObjectPropertiesType (const SignedDataObjectPropertiesType& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      DataObjectFormat_ (x.DataObjectFormat_, f, this),
      CommitmentTypeIndication_ (x.CommitmentTypeIndication_, f, this),
      AllDataObjectsTimeStamp_ (x.AllDataObjectsTimeStamp_, f, this),
      IndividualDataObjectsTimeStamp_ (x.IndividualDataObjectsTimeStamp_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    SignedDataObjectPropertiesType::
    SignedDataObjectPropertiesType (const xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      DataObjectFormat_ (f, this),
      CommitmentTypeIndication_ (f, this),
      AllDataObjectsTimeStamp_ (f, this),
      IndividualDataObjectsTimeStamp_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SignedDataObjectPropertiesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DataObjectFormat
        //
        if (n.name () == "DataObjectFormat" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< DataObjectFormatType > r (
            DataObjectFormatTraits::create (i, f, this));

          this->DataObjectFormat_.push_back (r);
          continue;
        }

        // CommitmentTypeIndication
        //
        if (n.name () == "CommitmentTypeIndication" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CommitmentTypeIndicationType > r (
            CommitmentTypeIndicationTraits::create (i, f, this));

          this->CommitmentTypeIndication_.push_back (r);
          continue;
        }

        // AllDataObjectsTimeStamp
        //
        if (n.name () == "AllDataObjectsTimeStamp" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< AllDataObjectsTimeStampType > r (
            AllDataObjectsTimeStampTraits::create (i, f, this));

          this->AllDataObjectsTimeStamp_.push_back (r);
          continue;
        }

        // IndividualDataObjectsTimeStamp
        //
        if (n.name () == "IndividualDataObjectsTimeStamp" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< IndividualDataObjectsTimeStampType > r (
            IndividualDataObjectsTimeStampTraits::create (i, f, this));

          this->IndividualDataObjectsTimeStamp_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    SignedDataObjectPropertiesType* SignedDataObjectPropertiesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SignedDataObjectPropertiesType (*this, f, c);
    }

    SignedDataObjectPropertiesType::
    ~SignedDataObjectPropertiesType ()
    {
    }

    // UnsignedSignaturePropertiesType
    //

    UnsignedSignaturePropertiesType::
    UnsignedSignaturePropertiesType ()
    : ::xml_schema::Type (),
      CounterSignature_ (::xml_schema::Flags (), this),
      SignatureTimeStamp_ (::xml_schema::Flags (), this),
      CompleteCertificateRefs_ (::xml_schema::Flags (), this),
      CompleteRevocationRefs_ (::xml_schema::Flags (), this),
      AttributeCertificateRefs_ (::xml_schema::Flags (), this),
      AttributeRevocationRefs_ (::xml_schema::Flags (), this),
      SigAndRefsTimeStamp_ (::xml_schema::Flags (), this),
      RefsOnlyTimeStamp_ (::xml_schema::Flags (), this),
      CertificateValues_ (::xml_schema::Flags (), this),
      RevocationValues_ (::xml_schema::Flags (), this),
      AttrAuthoritiesCertValues_ (::xml_schema::Flags (), this),
      AttributeRevocationValues_ (::xml_schema::Flags (), this),
      ArchiveTimeStamp_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    UnsignedSignaturePropertiesType::
    UnsignedSignaturePropertiesType (const UnsignedSignaturePropertiesType& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      CounterSignature_ (x.CounterSignature_, f, this),
      SignatureTimeStamp_ (x.SignatureTimeStamp_, f, this),
      CompleteCertificateRefs_ (x.CompleteCertificateRefs_, f, this),
      CompleteRevocationRefs_ (x.CompleteRevocationRefs_, f, this),
      AttributeCertificateRefs_ (x.AttributeCertificateRefs_, f, this),
      AttributeRevocationRefs_ (x.AttributeRevocationRefs_, f, this),
      SigAndRefsTimeStamp_ (x.SigAndRefsTimeStamp_, f, this),
      RefsOnlyTimeStamp_ (x.RefsOnlyTimeStamp_, f, this),
      CertificateValues_ (x.CertificateValues_, f, this),
      RevocationValues_ (x.RevocationValues_, f, this),
      AttrAuthoritiesCertValues_ (x.AttrAuthoritiesCertValues_, f, this),
      AttributeRevocationValues_ (x.AttributeRevocationValues_, f, this),
      ArchiveTimeStamp_ (x.ArchiveTimeStamp_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    UnsignedSignaturePropertiesType::
    UnsignedSignaturePropertiesType (const xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      CounterSignature_ (f, this),
      SignatureTimeStamp_ (f, this),
      CompleteCertificateRefs_ (f, this),
      CompleteRevocationRefs_ (f, this),
      AttributeCertificateRefs_ (f, this),
      AttributeRevocationRefs_ (f, this),
      SigAndRefsTimeStamp_ (f, this),
      RefsOnlyTimeStamp_ (f, this),
      CertificateValues_ (f, this),
      RevocationValues_ (f, this),
      AttrAuthoritiesCertValues_ (f, this),
      AttributeRevocationValues_ (f, this),
      ArchiveTimeStamp_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void UnsignedSignaturePropertiesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CounterSignature
        //
        if (n.name () == "CounterSignature" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CounterSignatureType > r (
            CounterSignatureTraits::create (i, f, this));

          this->CounterSignature_.push_back (r);
          continue;
        }

        // SignatureTimeStamp
        //
        if (n.name () == "SignatureTimeStamp" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< SignatureTimeStampType > r (
            SignatureTimeStampTraits::create (i, f, this));

          this->SignatureTimeStamp_.push_back (r);
          continue;
        }

        // CompleteCertificateRefs
        //
        if (n.name () == "CompleteCertificateRefs" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CompleteCertificateRefsType > r (
            CompleteCertificateRefsTraits::create (i, f, this));

          this->CompleteCertificateRefs_.push_back (r);
          continue;
        }

        // CompleteRevocationRefs
        //
        if (n.name () == "CompleteRevocationRefs" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CompleteRevocationRefsType > r (
            CompleteRevocationRefsTraits::create (i, f, this));

          this->CompleteRevocationRefs_.push_back (r);
          continue;
        }

        // AttributeCertificateRefs
        //
        if (n.name () == "AttributeCertificateRefs" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< AttributeCertificateRefsType > r (
            AttributeCertificateRefsTraits::create (i, f, this));

          this->AttributeCertificateRefs_.push_back (r);
          continue;
        }

        // AttributeRevocationRefs
        //
        if (n.name () == "AttributeRevocationRefs" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< AttributeRevocationRefsType > r (
            AttributeRevocationRefsTraits::create (i, f, this));

          this->AttributeRevocationRefs_.push_back (r);
          continue;
        }

        // SigAndRefsTimeStamp
        //
        if (n.name () == "SigAndRefsTimeStamp" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< SigAndRefsTimeStampType > r (
            SigAndRefsTimeStampTraits::create (i, f, this));

          this->SigAndRefsTimeStamp_.push_back (r);
          continue;
        }

        // RefsOnlyTimeStamp
        //
        if (n.name () == "RefsOnlyTimeStamp" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< RefsOnlyTimeStampType > r (
            RefsOnlyTimeStampTraits::create (i, f, this));

          this->RefsOnlyTimeStamp_.push_back (r);
          continue;
        }

        // CertificateValues
        //
        if (n.name () == "CertificateValues" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CertificateValuesType > r (
            CertificateValuesTraits::create (i, f, this));

          this->CertificateValues_.push_back (r);
          continue;
        }

        // RevocationValues
        //
        if (n.name () == "RevocationValues" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< RevocationValuesType > r (
            RevocationValuesTraits::create (i, f, this));

          this->RevocationValues_.push_back (r);
          continue;
        }

        // AttrAuthoritiesCertValues
        //
        if (n.name () == "AttrAuthoritiesCertValues" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< AttrAuthoritiesCertValuesType > r (
            AttrAuthoritiesCertValuesTraits::create (i, f, this));

          this->AttrAuthoritiesCertValues_.push_back (r);
          continue;
        }

        // AttributeRevocationValues
        //
        if (n.name () == "AttributeRevocationValues" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< AttributeRevocationValuesType > r (
            AttributeRevocationValuesTraits::create (i, f, this));

          this->AttributeRevocationValues_.push_back (r);
          continue;
        }

        // ArchiveTimeStamp
        //
        if (n.name () == "ArchiveTimeStamp" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< ArchiveTimeStampType > r (
            ArchiveTimeStampTraits::create (i, f, this));

          this->ArchiveTimeStamp_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    UnsignedSignaturePropertiesType* UnsignedSignaturePropertiesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class UnsignedSignaturePropertiesType (*this, f, c);
    }

    UnsignedSignaturePropertiesType::
    ~UnsignedSignaturePropertiesType ()
    {
    }

    // UnsignedDataObjectPropertiesType
    //

    UnsignedDataObjectPropertiesType::
    UnsignedDataObjectPropertiesType ()
    : ::xml_schema::Type (),
      UnsignedDataObjectProperty_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    UnsignedDataObjectPropertiesType::
    UnsignedDataObjectPropertiesType (const UnsignedDataObjectPropertiesType& x,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      UnsignedDataObjectProperty_ (x.UnsignedDataObjectProperty_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    UnsignedDataObjectPropertiesType::
    UnsignedDataObjectPropertiesType (const xercesc::DOMElement& e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      UnsignedDataObjectProperty_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void UnsignedDataObjectPropertiesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // UnsignedDataObjectProperty
        //
        if (n.name () == "UnsignedDataObjectProperty" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< UnsignedDataObjectPropertyType > r (
            UnsignedDataObjectPropertyTraits::create (i, f, this));

          this->UnsignedDataObjectProperty_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    UnsignedDataObjectPropertiesType* UnsignedDataObjectPropertiesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class UnsignedDataObjectPropertiesType (*this, f, c);
    }

    UnsignedDataObjectPropertiesType::
    ~UnsignedDataObjectPropertiesType ()
    {
    }

    // QualifyingPropertiesReferenceType
    //

    QualifyingPropertiesReferenceType::
    QualifyingPropertiesReferenceType (const URIType& URI)
    : ::xml_schema::Type (),
      URI_ (URI, ::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    QualifyingPropertiesReferenceType::
    QualifyingPropertiesReferenceType (const QualifyingPropertiesReferenceType& x,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      URI_ (x.URI_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    QualifyingPropertiesReferenceType::
    QualifyingPropertiesReferenceType (const xercesc::DOMElement& e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      URI_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void QualifyingPropertiesReferenceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "URI" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< URIType > r (
            URITraits::create (i, f, this));

          this->URI_.set (r);
          continue;
        }

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }

      if (!URI_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "URI",
          "");
      }
    }

    QualifyingPropertiesReferenceType* QualifyingPropertiesReferenceType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class QualifyingPropertiesReferenceType (*this, f, c);
    }

    QualifyingPropertiesReferenceType::
    ~QualifyingPropertiesReferenceType ()
    {
    }

    // CertIDListType
    //

    CertIDListType::
    CertIDListType ()
    : ::xml_schema::Type (),
      Cert_ (::xml_schema::Flags (), this)
    {
    }

    CertIDListType::
    CertIDListType (const CertIDListType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Cert_ (x.Cert_, f, this)
    {
    }

    CertIDListType::
    CertIDListType (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Cert_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CertIDListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Cert
        //
        if (n.name () == "Cert" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CertType > r (
            CertTraits::create (i, f, this));

          this->Cert_.push_back (r);
          continue;
        }

        break;
      }
    }

    CertIDListType* CertIDListType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CertIDListType (*this, f, c);
    }

    CertIDListType::
    ~CertIDListType ()
    {
    }

    // CertIDType
    //

    CertIDType::
    CertIDType (const CertDigestType& CertDigest,
                const IssuerSerialType& IssuerSerial)
    : ::xml_schema::Type (),
      CertDigest_ (CertDigest, ::xml_schema::Flags (), this),
      IssuerSerial_ (IssuerSerial, ::xml_schema::Flags (), this),
      URI_ (::xml_schema::Flags (), this)
    {
    }

    CertIDType::
    CertIDType (::std::auto_ptr< CertDigestType >& CertDigest,
                ::std::auto_ptr< IssuerSerialType >& IssuerSerial)
    : ::xml_schema::Type (),
      CertDigest_ (CertDigest, ::xml_schema::Flags (), this),
      IssuerSerial_ (IssuerSerial, ::xml_schema::Flags (), this),
      URI_ (::xml_schema::Flags (), this)
    {
    }

    CertIDType::
    CertIDType (const CertIDType& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      CertDigest_ (x.CertDigest_, f, this),
      IssuerSerial_ (x.IssuerSerial_, f, this),
      URI_ (x.URI_, f, this)
    {
    }

    CertIDType::
    CertIDType (const xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      CertDigest_ (f, this),
      IssuerSerial_ (f, this),
      URI_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CertIDType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CertDigest
        //
        if (n.name () == "CertDigest" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CertDigestType > r (
            CertDigestTraits::create (i, f, this));

          if (!CertDigest_.present ())
          {
            this->CertDigest_.set (r);
            continue;
          }
        }

        // IssuerSerial
        //
        if (n.name () == "IssuerSerial" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< IssuerSerialType > r (
            IssuerSerialTraits::create (i, f, this));

          if (!IssuerSerial_.present ())
          {
            this->IssuerSerial_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CertDigest_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CertDigest",
          "http://uri.etsi.org/01903/v1.3.2#");
      }

      if (!IssuerSerial_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "IssuerSerial",
          "http://uri.etsi.org/01903/v1.3.2#");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "URI" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< URIType > r (
            URITraits::create (i, f, this));

          this->URI_.set (r);
          continue;
        }
      }
    }

    CertIDType* CertIDType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CertIDType (*this, f, c);
    }

    CertIDType::
    ~CertIDType ()
    {
    }

    // DigestAlgAndValueType
    //

    DigestAlgAndValueType::
    DigestAlgAndValueType (const DigestMethodType& DigestMethod,
                           const DigestValueType& DigestValue)
    : ::xml_schema::Type (),
      DigestMethod_ (DigestMethod, ::xml_schema::Flags (), this),
      DigestValue_ (DigestValue, ::xml_schema::Flags (), this)
    {
    }

    DigestAlgAndValueType::
    DigestAlgAndValueType (::std::auto_ptr< DigestMethodType >& DigestMethod,
                           const DigestValueType& DigestValue)
    : ::xml_schema::Type (),
      DigestMethod_ (DigestMethod, ::xml_schema::Flags (), this),
      DigestValue_ (DigestValue, ::xml_schema::Flags (), this)
    {
    }

    DigestAlgAndValueType::
    DigestAlgAndValueType (const DigestAlgAndValueType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      DigestMethod_ (x.DigestMethod_, f, this),
      DigestValue_ (x.DigestValue_, f, this)
    {
    }

    DigestAlgAndValueType::
    DigestAlgAndValueType (const xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      DigestMethod_ (f, this),
      DigestValue_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void DigestAlgAndValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DigestMethod
        //
        if (n.name () == "DigestMethod" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< DigestMethodType > r (
            DigestMethodTraits::create (i, f, this));

          if (!DigestMethod_.present ())
          {
            this->DigestMethod_.set (r);
            continue;
          }
        }

        // DigestValue
        //
        if (n.name () == "DigestValue" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< DigestValueType > r (
            DigestValueTraits::create (i, f, this));

          if (!DigestValue_.present ())
          {
            this->DigestValue_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DigestMethod_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DigestMethod",
          "http://www.w3.org/2000/09/xmldsig#");
      }

      if (!DigestValue_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DigestValue",
          "http://www.w3.org/2000/09/xmldsig#");
      }
    }

    DigestAlgAndValueType* DigestAlgAndValueType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DigestAlgAndValueType (*this, f, c);
    }

    DigestAlgAndValueType::
    ~DigestAlgAndValueType ()
    {
    }

    // SignaturePolicyIdentifierType
    //

    SignaturePolicyIdentifierType::
    SignaturePolicyIdentifierType ()
    : ::xml_schema::Type (),
      SignaturePolicyId_ (::xml_schema::Flags (), this),
      SignaturePolicyImplied_ (::xml_schema::Flags (), this)
    {
    }

    SignaturePolicyIdentifierType::
    SignaturePolicyIdentifierType (const SignaturePolicyIdentifierType& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      SignaturePolicyId_ (x.SignaturePolicyId_, f, this),
      SignaturePolicyImplied_ (x.SignaturePolicyImplied_, f, this)
    {
    }

    SignaturePolicyIdentifierType::
    SignaturePolicyIdentifierType (const xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      SignaturePolicyId_ (f, this),
      SignaturePolicyImplied_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SignaturePolicyIdentifierType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SignaturePolicyId
        //
        if (n.name () == "SignaturePolicyId" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< SignaturePolicyIdType > r (
            SignaturePolicyIdTraits::create (i, f, this));

          if (!this->SignaturePolicyId_)
          {
            this->SignaturePolicyId_.set (r);
            continue;
          }
        }

        // SignaturePolicyImplied
        //
        if (n.name () == "SignaturePolicyImplied" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< SignaturePolicyImpliedType > r (
            SignaturePolicyImpliedTraits::create (i, f, this));

          if (!this->SignaturePolicyImplied_)
          {
            this->SignaturePolicyImplied_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SignaturePolicyIdentifierType* SignaturePolicyIdentifierType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SignaturePolicyIdentifierType (*this, f, c);
    }

    SignaturePolicyIdentifierType::
    ~SignaturePolicyIdentifierType ()
    {
    }

    // SignaturePolicyIdType
    //

    SignaturePolicyIdType::
    SignaturePolicyIdType (const SigPolicyIdType& SigPolicyId,
                           const SigPolicyHashType& SigPolicyHash)
    : ::xml_schema::Type (),
      SigPolicyId_ (SigPolicyId, ::xml_schema::Flags (), this),
      Transforms_ (::xml_schema::Flags (), this),
      SigPolicyHash_ (SigPolicyHash, ::xml_schema::Flags (), this),
      SigPolicyQualifiers_ (::xml_schema::Flags (), this)
    {
    }

    SignaturePolicyIdType::
    SignaturePolicyIdType (::std::auto_ptr< SigPolicyIdType >& SigPolicyId,
                           ::std::auto_ptr< SigPolicyHashType >& SigPolicyHash)
    : ::xml_schema::Type (),
      SigPolicyId_ (SigPolicyId, ::xml_schema::Flags (), this),
      Transforms_ (::xml_schema::Flags (), this),
      SigPolicyHash_ (SigPolicyHash, ::xml_schema::Flags (), this),
      SigPolicyQualifiers_ (::xml_schema::Flags (), this)
    {
    }

    SignaturePolicyIdType::
    SignaturePolicyIdType (const SignaturePolicyIdType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      SigPolicyId_ (x.SigPolicyId_, f, this),
      Transforms_ (x.Transforms_, f, this),
      SigPolicyHash_ (x.SigPolicyHash_, f, this),
      SigPolicyQualifiers_ (x.SigPolicyQualifiers_, f, this)
    {
    }

    SignaturePolicyIdType::
    SignaturePolicyIdType (const xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      SigPolicyId_ (f, this),
      Transforms_ (f, this),
      SigPolicyHash_ (f, this),
      SigPolicyQualifiers_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SignaturePolicyIdType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SigPolicyId
        //
        if (n.name () == "SigPolicyId" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< SigPolicyIdType > r (
            SigPolicyIdTraits::create (i, f, this));

          if (!SigPolicyId_.present ())
          {
            this->SigPolicyId_.set (r);
            continue;
          }
        }

        // Transforms
        //
        if (n.name () == "Transforms" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< TransformsType > r (
            TransformsTraits::create (i, f, this));

          if (!this->Transforms_)
          {
            this->Transforms_.set (r);
            continue;
          }
        }

        // SigPolicyHash
        //
        if (n.name () == "SigPolicyHash" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< SigPolicyHashType > r (
            SigPolicyHashTraits::create (i, f, this));

          if (!SigPolicyHash_.present ())
          {
            this->SigPolicyHash_.set (r);
            continue;
          }
        }

        // SigPolicyQualifiers
        //
        if (n.name () == "SigPolicyQualifiers" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< SigPolicyQualifiersType > r (
            SigPolicyQualifiersTraits::create (i, f, this));

          if (!this->SigPolicyQualifiers_)
          {
            this->SigPolicyQualifiers_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SigPolicyId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SigPolicyId",
          "http://uri.etsi.org/01903/v1.3.2#");
      }

      if (!SigPolicyHash_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SigPolicyHash",
          "http://uri.etsi.org/01903/v1.3.2#");
      }
    }

    SignaturePolicyIdType* SignaturePolicyIdType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SignaturePolicyIdType (*this, f, c);
    }

    SignaturePolicyIdType::
    ~SignaturePolicyIdType ()
    {
    }

    // SigPolicyQualifiersListType
    //

    SigPolicyQualifiersListType::
    SigPolicyQualifiersListType ()
    : ::xml_schema::Type (),
      SigPolicyQualifier_ (::xml_schema::Flags (), this)
    {
    }

    SigPolicyQualifiersListType::
    SigPolicyQualifiersListType (const SigPolicyQualifiersListType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      SigPolicyQualifier_ (x.SigPolicyQualifier_, f, this)
    {
    }

    SigPolicyQualifiersListType::
    SigPolicyQualifiersListType (const xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      SigPolicyQualifier_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SigPolicyQualifiersListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SigPolicyQualifier
        //
        if (n.name () == "SigPolicyQualifier" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< SigPolicyQualifierType > r (
            SigPolicyQualifierTraits::create (i, f, this));

          this->SigPolicyQualifier_.push_back (r);
          continue;
        }

        break;
      }
    }

    SigPolicyQualifiersListType* SigPolicyQualifiersListType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SigPolicyQualifiersListType (*this, f, c);
    }

    SigPolicyQualifiersListType::
    ~SigPolicyQualifiersListType ()
    {
    }

    // SPUserNoticeType
    //

    SPUserNoticeType::
    SPUserNoticeType ()
    : ::xml_schema::Type (),
      NoticeRef_ (::xml_schema::Flags (), this),
      ExplicitText_ (::xml_schema::Flags (), this)
    {
    }

    SPUserNoticeType::
    SPUserNoticeType (const SPUserNoticeType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      NoticeRef_ (x.NoticeRef_, f, this),
      ExplicitText_ (x.ExplicitText_, f, this)
    {
    }

    SPUserNoticeType::
    SPUserNoticeType (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      NoticeRef_ (f, this),
      ExplicitText_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SPUserNoticeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // NoticeRef
        //
        if (n.name () == "NoticeRef" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< NoticeRefType > r (
            NoticeRefTraits::create (i, f, this));

          if (!this->NoticeRef_)
          {
            this->NoticeRef_.set (r);
            continue;
          }
        }

        // ExplicitText
        //
        if (n.name () == "ExplicitText" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< ExplicitTextType > r (
            ExplicitTextTraits::create (i, f, this));

          if (!this->ExplicitText_)
          {
            this->ExplicitText_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SPUserNoticeType* SPUserNoticeType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SPUserNoticeType (*this, f, c);
    }

    SPUserNoticeType::
    ~SPUserNoticeType ()
    {
    }

    // NoticeReferenceType
    //

    NoticeReferenceType::
    NoticeReferenceType (const OrganizationType& Organization,
                         const NoticeNumbersType& NoticeNumbers)
    : ::xml_schema::Type (),
      Organization_ (Organization, ::xml_schema::Flags (), this),
      NoticeNumbers_ (NoticeNumbers, ::xml_schema::Flags (), this)
    {
    }

    NoticeReferenceType::
    NoticeReferenceType (const OrganizationType& Organization,
                         ::std::auto_ptr< NoticeNumbersType >& NoticeNumbers)
    : ::xml_schema::Type (),
      Organization_ (Organization, ::xml_schema::Flags (), this),
      NoticeNumbers_ (NoticeNumbers, ::xml_schema::Flags (), this)
    {
    }

    NoticeReferenceType::
    NoticeReferenceType (const NoticeReferenceType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Organization_ (x.Organization_, f, this),
      NoticeNumbers_ (x.NoticeNumbers_, f, this)
    {
    }

    NoticeReferenceType::
    NoticeReferenceType (const xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Organization_ (f, this),
      NoticeNumbers_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void NoticeReferenceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Organization
        //
        if (n.name () == "Organization" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< OrganizationType > r (
            OrganizationTraits::create (i, f, this));

          if (!Organization_.present ())
          {
            this->Organization_.set (r);
            continue;
          }
        }

        // NoticeNumbers
        //
        if (n.name () == "NoticeNumbers" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< NoticeNumbersType > r (
            NoticeNumbersTraits::create (i, f, this));

          if (!NoticeNumbers_.present ())
          {
            this->NoticeNumbers_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Organization_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Organization",
          "http://uri.etsi.org/01903/v1.3.2#");
      }

      if (!NoticeNumbers_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "NoticeNumbers",
          "http://uri.etsi.org/01903/v1.3.2#");
      }
    }

    NoticeReferenceType* NoticeReferenceType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class NoticeReferenceType (*this, f, c);
    }

    NoticeReferenceType::
    ~NoticeReferenceType ()
    {
    }

    // IntegerListType
    //

    IntegerListType::
    IntegerListType ()
    : ::xml_schema::Type (),
      int__ (::xml_schema::Flags (), this)
    {
    }

    IntegerListType::
    IntegerListType (const IntegerListType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      int__ (x.int__, f, this)
    {
    }

    IntegerListType::
    IntegerListType (const xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      int__ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void IntegerListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // int
        //
        if (n.name () == "int" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          this->int__.push_back (IntTraits::create (i, f, this));
          continue;
        }

        break;
      }
    }

    IntegerListType* IntegerListType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IntegerListType (*this, f, c);
    }

    IntegerListType::
    ~IntegerListType ()
    {
    }

    // CounterSignatureType
    //

    CounterSignatureType::
    CounterSignatureType (const SignatureType& Signature)
    : ::xml_schema::Type (),
      Signature_ (Signature, ::xml_schema::Flags (), this)
    {
    }

    CounterSignatureType::
    CounterSignatureType (::std::auto_ptr< SignatureType >& Signature)
    : ::xml_schema::Type (),
      Signature_ (Signature, ::xml_schema::Flags (), this)
    {
    }

    CounterSignatureType::
    CounterSignatureType (const CounterSignatureType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Signature_ (x.Signature_, f, this)
    {
    }

    CounterSignatureType::
    CounterSignatureType (const xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Signature_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CounterSignatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Signature
        //
        if (n.name () == "Signature" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
        {
          ::std::auto_ptr< SignatureType > r (
            SignatureTraits::create (i, f, this));

          if (!Signature_.present ())
          {
            this->Signature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Signature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Signature",
          "http://www.w3.org/2000/09/xmldsig#");
      }
    }

    CounterSignatureType* CounterSignatureType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CounterSignatureType (*this, f, c);
    }

    CounterSignatureType::
    ~CounterSignatureType ()
    {
    }

    // DataObjectFormatType
    //

    DataObjectFormatType::
    DataObjectFormatType (const ObjectReferenceType& ObjectReference)
    : ::xml_schema::Type (),
      Description_ (::xml_schema::Flags (), this),
      ObjectIdentifier_ (::xml_schema::Flags (), this),
      MimeType_ (::xml_schema::Flags (), this),
      Encoding_ (::xml_schema::Flags (), this),
      ObjectReference_ (ObjectReference, ::xml_schema::Flags (), this)
    {
    }

    DataObjectFormatType::
    DataObjectFormatType (const DataObjectFormatType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Description_ (x.Description_, f, this),
      ObjectIdentifier_ (x.ObjectIdentifier_, f, this),
      MimeType_ (x.MimeType_, f, this),
      Encoding_ (x.Encoding_, f, this),
      ObjectReference_ (x.ObjectReference_, f, this)
    {
    }

    DataObjectFormatType::
    DataObjectFormatType (const xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Description_ (f, this),
      ObjectIdentifier_ (f, this),
      MimeType_ (f, this),
      Encoding_ (f, this),
      ObjectReference_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void DataObjectFormatType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Description
        //
        if (n.name () == "Description" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< DescriptionType > r (
            DescriptionTraits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (r);
            continue;
          }
        }

        // ObjectIdentifier
        //
        if (n.name () == "ObjectIdentifier" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< ObjectIdentifierType > r (
            ObjectIdentifierTraits::create (i, f, this));

          if (!this->ObjectIdentifier_)
          {
            this->ObjectIdentifier_.set (r);
            continue;
          }
        }

        // MimeType
        //
        if (n.name () == "MimeType" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< MimeTypeType > r (
            MimeTypeTraits::create (i, f, this));

          if (!this->MimeType_)
          {
            this->MimeType_.set (r);
            continue;
          }
        }

        // Encoding
        //
        if (n.name () == "Encoding" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< EncodingType > r (
            EncodingTraits::create (i, f, this));

          if (!this->Encoding_)
          {
            this->Encoding_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ObjectReference" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ObjectReferenceType > r (
            ObjectReferenceTraits::create (i, f, this));

          this->ObjectReference_.set (r);
          continue;
        }
      }

      if (!ObjectReference_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ObjectReference",
          "");
      }
    }

    DataObjectFormatType* DataObjectFormatType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DataObjectFormatType (*this, f, c);
    }

    DataObjectFormatType::
    ~DataObjectFormatType ()
    {
    }

    // CommitmentTypeIndicationType
    //

    CommitmentTypeIndicationType::
    CommitmentTypeIndicationType (const CommitmentTypeIdType& CommitmentTypeId)
    : ::xml_schema::Type (),
      CommitmentTypeId_ (CommitmentTypeId, ::xml_schema::Flags (), this),
      ObjectReference_ (::xml_schema::Flags (), this),
      AllSignedDataObjects_ (::xml_schema::Flags (), this),
      CommitmentTypeQualifiers_ (::xml_schema::Flags (), this)
    {
    }

    CommitmentTypeIndicationType::
    CommitmentTypeIndicationType (::std::auto_ptr< CommitmentTypeIdType >& CommitmentTypeId)
    : ::xml_schema::Type (),
      CommitmentTypeId_ (CommitmentTypeId, ::xml_schema::Flags (), this),
      ObjectReference_ (::xml_schema::Flags (), this),
      AllSignedDataObjects_ (::xml_schema::Flags (), this),
      CommitmentTypeQualifiers_ (::xml_schema::Flags (), this)
    {
    }

    CommitmentTypeIndicationType::
    CommitmentTypeIndicationType (const CommitmentTypeIndicationType& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      CommitmentTypeId_ (x.CommitmentTypeId_, f, this),
      ObjectReference_ (x.ObjectReference_, f, this),
      AllSignedDataObjects_ (x.AllSignedDataObjects_, f, this),
      CommitmentTypeQualifiers_ (x.CommitmentTypeQualifiers_, f, this)
    {
    }

    CommitmentTypeIndicationType::
    CommitmentTypeIndicationType (const xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      CommitmentTypeId_ (f, this),
      ObjectReference_ (f, this),
      AllSignedDataObjects_ (f, this),
      CommitmentTypeQualifiers_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CommitmentTypeIndicationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CommitmentTypeId
        //
        if (n.name () == "CommitmentTypeId" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CommitmentTypeIdType > r (
            CommitmentTypeIdTraits::create (i, f, this));

          if (!CommitmentTypeId_.present ())
          {
            this->CommitmentTypeId_.set (r);
            continue;
          }
        }

        // ObjectReference
        //
        if (n.name () == "ObjectReference" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< ObjectReferenceType > r (
            ObjectReferenceTraits::create (i, f, this));

          this->ObjectReference_.push_back (r);
          continue;
        }

        // AllSignedDataObjects
        //
        if (n.name () == "AllSignedDataObjects" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< AllSignedDataObjectsType > r (
            AllSignedDataObjectsTraits::create (i, f, this));

          if (!this->AllSignedDataObjects_)
          {
            this->AllSignedDataObjects_.set (r);
            continue;
          }
        }

        // CommitmentTypeQualifiers
        //
        if (n.name () == "CommitmentTypeQualifiers" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CommitmentTypeQualifiersType > r (
            CommitmentTypeQualifiersTraits::create (i, f, this));

          if (!this->CommitmentTypeQualifiers_)
          {
            this->CommitmentTypeQualifiers_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CommitmentTypeId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CommitmentTypeId",
          "http://uri.etsi.org/01903/v1.3.2#");
      }
    }

    CommitmentTypeIndicationType* CommitmentTypeIndicationType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CommitmentTypeIndicationType (*this, f, c);
    }

    CommitmentTypeIndicationType::
    ~CommitmentTypeIndicationType ()
    {
    }

    // CommitmentTypeQualifiersListType
    //

    CommitmentTypeQualifiersListType::
    CommitmentTypeQualifiersListType ()
    : ::xml_schema::Type (),
      CommitmentTypeQualifier_ (::xml_schema::Flags (), this)
    {
    }

    CommitmentTypeQualifiersListType::
    CommitmentTypeQualifiersListType (const CommitmentTypeQualifiersListType& x,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      CommitmentTypeQualifier_ (x.CommitmentTypeQualifier_, f, this)
    {
    }

    CommitmentTypeQualifiersListType::
    CommitmentTypeQualifiersListType (const xercesc::DOMElement& e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      CommitmentTypeQualifier_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CommitmentTypeQualifiersListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CommitmentTypeQualifier
        //
        if (n.name () == "CommitmentTypeQualifier" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CommitmentTypeQualifierType > r (
            CommitmentTypeQualifierTraits::create (i, f, this));

          this->CommitmentTypeQualifier_.push_back (r);
          continue;
        }

        break;
      }
    }

    CommitmentTypeQualifiersListType* CommitmentTypeQualifiersListType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CommitmentTypeQualifiersListType (*this, f, c);
    }

    CommitmentTypeQualifiersListType::
    ~CommitmentTypeQualifiersListType ()
    {
    }

    // SignatureProductionPlaceType
    //

    SignatureProductionPlaceType::
    SignatureProductionPlaceType ()
    : ::xml_schema::Type (),
      City_ (::xml_schema::Flags (), this),
      StateOrProvince_ (::xml_schema::Flags (), this),
      PostalCode_ (::xml_schema::Flags (), this),
      CountryName_ (::xml_schema::Flags (), this)
    {
    }

    SignatureProductionPlaceType::
    SignatureProductionPlaceType (const SignatureProductionPlaceType& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      City_ (x.City_, f, this),
      StateOrProvince_ (x.StateOrProvince_, f, this),
      PostalCode_ (x.PostalCode_, f, this),
      CountryName_ (x.CountryName_, f, this)
    {
    }

    SignatureProductionPlaceType::
    SignatureProductionPlaceType (const xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      City_ (f, this),
      StateOrProvince_ (f, this),
      PostalCode_ (f, this),
      CountryName_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SignatureProductionPlaceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // City
        //
        if (n.name () == "City" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CityType > r (
            CityTraits::create (i, f, this));

          if (!this->City_)
          {
            this->City_.set (r);
            continue;
          }
        }

        // StateOrProvince
        //
        if (n.name () == "StateOrProvince" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< StateOrProvinceType > r (
            StateOrProvinceTraits::create (i, f, this));

          if (!this->StateOrProvince_)
          {
            this->StateOrProvince_.set (r);
            continue;
          }
        }

        // PostalCode
        //
        if (n.name () == "PostalCode" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< PostalCodeType > r (
            PostalCodeTraits::create (i, f, this));

          if (!this->PostalCode_)
          {
            this->PostalCode_.set (r);
            continue;
          }
        }

        // CountryName
        //
        if (n.name () == "CountryName" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CountryNameType > r (
            CountryNameTraits::create (i, f, this));

          if (!this->CountryName_)
          {
            this->CountryName_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SignatureProductionPlaceType* SignatureProductionPlaceType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SignatureProductionPlaceType (*this, f, c);
    }

    SignatureProductionPlaceType::
    ~SignatureProductionPlaceType ()
    {
    }

    // SignerRoleType
    //

    SignerRoleType::
    SignerRoleType ()
    : ::xml_schema::Type (),
      ClaimedRoles_ (::xml_schema::Flags (), this),
      CertifiedRoles_ (::xml_schema::Flags (), this)
    {
    }

    SignerRoleType::
    SignerRoleType (const SignerRoleType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      ClaimedRoles_ (x.ClaimedRoles_, f, this),
      CertifiedRoles_ (x.CertifiedRoles_, f, this)
    {
    }

    SignerRoleType::
    SignerRoleType (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      ClaimedRoles_ (f, this),
      CertifiedRoles_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SignerRoleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ClaimedRoles
        //
        if (n.name () == "ClaimedRoles" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< ClaimedRolesType > r (
            ClaimedRolesTraits::create (i, f, this));

          if (!this->ClaimedRoles_)
          {
            this->ClaimedRoles_.set (r);
            continue;
          }
        }

        // CertifiedRoles
        //
        if (n.name () == "CertifiedRoles" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CertifiedRolesType > r (
            CertifiedRolesTraits::create (i, f, this));

          if (!this->CertifiedRoles_)
          {
            this->CertifiedRoles_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SignerRoleType* SignerRoleType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SignerRoleType (*this, f, c);
    }

    SignerRoleType::
    ~SignerRoleType ()
    {
    }

    // ClaimedRolesListType
    //

    ClaimedRolesListType::
    ClaimedRolesListType ()
    : ::xml_schema::Type (),
      ClaimedRole_ (::xml_schema::Flags (), this)
    {
    }

    ClaimedRolesListType::
    ClaimedRolesListType (const ClaimedRolesListType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      ClaimedRole_ (x.ClaimedRole_, f, this)
    {
    }

    ClaimedRolesListType::
    ClaimedRolesListType (const xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      ClaimedRole_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ClaimedRolesListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ClaimedRole
        //
        if (n.name () == "ClaimedRole" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< ClaimedRoleType > r (
            ClaimedRoleTraits::create (i, f, this));

          this->ClaimedRole_.push_back (r);
          continue;
        }

        break;
      }
    }

    ClaimedRolesListType* ClaimedRolesListType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ClaimedRolesListType (*this, f, c);
    }

    ClaimedRolesListType::
    ~ClaimedRolesListType ()
    {
    }

    // CertifiedRolesListType
    //

    CertifiedRolesListType::
    CertifiedRolesListType ()
    : ::xml_schema::Type (),
      CertifiedRole_ (::xml_schema::Flags (), this)
    {
    }

    CertifiedRolesListType::
    CertifiedRolesListType (const CertifiedRolesListType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      CertifiedRole_ (x.CertifiedRole_, f, this)
    {
    }

    CertifiedRolesListType::
    CertifiedRolesListType (const xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      CertifiedRole_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CertifiedRolesListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CertifiedRole
        //
        if (n.name () == "CertifiedRole" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CertifiedRoleType > r (
            CertifiedRoleTraits::create (i, f, this));

          this->CertifiedRole_.push_back (r);
          continue;
        }

        break;
      }
    }

    CertifiedRolesListType* CertifiedRolesListType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CertifiedRolesListType (*this, f, c);
    }

    CertifiedRolesListType::
    ~CertifiedRolesListType ()
    {
    }

    // CompleteCertificateRefsType
    //

    CompleteCertificateRefsType::
    CompleteCertificateRefsType (const CertRefsType& CertRefs)
    : ::xml_schema::Type (),
      CertRefs_ (CertRefs, ::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    CompleteCertificateRefsType::
    CompleteCertificateRefsType (::std::auto_ptr< CertRefsType >& CertRefs)
    : ::xml_schema::Type (),
      CertRefs_ (CertRefs, ::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    CompleteCertificateRefsType::
    CompleteCertificateRefsType (const CompleteCertificateRefsType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      CertRefs_ (x.CertRefs_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    CompleteCertificateRefsType::
    CompleteCertificateRefsType (const xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      CertRefs_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CompleteCertificateRefsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CertRefs
        //
        if (n.name () == "CertRefs" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CertRefsType > r (
            CertRefsTraits::create (i, f, this));

          if (!CertRefs_.present ())
          {
            this->CertRefs_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CertRefs_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CertRefs",
          "http://uri.etsi.org/01903/v1.3.2#");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    CompleteCertificateRefsType* CompleteCertificateRefsType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CompleteCertificateRefsType (*this, f, c);
    }

    CompleteCertificateRefsType::
    ~CompleteCertificateRefsType ()
    {
    }

    // CompleteRevocationRefsType
    //

    CompleteRevocationRefsType::
    CompleteRevocationRefsType ()
    : ::xml_schema::Type (),
      CRLRefs_ (::xml_schema::Flags (), this),
      OCSPRefs_ (::xml_schema::Flags (), this),
      OtherRefs_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    CompleteRevocationRefsType::
    CompleteRevocationRefsType (const CompleteRevocationRefsType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      CRLRefs_ (x.CRLRefs_, f, this),
      OCSPRefs_ (x.OCSPRefs_, f, this),
      OtherRefs_ (x.OtherRefs_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    CompleteRevocationRefsType::
    CompleteRevocationRefsType (const xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      CRLRefs_ (f, this),
      OCSPRefs_ (f, this),
      OtherRefs_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CompleteRevocationRefsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CRLRefs
        //
        if (n.name () == "CRLRefs" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CRLRefsType > r (
            CRLRefsTraits::create (i, f, this));

          if (!this->CRLRefs_)
          {
            this->CRLRefs_.set (r);
            continue;
          }
        }

        // OCSPRefs
        //
        if (n.name () == "OCSPRefs" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< OCSPRefsType > r (
            OCSPRefsTraits::create (i, f, this));

          if (!this->OCSPRefs_)
          {
            this->OCSPRefs_.set (r);
            continue;
          }
        }

        // OtherRefs
        //
        if (n.name () == "OtherRefs" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< OtherRefsType > r (
            OtherRefsTraits::create (i, f, this));

          if (!this->OtherRefs_)
          {
            this->OtherRefs_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    CompleteRevocationRefsType* CompleteRevocationRefsType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CompleteRevocationRefsType (*this, f, c);
    }

    CompleteRevocationRefsType::
    ~CompleteRevocationRefsType ()
    {
    }

    // CRLRefsType
    //

    CRLRefsType::
    CRLRefsType ()
    : ::xml_schema::Type (),
      CRLRef_ (::xml_schema::Flags (), this)
    {
    }

    CRLRefsType::
    CRLRefsType (const CRLRefsType& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      CRLRef_ (x.CRLRef_, f, this)
    {
    }

    CRLRefsType::
    CRLRefsType (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      CRLRef_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CRLRefsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CRLRef
        //
        if (n.name () == "CRLRef" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CRLRefType > r (
            CRLRefTraits::create (i, f, this));

          this->CRLRef_.push_back (r);
          continue;
        }

        break;
      }
    }

    CRLRefsType* CRLRefsType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CRLRefsType (*this, f, c);
    }

    CRLRefsType::
    ~CRLRefsType ()
    {
    }

    // CRLRefType
    //

    CRLRefType::
    CRLRefType (const DigestAlgAndValueType& DigestAlgAndValue)
    : ::xml_schema::Type (),
      DigestAlgAndValue_ (DigestAlgAndValue, ::xml_schema::Flags (), this),
      CRLIdentifier_ (::xml_schema::Flags (), this)
    {
    }

    CRLRefType::
    CRLRefType (::std::auto_ptr< DigestAlgAndValueType >& DigestAlgAndValue)
    : ::xml_schema::Type (),
      DigestAlgAndValue_ (DigestAlgAndValue, ::xml_schema::Flags (), this),
      CRLIdentifier_ (::xml_schema::Flags (), this)
    {
    }

    CRLRefType::
    CRLRefType (const CRLRefType& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      DigestAlgAndValue_ (x.DigestAlgAndValue_, f, this),
      CRLIdentifier_ (x.CRLIdentifier_, f, this)
    {
    }

    CRLRefType::
    CRLRefType (const xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      DigestAlgAndValue_ (f, this),
      CRLIdentifier_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CRLRefType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DigestAlgAndValue
        //
        if (n.name () == "DigestAlgAndValue" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< DigestAlgAndValueType > r (
            DigestAlgAndValueTraits::create (i, f, this));

          if (!DigestAlgAndValue_.present ())
          {
            this->DigestAlgAndValue_.set (r);
            continue;
          }
        }

        // CRLIdentifier
        //
        if (n.name () == "CRLIdentifier" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CRLIdentifierType > r (
            CRLIdentifierTraits::create (i, f, this));

          if (!this->CRLIdentifier_)
          {
            this->CRLIdentifier_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DigestAlgAndValue_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DigestAlgAndValue",
          "http://uri.etsi.org/01903/v1.3.2#");
      }
    }

    CRLRefType* CRLRefType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CRLRefType (*this, f, c);
    }

    CRLRefType::
    ~CRLRefType ()
    {
    }

    // CRLIdentifierType
    //

    CRLIdentifierType::
    CRLIdentifierType (const IssuerType& Issuer,
                       const IssueTimeType& IssueTime)
    : ::xml_schema::Type (),
      Issuer_ (Issuer, ::xml_schema::Flags (), this),
      IssueTime_ (IssueTime, ::xml_schema::Flags (), this),
      Number_ (::xml_schema::Flags (), this),
      URI_ (::xml_schema::Flags (), this)
    {
    }

    CRLIdentifierType::
    CRLIdentifierType (const CRLIdentifierType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Issuer_ (x.Issuer_, f, this),
      IssueTime_ (x.IssueTime_, f, this),
      Number_ (x.Number_, f, this),
      URI_ (x.URI_, f, this)
    {
    }

    CRLIdentifierType::
    CRLIdentifierType (const xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Issuer_ (f, this),
      IssueTime_ (f, this),
      Number_ (f, this),
      URI_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CRLIdentifierType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Issuer
        //
        if (n.name () == "Issuer" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< IssuerType > r (
            IssuerTraits::create (i, f, this));

          if (!Issuer_.present ())
          {
            this->Issuer_.set (r);
            continue;
          }
        }

        // IssueTime
        //
        if (n.name () == "IssueTime" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< IssueTimeType > r (
            IssueTimeTraits::create (i, f, this));

          if (!IssueTime_.present ())
          {
            this->IssueTime_.set (r);
            continue;
          }
        }

        // Number
        //
        if (n.name () == "Number" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          if (!this->Number_)
          {
            this->Number_.set (NumberTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!Issuer_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Issuer",
          "http://uri.etsi.org/01903/v1.3.2#");
      }

      if (!IssueTime_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "IssueTime",
          "http://uri.etsi.org/01903/v1.3.2#");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "URI" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< URIType > r (
            URITraits::create (i, f, this));

          this->URI_.set (r);
          continue;
        }
      }
    }

    CRLIdentifierType* CRLIdentifierType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CRLIdentifierType (*this, f, c);
    }

    CRLIdentifierType::
    ~CRLIdentifierType ()
    {
    }

    // OCSPRefsType
    //

    OCSPRefsType::
    OCSPRefsType ()
    : ::xml_schema::Type (),
      OCSPRef_ (::xml_schema::Flags (), this)
    {
    }

    OCSPRefsType::
    OCSPRefsType (const OCSPRefsType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      OCSPRef_ (x.OCSPRef_, f, this)
    {
    }

    OCSPRefsType::
    OCSPRefsType (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      OCSPRef_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OCSPRefsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // OCSPRef
        //
        if (n.name () == "OCSPRef" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< OCSPRefType > r (
            OCSPRefTraits::create (i, f, this));

          this->OCSPRef_.push_back (r);
          continue;
        }

        break;
      }
    }

    OCSPRefsType* OCSPRefsType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class OCSPRefsType (*this, f, c);
    }

    OCSPRefsType::
    ~OCSPRefsType ()
    {
    }

    // OCSPRefType
    //

    OCSPRefType::
    OCSPRefType (const OCSPIdentifierType& OCSPIdentifier)
    : ::xml_schema::Type (),
      OCSPIdentifier_ (OCSPIdentifier, ::xml_schema::Flags (), this),
      DigestAlgAndValue_ (::xml_schema::Flags (), this)
    {
    }

    OCSPRefType::
    OCSPRefType (::std::auto_ptr< OCSPIdentifierType >& OCSPIdentifier)
    : ::xml_schema::Type (),
      OCSPIdentifier_ (OCSPIdentifier, ::xml_schema::Flags (), this),
      DigestAlgAndValue_ (::xml_schema::Flags (), this)
    {
    }

    OCSPRefType::
    OCSPRefType (const OCSPRefType& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      OCSPIdentifier_ (x.OCSPIdentifier_, f, this),
      DigestAlgAndValue_ (x.DigestAlgAndValue_, f, this)
    {
    }

    OCSPRefType::
    OCSPRefType (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      OCSPIdentifier_ (f, this),
      DigestAlgAndValue_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OCSPRefType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // OCSPIdentifier
        //
        if (n.name () == "OCSPIdentifier" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< OCSPIdentifierType > r (
            OCSPIdentifierTraits::create (i, f, this));

          if (!OCSPIdentifier_.present ())
          {
            this->OCSPIdentifier_.set (r);
            continue;
          }
        }

        // DigestAlgAndValue
        //
        if (n.name () == "DigestAlgAndValue" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< DigestAlgAndValueType > r (
            DigestAlgAndValueTraits::create (i, f, this));

          if (!this->DigestAlgAndValue_)
          {
            this->DigestAlgAndValue_.set (r);
            continue;
          }
        }

        break;
      }

      if (!OCSPIdentifier_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "OCSPIdentifier",
          "http://uri.etsi.org/01903/v1.3.2#");
      }
    }

    OCSPRefType* OCSPRefType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class OCSPRefType (*this, f, c);
    }

    OCSPRefType::
    ~OCSPRefType ()
    {
    }

    // ResponderIDType
    //

    ResponderIDType::
    ResponderIDType ()
    : ::xml_schema::Type (),
      ByName_ (::xml_schema::Flags (), this),
      ByKey_ (::xml_schema::Flags (), this)
    {
    }

    ResponderIDType::
    ResponderIDType (const ResponderIDType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      ByName_ (x.ByName_, f, this),
      ByKey_ (x.ByKey_, f, this)
    {
    }

    ResponderIDType::
    ResponderIDType (const xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      ByName_ (f, this),
      ByKey_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ResponderIDType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ByName
        //
        if (n.name () == "ByName" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< ByNameType > r (
            ByNameTraits::create (i, f, this));

          if (!this->ByName_)
          {
            this->ByName_.set (r);
            continue;
          }
        }

        // ByKey
        //
        if (n.name () == "ByKey" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< ByKeyType > r (
            ByKeyTraits::create (i, f, this));

          if (!this->ByKey_)
          {
            this->ByKey_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ResponderIDType* ResponderIDType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ResponderIDType (*this, f, c);
    }

    ResponderIDType::
    ~ResponderIDType ()
    {
    }

    // OCSPIdentifierType
    //

    OCSPIdentifierType::
    OCSPIdentifierType (const ResponderIDType& ResponderID,
                        const ProducedAtType& ProducedAt)
    : ::xml_schema::Type (),
      ResponderID_ (ResponderID, ::xml_schema::Flags (), this),
      ProducedAt_ (ProducedAt, ::xml_schema::Flags (), this),
      URI_ (::xml_schema::Flags (), this)
    {
    }

    OCSPIdentifierType::
    OCSPIdentifierType (::std::auto_ptr< ResponderIDType >& ResponderID,
                        const ProducedAtType& ProducedAt)
    : ::xml_schema::Type (),
      ResponderID_ (ResponderID, ::xml_schema::Flags (), this),
      ProducedAt_ (ProducedAt, ::xml_schema::Flags (), this),
      URI_ (::xml_schema::Flags (), this)
    {
    }

    OCSPIdentifierType::
    OCSPIdentifierType (const OCSPIdentifierType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      ResponderID_ (x.ResponderID_, f, this),
      ProducedAt_ (x.ProducedAt_, f, this),
      URI_ (x.URI_, f, this)
    {
    }

    OCSPIdentifierType::
    OCSPIdentifierType (const xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      ResponderID_ (f, this),
      ProducedAt_ (f, this),
      URI_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void OCSPIdentifierType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ResponderID
        //
        if (n.name () == "ResponderID" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< ResponderIDType > r (
            ResponderIDTraits::create (i, f, this));

          if (!ResponderID_.present ())
          {
            this->ResponderID_.set (r);
            continue;
          }
        }

        // ProducedAt
        //
        if (n.name () == "ProducedAt" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< ProducedAtType > r (
            ProducedAtTraits::create (i, f, this));

          if (!ProducedAt_.present ())
          {
            this->ProducedAt_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ResponderID_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ResponderID",
          "http://uri.etsi.org/01903/v1.3.2#");
      }

      if (!ProducedAt_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProducedAt",
          "http://uri.etsi.org/01903/v1.3.2#");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "URI" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< URIType > r (
            URITraits::create (i, f, this));

          this->URI_.set (r);
          continue;
        }
      }
    }

    OCSPIdentifierType* OCSPIdentifierType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class OCSPIdentifierType (*this, f, c);
    }

    OCSPIdentifierType::
    ~OCSPIdentifierType ()
    {
    }

    // OtherCertStatusRefsType
    //

    OtherCertStatusRefsType::
    OtherCertStatusRefsType ()
    : ::xml_schema::Type (),
      OtherRef_ (::xml_schema::Flags (), this)
    {
    }

    OtherCertStatusRefsType::
    OtherCertStatusRefsType (const OtherCertStatusRefsType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      OtherRef_ (x.OtherRef_, f, this)
    {
    }

    OtherCertStatusRefsType::
    OtherCertStatusRefsType (const xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      OtherRef_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OtherCertStatusRefsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // OtherRef
        //
        if (n.name () == "OtherRef" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< OtherRefType > r (
            OtherRefTraits::create (i, f, this));

          this->OtherRef_.push_back (r);
          continue;
        }

        break;
      }
    }

    OtherCertStatusRefsType* OtherCertStatusRefsType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class OtherCertStatusRefsType (*this, f, c);
    }

    OtherCertStatusRefsType::
    ~OtherCertStatusRefsType ()
    {
    }

    // CertificateValuesType
    //

    CertificateValuesType::
    CertificateValuesType ()
    : ::xml_schema::Type (),
      EncapsulatedX509Certificate_ (::xml_schema::Flags (), this),
      OtherCertificate_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    CertificateValuesType::
    CertificateValuesType (const CertificateValuesType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EncapsulatedX509Certificate_ (x.EncapsulatedX509Certificate_, f, this),
      OtherCertificate_ (x.OtherCertificate_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    CertificateValuesType::
    CertificateValuesType (const xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EncapsulatedX509Certificate_ (f, this),
      OtherCertificate_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CertificateValuesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EncapsulatedX509Certificate
        //
        if (n.name () == "EncapsulatedX509Certificate" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< EncapsulatedX509CertificateType > r (
            EncapsulatedX509CertificateTraits::create (i, f, this));

          this->EncapsulatedX509Certificate_.push_back (r);
          continue;
        }

        // OtherCertificate
        //
        if (n.name () == "OtherCertificate" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< OtherCertificateType > r (
            OtherCertificateTraits::create (i, f, this));

          this->OtherCertificate_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    CertificateValuesType* CertificateValuesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CertificateValuesType (*this, f, c);
    }

    CertificateValuesType::
    ~CertificateValuesType ()
    {
    }

    // RevocationValuesType
    //

    RevocationValuesType::
    RevocationValuesType ()
    : ::xml_schema::Type (),
      CRLValues_ (::xml_schema::Flags (), this),
      OCSPValues_ (::xml_schema::Flags (), this),
      OtherValues_ (::xml_schema::Flags (), this),
      Id_ (::xml_schema::Flags (), this)
    {
    }

    RevocationValuesType::
    RevocationValuesType (const RevocationValuesType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      CRLValues_ (x.CRLValues_, f, this),
      OCSPValues_ (x.OCSPValues_, f, this),
      OtherValues_ (x.OtherValues_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    RevocationValuesType::
    RevocationValuesType (const xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      CRLValues_ (f, this),
      OCSPValues_ (f, this),
      OtherValues_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void RevocationValuesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CRLValues
        //
        if (n.name () == "CRLValues" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< CRLValuesType > r (
            CRLValuesTraits::create (i, f, this));

          if (!this->CRLValues_)
          {
            this->CRLValues_.set (r);
            continue;
          }
        }

        // OCSPValues
        //
        if (n.name () == "OCSPValues" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< OCSPValuesType > r (
            OCSPValuesTraits::create (i, f, this));

          if (!this->OCSPValues_)
          {
            this->OCSPValues_.set (r);
            continue;
          }
        }

        // OtherValues
        //
        if (n.name () == "OtherValues" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< OtherValuesType > r (
            OtherValuesTraits::create (i, f, this));

          if (!this->OtherValues_)
          {
            this->OtherValues_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    RevocationValuesType* RevocationValuesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class RevocationValuesType (*this, f, c);
    }

    RevocationValuesType::
    ~RevocationValuesType ()
    {
    }

    // CRLValuesType
    //

    CRLValuesType::
    CRLValuesType ()
    : ::xml_schema::Type (),
      EncapsulatedCRLValue_ (::xml_schema::Flags (), this)
    {
    }

    CRLValuesType::
    CRLValuesType (const CRLValuesType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EncapsulatedCRLValue_ (x.EncapsulatedCRLValue_, f, this)
    {
    }

    CRLValuesType::
    CRLValuesType (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EncapsulatedCRLValue_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CRLValuesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EncapsulatedCRLValue
        //
        if (n.name () == "EncapsulatedCRLValue" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< EncapsulatedCRLValueType > r (
            EncapsulatedCRLValueTraits::create (i, f, this));

          this->EncapsulatedCRLValue_.push_back (r);
          continue;
        }

        break;
      }
    }

    CRLValuesType* CRLValuesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CRLValuesType (*this, f, c);
    }

    CRLValuesType::
    ~CRLValuesType ()
    {
    }

    // OCSPValuesType
    //

    OCSPValuesType::
    OCSPValuesType ()
    : ::xml_schema::Type (),
      EncapsulatedOCSPValue_ (::xml_schema::Flags (), this)
    {
    }

    OCSPValuesType::
    OCSPValuesType (const OCSPValuesType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EncapsulatedOCSPValue_ (x.EncapsulatedOCSPValue_, f, this)
    {
    }

    OCSPValuesType::
    OCSPValuesType (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EncapsulatedOCSPValue_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OCSPValuesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EncapsulatedOCSPValue
        //
        if (n.name () == "EncapsulatedOCSPValue" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< EncapsulatedOCSPValueType > r (
            EncapsulatedOCSPValueTraits::create (i, f, this));

          this->EncapsulatedOCSPValue_.push_back (r);
          continue;
        }

        break;
      }
    }

    OCSPValuesType* OCSPValuesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class OCSPValuesType (*this, f, c);
    }

    OCSPValuesType::
    ~OCSPValuesType ()
    {
    }

    // OtherCertStatusValuesType
    //

    OtherCertStatusValuesType::
    OtherCertStatusValuesType ()
    : ::xml_schema::Type (),
      OtherValue_ (::xml_schema::Flags (), this)
    {
    }

    OtherCertStatusValuesType::
    OtherCertStatusValuesType (const OtherCertStatusValuesType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      OtherValue_ (x.OtherValue_, f, this)
    {
    }

    OtherCertStatusValuesType::
    OtherCertStatusValuesType (const xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      OtherValue_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OtherCertStatusValuesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // OtherValue
        //
        if (n.name () == "OtherValue" && n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
        {
          ::std::auto_ptr< OtherValueType > r (
            OtherValueTraits::create (i, f, this));

          this->OtherValue_.push_back (r);
          continue;
        }

        break;
      }
    }

    OtherCertStatusValuesType* OtherCertStatusValuesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class OtherCertStatusValuesType (*this, f, c);
    }

    OtherCertStatusValuesType::
    ~OtherCertStatusValuesType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace digidoc
{
  namespace xades
  {
    ::std::auto_ptr< ::digidoc::xades::AnyType >
    any (const ::std::string& u,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::digidoc::xades::AnyType > r (
        ::digidoc::xades::any (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::digidoc::xades::AnyType >
    any (const ::std::string& u,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::digidoc::xades::AnyType > r (
        ::digidoc::xades::any (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::digidoc::xades::AnyType >
    any (const ::std::string& u,
         xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::digidoc::xades::AnyType > r (
        ::digidoc::xades::any (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::digidoc::xades::AnyType >
    any (::std::istream& is,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::digidoc::xades::any (isrc, f, p);
    }

    ::std::auto_ptr< ::digidoc::xades::AnyType >
    any (::std::istream& is,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::digidoc::xades::any (isrc, h, f, p);
    }

    ::std::auto_ptr< ::digidoc::xades::AnyType >
    any (::std::istream& is,
         xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::digidoc::xades::any (isrc, h, f, p);
    }

    ::std::auto_ptr< ::digidoc::xades::AnyType >
    any (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::digidoc::xades::any (isrc, f, p);
    }

    ::std::auto_ptr< ::digidoc::xades::AnyType >
    any (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::digidoc::xades::any (isrc, h, f, p);
    }

    ::std::auto_ptr< ::digidoc::xades::AnyType >
    any (::std::istream& is,
         const ::std::string& sid,
         xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::digidoc::xades::any (isrc, h, f, p);
    }

    ::std::auto_ptr< ::digidoc::xades::AnyType >
    any (xercesc::InputSource& i,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::digidoc::xades::AnyType > r (
        ::digidoc::xades::any (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::digidoc::xades::AnyType >
    any (xercesc::InputSource& i,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::digidoc::xades::AnyType > r (
        ::digidoc::xades::any (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::digidoc::xades::AnyType >
    any (xercesc::InputSource& i,
         xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::digidoc::xades::AnyType > r (
        ::digidoc::xades::any (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::digidoc::xades::AnyType >
    any (const xercesc::DOMDocument& d,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > c (
          static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::digidoc::xades::AnyType > r (
          ::digidoc::xades::any (
            c, f | ::xml_schema::Flags::own_dom, p));

        return r;
      }

      const xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Any" &&
          n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
      {
        ::std::auto_ptr< ::digidoc::xades::AnyType > r (
          ::xsd::cxx::tree::traits< ::digidoc::xades::AnyType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Any",
        "http://uri.etsi.org/01903/v1.3.2#");
    }

    ::std::auto_ptr< ::digidoc::xades::AnyType >
    any (::xml_schema::dom::auto_ptr< xercesc::DOMDocument >& d,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Any" &&
          n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
      {
        ::std::auto_ptr< ::digidoc::xades::AnyType > r (
          ::xsd::cxx::tree::traits< ::digidoc::xades::AnyType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Any",
        "http://uri.etsi.org/01903/v1.3.2#");
    }
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace digidoc
{
  namespace xades
  {
    void
    any (::std::ostream& o,
         const ::digidoc::xades::AnyType& s,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::digidoc::xades::any (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    any (::std::ostream& o,
         const ::digidoc::xades::AnyType& s,
         ::xml_schema::ErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::digidoc::xades::any (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    any (::std::ostream& o,
         const ::digidoc::xades::AnyType& s,
         xercesc::DOMErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::digidoc::xades::any (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    any (xercesc::XMLFormatTarget& t,
         const ::digidoc::xades::AnyType& s,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::digidoc::xades::any (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    any (xercesc::XMLFormatTarget& t,
         const ::digidoc::xades::AnyType& s,
         ::xml_schema::ErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::digidoc::xades::any (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    any (xercesc::XMLFormatTarget& t,
         const ::digidoc::xades::AnyType& s,
         xercesc::DOMErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::digidoc::xades::any (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    any (xercesc::DOMDocument& d,
         const ::digidoc::xades::AnyType& s,
         ::xml_schema::Flags)
    {
      xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Any" &&
          n.namespace_ () == "http://uri.etsi.org/01903/v1.3.2#")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "Any",
          "http://uri.etsi.org/01903/v1.3.2#");
      }
    }

    ::xml_schema::dom::auto_ptr< xercesc::DOMDocument >
    any (const ::digidoc::xades::AnyType& s,
         const ::xml_schema::NamespaceInfomap& m,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "Any",
          "http://uri.etsi.org/01903/v1.3.2#",
          m, f));

      ::digidoc::xades::any (*d, s, f);
      return d;
    }

    void
    operator<< (xercesc::DOMElement& e, const AnyType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ObjectIdentifierType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Identifier
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Identifier",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << i.identifier ();
      }

      // Description
      //
      if (i.description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Description",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.description ();
      }

      // DocumentationReferences
      //
      if (i.documentationReferences ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DocumentationReferences",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.documentationReferences ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IdentifierType& i)
    {
      e << static_cast< const ::xml_schema::Uri& > (i);

      // Qualifier
      //
      if (i.qualifier ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Qualifier",
            e));

        a << *i.qualifier ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const QualifierType& i)
    {
      e << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const QualifierType& i)
    {
      a << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const QualifierType& i)
    {
      l << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const DocumentationReferencesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // DocumentationReference
      //
      for (DocumentationReferencesType::DocumentationReferenceConstIterator
           b (i.documentationReference ().begin ()), n (i.documentationReference ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DocumentationReference",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EncapsulatedPKIDataType& i)
    {
      e << static_cast< const ::xml_schema::Base64Binary& > (i);

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }

      // Encoding
      //
      if (i.encoding ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Encoding",
            e));

        a << *i.encoding ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IncludeType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // URI
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "URI",
            e));

        a << i.uRI ();
      }

      // referencedData
      //
      if (i.referencedData ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "referencedData",
            e));

        a << *i.referencedData ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ReferenceInfoType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // DigestMethod
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DigestMethod",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << i.digestMethod ();
      }

      // DigestValue
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DigestValue",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << i.digestValue ();
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }

      // URI
      //
      if (i.uRI ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "URI",
            e));

        a << *i.uRI ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const GenericTimeStampType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Include
      //
      for (GenericTimeStampType::IncludeConstIterator
           b (i.include ().begin ()), n (i.include ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Include",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // ReferenceInfo
      //
      for (GenericTimeStampType::ReferenceInfoConstIterator
           b (i.referenceInfo ().begin ()), n (i.referenceInfo ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ReferenceInfo",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // CanonicalizationMethod
      //
      if (i.canonicalizationMethod ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CanonicalizationMethod",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *i.canonicalizationMethod ();
      }

      // EncapsulatedTimeStamp
      //
      for (GenericTimeStampType::EncapsulatedTimeStampConstIterator
           b (i.encapsulatedTimeStamp ().begin ()), n (i.encapsulatedTimeStamp ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EncapsulatedTimeStamp",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // XMLTimeStamp
      //
      for (GenericTimeStampType::XMLTimeStampConstIterator
           b (i.xMLTimeStamp ().begin ()), n (i.xMLTimeStamp ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XMLTimeStamp",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const XAdESTimeStampType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Include
      //
      for (XAdESTimeStampType::IncludeConstIterator
           b (i.include ().begin ()), n (i.include ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Include",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // CanonicalizationMethod
      //
      if (i.canonicalizationMethod ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CanonicalizationMethod",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *i.canonicalizationMethod ();
      }

      // EncapsulatedTimeStamp
      //
      for (XAdESTimeStampType::EncapsulatedTimeStampConstIterator
           b (i.encapsulatedTimeStamp ().begin ()), n (i.encapsulatedTimeStamp ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EncapsulatedTimeStamp",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // XMLTimeStamp
      //
      for (XAdESTimeStampType::XMLTimeStampConstIterator
           b (i.xMLTimeStamp ().begin ()), n (i.xMLTimeStamp ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XMLTimeStamp",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherTimeStampType& i)
    {
      e << static_cast< const ::digidoc::xades::GenericTimeStampType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const QualifyingPropertiesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // SignedProperties
      //
      if (i.signedProperties ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SignedProperties",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.signedProperties ();
      }

      // UnsignedProperties
      //
      if (i.unsignedProperties ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnsignedProperties",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.unsignedProperties ();
      }

      // Target
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Target",
            e));

        a << i.target ();
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SignedPropertiesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // SignedSignatureProperties
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SignedSignatureProperties",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << i.signedSignatureProperties ();
      }

      // SignedDataObjectProperties
      //
      if (i.signedDataObjectProperties ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SignedDataObjectProperties",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.signedDataObjectProperties ();
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const UnsignedPropertiesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // UnsignedSignatureProperties
      //
      if (i.unsignedSignatureProperties ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnsignedSignatureProperties",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.unsignedSignatureProperties ();
      }

      // UnsignedDataObjectProperties
      //
      if (i.unsignedDataObjectProperties ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnsignedDataObjectProperties",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.unsignedDataObjectProperties ();
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SignedSignaturePropertiesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // SigningTime
      //
      if (i.signingTime ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SigningTime",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.signingTime ();
      }

      // SigningCertificate
      //
      if (i.signingCertificate ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SigningCertificate",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.signingCertificate ();
      }

      // SignaturePolicyIdentifier
      //
      if (i.signaturePolicyIdentifier ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SignaturePolicyIdentifier",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.signaturePolicyIdentifier ();
      }

      // SignatureProductionPlace
      //
      if (i.signatureProductionPlace ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SignatureProductionPlace",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.signatureProductionPlace ();
      }

      // SignerRole
      //
      if (i.signerRole ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SignerRole",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.signerRole ();
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SignedDataObjectPropertiesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // DataObjectFormat
      //
      for (SignedDataObjectPropertiesType::DataObjectFormatConstIterator
           b (i.dataObjectFormat ().begin ()), n (i.dataObjectFormat ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DataObjectFormat",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // CommitmentTypeIndication
      //
      for (SignedDataObjectPropertiesType::CommitmentTypeIndicationConstIterator
           b (i.commitmentTypeIndication ().begin ()), n (i.commitmentTypeIndication ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CommitmentTypeIndication",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // AllDataObjectsTimeStamp
      //
      for (SignedDataObjectPropertiesType::AllDataObjectsTimeStampConstIterator
           b (i.allDataObjectsTimeStamp ().begin ()), n (i.allDataObjectsTimeStamp ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AllDataObjectsTimeStamp",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // IndividualDataObjectsTimeStamp
      //
      for (SignedDataObjectPropertiesType::IndividualDataObjectsTimeStampConstIterator
           b (i.individualDataObjectsTimeStamp ().begin ()), n (i.individualDataObjectsTimeStamp ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "IndividualDataObjectsTimeStamp",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const UnsignedSignaturePropertiesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // CounterSignature
      //
      for (UnsignedSignaturePropertiesType::CounterSignatureConstIterator
           b (i.counterSignature ().begin ()), n (i.counterSignature ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CounterSignature",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // SignatureTimeStamp
      //
      for (UnsignedSignaturePropertiesType::SignatureTimeStampConstIterator
           b (i.signatureTimeStamp ().begin ()), n (i.signatureTimeStamp ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SignatureTimeStamp",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // CompleteCertificateRefs
      //
      for (UnsignedSignaturePropertiesType::CompleteCertificateRefsConstIterator
           b (i.completeCertificateRefs ().begin ()), n (i.completeCertificateRefs ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CompleteCertificateRefs",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // CompleteRevocationRefs
      //
      for (UnsignedSignaturePropertiesType::CompleteRevocationRefsConstIterator
           b (i.completeRevocationRefs ().begin ()), n (i.completeRevocationRefs ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CompleteRevocationRefs",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // AttributeCertificateRefs
      //
      for (UnsignedSignaturePropertiesType::AttributeCertificateRefsConstIterator
           b (i.attributeCertificateRefs ().begin ()), n (i.attributeCertificateRefs ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AttributeCertificateRefs",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // AttributeRevocationRefs
      //
      for (UnsignedSignaturePropertiesType::AttributeRevocationRefsConstIterator
           b (i.attributeRevocationRefs ().begin ()), n (i.attributeRevocationRefs ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AttributeRevocationRefs",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // SigAndRefsTimeStamp
      //
      for (UnsignedSignaturePropertiesType::SigAndRefsTimeStampConstIterator
           b (i.sigAndRefsTimeStamp ().begin ()), n (i.sigAndRefsTimeStamp ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SigAndRefsTimeStamp",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // RefsOnlyTimeStamp
      //
      for (UnsignedSignaturePropertiesType::RefsOnlyTimeStampConstIterator
           b (i.refsOnlyTimeStamp ().begin ()), n (i.refsOnlyTimeStamp ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RefsOnlyTimeStamp",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // CertificateValues
      //
      for (UnsignedSignaturePropertiesType::CertificateValuesConstIterator
           b (i.certificateValues ().begin ()), n (i.certificateValues ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CertificateValues",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // RevocationValues
      //
      for (UnsignedSignaturePropertiesType::RevocationValuesConstIterator
           b (i.revocationValues ().begin ()), n (i.revocationValues ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RevocationValues",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // AttrAuthoritiesCertValues
      //
      for (UnsignedSignaturePropertiesType::AttrAuthoritiesCertValuesConstIterator
           b (i.attrAuthoritiesCertValues ().begin ()), n (i.attrAuthoritiesCertValues ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AttrAuthoritiesCertValues",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // AttributeRevocationValues
      //
      for (UnsignedSignaturePropertiesType::AttributeRevocationValuesConstIterator
           b (i.attributeRevocationValues ().begin ()), n (i.attributeRevocationValues ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AttributeRevocationValues",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // ArchiveTimeStamp
      //
      for (UnsignedSignaturePropertiesType::ArchiveTimeStampConstIterator
           b (i.archiveTimeStamp ().begin ()), n (i.archiveTimeStamp ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ArchiveTimeStamp",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const UnsignedDataObjectPropertiesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // UnsignedDataObjectProperty
      //
      for (UnsignedDataObjectPropertiesType::UnsignedDataObjectPropertyConstIterator
           b (i.unsignedDataObjectProperty ().begin ()), n (i.unsignedDataObjectProperty ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnsignedDataObjectProperty",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const QualifyingPropertiesReferenceType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // URI
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "URI",
            e));

        a << i.uRI ();
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CertIDListType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Cert
      //
      for (CertIDListType::CertConstIterator
           b (i.cert ().begin ()), n (i.cert ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cert",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CertIDType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // CertDigest
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CertDigest",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << i.certDigest ();
      }

      // IssuerSerial
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "IssuerSerial",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << i.issuerSerial ();
      }

      // URI
      //
      if (i.uRI ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "URI",
            e));

        a << *i.uRI ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DigestAlgAndValueType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // DigestMethod
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DigestMethod",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << i.digestMethod ();
      }

      // DigestValue
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DigestValue",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << i.digestValue ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SignaturePolicyIdentifierType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // SignaturePolicyId
      //
      if (i.signaturePolicyId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SignaturePolicyId",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.signaturePolicyId ();
      }

      // SignaturePolicyImplied
      //
      if (i.signaturePolicyImplied ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SignaturePolicyImplied",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.signaturePolicyImplied ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SignaturePolicyIdType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // SigPolicyId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SigPolicyId",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << i.sigPolicyId ();
      }

      // Transforms
      //
      if (i.transforms ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transforms",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << *i.transforms ();
      }

      // SigPolicyHash
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SigPolicyHash",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << i.sigPolicyHash ();
      }

      // SigPolicyQualifiers
      //
      if (i.sigPolicyQualifiers ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SigPolicyQualifiers",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.sigPolicyQualifiers ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SigPolicyQualifiersListType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // SigPolicyQualifier
      //
      for (SigPolicyQualifiersListType::SigPolicyQualifierConstIterator
           b (i.sigPolicyQualifier ().begin ()), n (i.sigPolicyQualifier ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SigPolicyQualifier",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SPUserNoticeType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // NoticeRef
      //
      if (i.noticeRef ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "NoticeRef",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.noticeRef ();
      }

      // ExplicitText
      //
      if (i.explicitText ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ExplicitText",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.explicitText ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NoticeReferenceType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Organization
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Organization",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << i.organization ();
      }

      // NoticeNumbers
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "NoticeNumbers",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << i.noticeNumbers ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const IntegerListType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // int
      //
      for (IntegerListType::IntConstIterator
           b (i.int_ ().begin ()), n (i.int_ ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "int",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CounterSignatureType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Signature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Signature",
            "http://www.w3.org/2000/09/xmldsig#",
            e));

        s << i.signature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DataObjectFormatType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Description
      //
      if (i.description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Description",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.description ();
      }

      // ObjectIdentifier
      //
      if (i.objectIdentifier ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ObjectIdentifier",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.objectIdentifier ();
      }

      // MimeType
      //
      if (i.mimeType ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MimeType",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.mimeType ();
      }

      // Encoding
      //
      if (i.encoding ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Encoding",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.encoding ();
      }

      // ObjectReference
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ObjectReference",
            e));

        a << i.objectReference ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CommitmentTypeIndicationType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // CommitmentTypeId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CommitmentTypeId",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << i.commitmentTypeId ();
      }

      // ObjectReference
      //
      for (CommitmentTypeIndicationType::ObjectReferenceConstIterator
           b (i.objectReference ().begin ()), n (i.objectReference ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ObjectReference",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // AllSignedDataObjects
      //
      if (i.allSignedDataObjects ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AllSignedDataObjects",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.allSignedDataObjects ();
      }

      // CommitmentTypeQualifiers
      //
      if (i.commitmentTypeQualifiers ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CommitmentTypeQualifiers",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.commitmentTypeQualifiers ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CommitmentTypeQualifiersListType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // CommitmentTypeQualifier
      //
      for (CommitmentTypeQualifiersListType::CommitmentTypeQualifierConstIterator
           b (i.commitmentTypeQualifier ().begin ()), n (i.commitmentTypeQualifier ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CommitmentTypeQualifier",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SignatureProductionPlaceType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // City
      //
      if (i.city ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "City",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.city ();
      }

      // StateOrProvince
      //
      if (i.stateOrProvince ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "StateOrProvince",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.stateOrProvince ();
      }

      // PostalCode
      //
      if (i.postalCode ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PostalCode",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.postalCode ();
      }

      // CountryName
      //
      if (i.countryName ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CountryName",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.countryName ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SignerRoleType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // ClaimedRoles
      //
      if (i.claimedRoles ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ClaimedRoles",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.claimedRoles ();
      }

      // CertifiedRoles
      //
      if (i.certifiedRoles ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CertifiedRoles",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.certifiedRoles ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ClaimedRolesListType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // ClaimedRole
      //
      for (ClaimedRolesListType::ClaimedRoleConstIterator
           b (i.claimedRole ().begin ()), n (i.claimedRole ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ClaimedRole",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CertifiedRolesListType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // CertifiedRole
      //
      for (CertifiedRolesListType::CertifiedRoleConstIterator
           b (i.certifiedRole ().begin ()), n (i.certifiedRole ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CertifiedRole",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CompleteCertificateRefsType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // CertRefs
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CertRefs",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << i.certRefs ();
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CompleteRevocationRefsType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // CRLRefs
      //
      if (i.cRLRefs ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CRLRefs",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.cRLRefs ();
      }

      // OCSPRefs
      //
      if (i.oCSPRefs ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OCSPRefs",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.oCSPRefs ();
      }

      // OtherRefs
      //
      if (i.otherRefs ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherRefs",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.otherRefs ();
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CRLRefsType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // CRLRef
      //
      for (CRLRefsType::CRLRefConstIterator
           b (i.cRLRef ().begin ()), n (i.cRLRef ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CRLRef",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CRLRefType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // DigestAlgAndValue
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DigestAlgAndValue",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << i.digestAlgAndValue ();
      }

      // CRLIdentifier
      //
      if (i.cRLIdentifier ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CRLIdentifier",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.cRLIdentifier ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CRLIdentifierType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Issuer
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Issuer",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << i.issuer ();
      }

      // IssueTime
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "IssueTime",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << i.issueTime ();
      }

      // Number
      //
      if (i.number ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Number",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.number ();
      }

      // URI
      //
      if (i.uRI ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "URI",
            e));

        a << *i.uRI ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OCSPRefsType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // OCSPRef
      //
      for (OCSPRefsType::OCSPRefConstIterator
           b (i.oCSPRef ().begin ()), n (i.oCSPRef ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OCSPRef",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OCSPRefType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // OCSPIdentifier
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OCSPIdentifier",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << i.oCSPIdentifier ();
      }

      // DigestAlgAndValue
      //
      if (i.digestAlgAndValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DigestAlgAndValue",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.digestAlgAndValue ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ResponderIDType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // ByName
      //
      if (i.byName ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ByName",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.byName ();
      }

      // ByKey
      //
      if (i.byKey ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ByKey",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.byKey ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OCSPIdentifierType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // ResponderID
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ResponderID",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << i.responderID ();
      }

      // ProducedAt
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProducedAt",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << i.producedAt ();
      }

      // URI
      //
      if (i.uRI ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "URI",
            e));

        a << *i.uRI ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherCertStatusRefsType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // OtherRef
      //
      for (OtherCertStatusRefsType::OtherRefConstIterator
           b (i.otherRef ().begin ()), n (i.otherRef ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherRef",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CertificateValuesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EncapsulatedX509Certificate
      //
      for (CertificateValuesType::EncapsulatedX509CertificateConstIterator
           b (i.encapsulatedX509Certificate ().begin ()), n (i.encapsulatedX509Certificate ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EncapsulatedX509Certificate",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // OtherCertificate
      //
      for (CertificateValuesType::OtherCertificateConstIterator
           b (i.otherCertificate ().begin ()), n (i.otherCertificate ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherCertificate",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const RevocationValuesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // CRLValues
      //
      if (i.cRLValues ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CRLValues",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.cRLValues ();
      }

      // OCSPValues
      //
      if (i.oCSPValues ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OCSPValues",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.oCSPValues ();
      }

      // OtherValues
      //
      if (i.otherValues ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherValues",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *i.otherValues ();
      }

      // Id
      //
      if (i.id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Id",
            e));

        a << *i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CRLValuesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EncapsulatedCRLValue
      //
      for (CRLValuesType::EncapsulatedCRLValueConstIterator
           b (i.encapsulatedCRLValue ().begin ()), n (i.encapsulatedCRLValue ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EncapsulatedCRLValue",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OCSPValuesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EncapsulatedOCSPValue
      //
      for (OCSPValuesType::EncapsulatedOCSPValueConstIterator
           b (i.encapsulatedOCSPValue ().begin ()), n (i.encapsulatedOCSPValue ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EncapsulatedOCSPValue",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherCertStatusValuesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // OtherValue
      //
      for (OtherCertStatusValuesType::OtherValueConstIterator
           b (i.otherValue ().begin ()), n (i.otherValue ().end ());
           b != n; ++b)
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherValue",
            "http://uri.etsi.org/01903/v1.3.2#",
            e));

        s << *b;
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

